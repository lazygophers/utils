
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pgp: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lazygophers/utils/pgp/pgp.go (80.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pgp

import (
        "bytes"
        "crypto"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/ProtonMail/go-crypto/openpgp"
        "github.com/ProtonMail/go-crypto/openpgp/armor"
        "github.com/ProtonMail/go-crypto/openpgp/packet"
        "github.com/lazygophers/log"
)

// KeyPair 表示PGP密钥对
type KeyPair struct {
        PublicKey  string // PEM格式的公钥
        PrivateKey string // PEM格式的私钥
        entity     *openpgp.Entity
}

// GenerateOptions 密钥生成选项
type GenerateOptions struct {
        Name      string        // 姓名
        Comment   string        // 注释
        Email     string        // 邮箱地址
        KeyLength int           // RSA密钥长度，默认2048
        Hash      crypto.Hash   // 哈希算法，默认SHA256
        Cipher    packet.CipherFunction // 加密算法，默认AES256
}

// defaultGenerateOptions 返回默认生成选项
func defaultGenerateOptions() *GenerateOptions <span class="cov8" title="1">{
        return &amp;GenerateOptions{
                KeyLength: 2048,
                Hash:      crypto.SHA256,
                Cipher:    packet.CipherAES256,
        }
}</span>

// GenerateKeyPair 生成新的PGP密钥对
//
// 参数:
//   - opts: 生成选项，如果为nil则使用默认选项
//
// 返回:
//   - *KeyPair: 生成的密钥对
//   - error: 错误信息
//
// 示例:
//
//        opts := &amp;pgp.GenerateOptions{
//            Name:    "张三",
//            Email:   "zhangsan@example.com",
//            Comment: "测试密钥",
//        }
//        keyPair, err := pgp.GenerateKeyPair(opts)
func GenerateKeyPair(opts *GenerateOptions) (*KeyPair, error) <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = defaultGenerateOptions()
        }</span>
        
        // 设置默认值
        <span class="cov8" title="1">if opts.KeyLength == 0 </span><span class="cov8" title="1">{
                opts.KeyLength = 2048
        }</span>
        <span class="cov8" title="1">if opts.Hash == 0 </span><span class="cov8" title="1">{
                opts.Hash = crypto.SHA256
        }</span>
        <span class="cov8" title="1">if opts.Cipher == 0 </span><span class="cov8" title="1">{
                opts.Cipher = packet.CipherAES256
        }</span>

        <span class="cov8" title="1">config := &amp;packet.Config{
                DefaultHash:   opts.Hash,
                DefaultCipher: opts.Cipher,
                RSABits:       opts.KeyLength,
                Time:          func() time.Time </span><span class="cov8" title="1">{ return time.Now() }</span>,
        }

        <span class="cov8" title="1">entity, err := openpgp.NewEntity(opts.Name, opts.Comment, opts.Email, config)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("生成PGP实体失败: %v", err)
                return nil, fmt.Errorf("生成PGP实体失败: %w", err)
        }</span>

        // 自签名用户ID
        <span class="cov8" title="1">for _, identity := range entity.Identities </span><span class="cov8" title="1">{
                err = identity.SelfSignature.SignUserId(identity.UserId.Id, entity.PrimaryKey, entity.PrivateKey, config)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("签名用户ID失败: %v", err)
                        return nil, fmt.Errorf("签名用户ID失败: %w", err)
                }</span>
        }

        <span class="cov8" title="1">keyPair := &amp;KeyPair{entity: entity}

        // 序列化公钥
        publicKeyBuf := &amp;bytes.Buffer{}
        publicKeyWriter, err := armor.Encode(publicKeyBuf, openpgp.PublicKeyType, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("创建公钥armor编码器失败: %v", err)
                return nil, fmt.Errorf("创建公钥armor编码器失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">err = entity.Serialize(publicKeyWriter)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("序列化公钥失败: %v", err)
                return nil, fmt.Errorf("序列化公钥失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">err = publicKeyWriter.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("关闭公钥写入器失败: %v", err)
                return nil, fmt.Errorf("关闭公钥写入器失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">keyPair.PublicKey = publicKeyBuf.String()

        // 序列化私钥
        privateKeyBuf := &amp;bytes.Buffer{}
        privateKeyWriter, err := armor.Encode(privateKeyBuf, openpgp.PrivateKeyType, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("创建私钥armor编码器失败: %v", err)
                return nil, fmt.Errorf("创建私钥armor编码器失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">err = entity.SerializePrivate(privateKeyWriter, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("序列化私钥失败: %v", err)
                return nil, fmt.Errorf("序列化私钥失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">err = privateKeyWriter.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("关闭私钥写入器失败: %v", err)
                return nil, fmt.Errorf("关闭私钥写入器失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">keyPair.PrivateKey = privateKeyBuf.String()

        log.Infof("成功生成PGP密钥对: %s &lt;%s&gt;", opts.Name, opts.Email)
        return keyPair, nil</span>
}

// ReadPublicKey 从PEM格式字符串读取公钥
//
// 参数:
//   - publicKeyPEM: PEM格式的公钥字符串
//
// 返回:
//   - openpgp.EntityList: 解析后的实体列表
//   - error: 错误信息
func ReadPublicKey(publicKeyPEM string) (openpgp.EntityList, error) <span class="cov8" title="1">{
        block, err := armor.Decode(strings.NewReader(publicKeyPEM))
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("解码公钥armor失败: %v", err)
                return nil, fmt.Errorf("解码公钥armor失败: %w", err)
        }</span>

        <span class="cov8" title="1">if block.Type != openpgp.PublicKeyType </span><span class="cov8" title="1">{
                err = fmt.Errorf("无效的公钥类型: %s", block.Type)
                log.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">entityList, err := openpgp.ReadKeyRing(block.Body)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("读取公钥环失败: %v", err)
                return nil, fmt.Errorf("读取公钥环失败: %w", err)
        }</span>

        <span class="cov8" title="1">return entityList, nil</span>
}

// ReadPrivateKey 从PEM格式字符串读取私钥
//
// 参数:
//   - privateKeyPEM: PEM格式的私钥字符串
//   - passphrase: 私钥密码，如果私钥未加密则为空字符串
//
// 返回:
//   - openpgp.EntityList: 解析后的实体列表
//   - error: 错误信息
func ReadPrivateKey(privateKeyPEM, passphrase string) (openpgp.EntityList, error) <span class="cov8" title="1">{
        block, err := armor.Decode(strings.NewReader(privateKeyPEM))
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("解码私钥armor失败: %v", err)
                return nil, fmt.Errorf("解码私钥armor失败: %w", err)
        }</span>

        <span class="cov8" title="1">if block.Type != openpgp.PrivateKeyType </span><span class="cov8" title="1">{
                err = fmt.Errorf("无效的私钥类型: %s", block.Type)
                log.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">entityList, err := openpgp.ReadKeyRing(block.Body)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("读取私钥环失败: %v", err)
                return nil, fmt.Errorf("读取私钥环失败: %w", err)
        }</span>

        // 如果私钥有密码保护，需要解密
        <span class="cov8" title="1">if passphrase != "" </span><span class="cov8" title="1">{
                for _, entity := range entityList </span><span class="cov8" title="1">{
                        if entity.PrivateKey != nil &amp;&amp; entity.PrivateKey.Encrypted </span><span class="cov0" title="0">{
                                err = entity.PrivateKey.Decrypt([]byte(passphrase))
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Errorf("解密私钥失败: %v", err)
                                        return nil, fmt.Errorf("解密私钥失败: %w", err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return entityList, nil</span>
}

// ReadKeyPair 从PEM格式字符串读取密钥对
//
// 参数:
//   - publicKeyPEM: PEM格式的公钥字符串
//   - privateKeyPEM: PEM格式的私钥字符串
//   - passphrase: 私钥密码，如果私钥未加密则为空字符串
//
// 返回:
//   - *KeyPair: 读取的密钥对
//   - error: 错误信息
func ReadKeyPair(publicKeyPEM, privateKeyPEM, passphrase string) (*KeyPair, error) <span class="cov8" title="1">{
        // 读取私钥
        privateEntities, err := ReadPrivateKey(privateKeyPEM, passphrase)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 读取公钥  
        <span class="cov8" title="1">publicEntities, err := ReadPublicKey(publicKeyPEM)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 验证密钥对匹配
        <span class="cov8" title="1">if len(privateEntities) == 0 || len(publicEntities) == 0 </span><span class="cov8" title="1">{
                err = fmt.Errorf("密钥对不完整")
                log.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;KeyPair{
                PublicKey:  publicKeyPEM,
                PrivateKey: privateKeyPEM,
                entity:     privateEntities[0], // 使用第一个实体
        }, nil</span>
}

// Encrypt 使用公钥加密数据
//
// 参数:
//   - data: 要加密的数据
//   - publicKeyPEM: PEM格式的公钥字符串
//
// 返回:
//   - []byte: 加密后的数据
//   - error: 错误信息
//
// 示例:
//
//        encrypted, err := pgp.Encrypt([]byte("敏感信息"), publicKeyPEM)
func Encrypt(data []byte, publicKeyPEM string) ([]byte, error) <span class="cov8" title="1">{
        entities, err := ReadPublicKey(publicKeyPEM)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return EncryptWithEntities(data, entities)</span>
}

// EncryptWithEntities 使用实体列表加密数据
//
// 参数:
//   - data: 要加密的数据
//   - entities: PGP实体列表
//
// 返回:
//   - []byte: 加密后的数据
//   - error: 错误信息
func EncryptWithEntities(data []byte, entities openpgp.EntityList) ([]byte, error) <span class="cov8" title="1">{
        if len(entities) == 0 </span><span class="cov8" title="1">{
                err := fmt.Errorf("实体列表不能为空")
                log.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">buf := &amp;bytes.Buffer{}

        // 创建加密写入器
        encryptWriter, err := openpgp.Encrypt(buf, entities, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("创建加密写入器失败: %v", err)
                return nil, fmt.Errorf("创建加密写入器失败: %w", err)
        }</span>

        // 写入数据
        <span class="cov8" title="1">_, err = encryptWriter.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("写入加密数据失败: %v", err)
                return nil, fmt.Errorf("写入加密数据失败: %w", err)
        }</span>

        // 关闭写入器
        <span class="cov8" title="1">err = encryptWriter.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("关闭加密写入器失败: %v", err)
                return nil, fmt.Errorf("关闭加密写入器失败: %w", err)
        }</span>

        <span class="cov8" title="1">log.Debugf("成功加密 %d 字节数据", len(data))
        return buf.Bytes(), nil</span>
}

// Decrypt 使用私钥解密数据
//
// 参数:
//   - encryptedData: 加密的数据
//   - privateKeyPEM: PEM格式的私钥字符串
//   - passphrase: 私钥密码，如果私钥未加密则为空字符串
//
// 返回:
//   - []byte: 解密后的数据
//   - error: 错误信息
//
// 示例:
//
//        decrypted, err := pgp.Decrypt(encryptedData, privateKeyPEM, "")
func Decrypt(encryptedData []byte, privateKeyPEM, passphrase string) ([]byte, error) <span class="cov8" title="1">{
        entities, err := ReadPrivateKey(privateKeyPEM, passphrase)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return DecryptWithEntities(encryptedData, entities)</span>
}

// DecryptWithEntities 使用实体列表解密数据
//
// 参数:
//   - encryptedData: 加密的数据
//   - entities: PGP实体列表
//
// 返回:
//   - []byte: 解密后的数据
//   - error: 错误信息
func DecryptWithEntities(encryptedData []byte, entities openpgp.EntityList) ([]byte, error) <span class="cov8" title="1">{
        if len(entities) == 0 </span><span class="cov8" title="1">{
                err := fmt.Errorf("实体列表不能为空")
                log.Error(err.Error())
                return nil, err
        }</span>

        // 读取加密消息
        <span class="cov8" title="1">messageReader, err := openpgp.ReadMessage(bytes.NewReader(encryptedData), entities, nil, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("读取加密消息失败: %v", err)
                return nil, fmt.Errorf("读取加密消息失败: %w", err)
        }</span>

        // 读取解密数据
        <span class="cov8" title="1">decryptedData, err := io.ReadAll(messageReader.UnverifiedBody)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("读取解密数据失败: %v", err)
                return nil, fmt.Errorf("读取解密数据失败: %w", err)
        }</span>

        <span class="cov8" title="1">log.Debugf("成功解密 %d 字节数据", len(decryptedData))
        return decryptedData, nil</span>
}

// EncryptText 加密数据并返回ASCII armor格式
//
// 参数:
//   - data: 要加密的数据
//   - publicKeyPEM: PEM格式的公钥字符串
//
// 返回:
//   - string: ASCII armor格式的加密数据
//   - error: 错误信息
func EncryptText(data []byte, publicKeyPEM string) (string, error) <span class="cov8" title="1">{
        entities, err := ReadPublicKey(publicKeyPEM)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">buf := &amp;bytes.Buffer{}

        // 创建armor编码器
        armorWriter, err := armor.Encode(buf, "PGP MESSAGE", nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("创建armor编码器失败: %v", err)
                return "", fmt.Errorf("创建armor编码器失败: %w", err)
        }</span>

        // 创建加密写入器
        <span class="cov8" title="1">encryptWriter, err := openpgp.Encrypt(armorWriter, entities, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("创建加密写入器失败: %v", err)
                return "", fmt.Errorf("创建加密写入器失败: %w", err)
        }</span>

        // 写入数据
        <span class="cov8" title="1">_, err = encryptWriter.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("写入加密数据失败: %v", err)
                return "", fmt.Errorf("写入加密数据失败: %w", err)
        }</span>

        // 关闭写入器
        <span class="cov8" title="1">err = encryptWriter.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("关闭加密写入器失败: %v", err)
                return "", fmt.Errorf("关闭加密写入器失败: %w", err)
        }</span>

        <span class="cov8" title="1">err = armorWriter.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("关闭armor编码器失败: %v", err)
                return "", fmt.Errorf("关闭armor编码器失败: %w", err)
        }</span>

        <span class="cov8" title="1">return buf.String(), nil</span>
}

// DecryptText 解密ASCII armor格式的数据
//
// 参数:
//   - encryptedText: ASCII armor格式的加密文本
//   - privateKeyPEM: PEM格式的私钥字符串
//   - passphrase: 私钥密码，如果私钥未加密则为空字符串
//
// 返回:
//   - []byte: 解密后的数据
//   - error: 错误信息
func DecryptText(encryptedText, privateKeyPEM, passphrase string) ([]byte, error) <span class="cov8" title="1">{
        entities, err := ReadPrivateKey(privateKeyPEM, passphrase)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 解码armor
        <span class="cov8" title="1">block, err := armor.Decode(strings.NewReader(encryptedText))
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("解码armor失败: %v", err)
                return nil, fmt.Errorf("解码armor失败: %w", err)
        }</span>

        <span class="cov8" title="1">if block.Type != "PGP MESSAGE" </span><span class="cov8" title="1">{
                err = fmt.Errorf("无效的消息类型: %s", block.Type)
                log.Error(err.Error())
                return nil, err
        }</span>

        // 读取加密消息
        <span class="cov8" title="1">messageReader, err := openpgp.ReadMessage(block.Body, entities, nil, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("读取加密消息失败: %v", err)
                return nil, fmt.Errorf("读取加密消息失败: %w", err)
        }</span>

        // 读取解密数据
        <span class="cov8" title="1">decryptedData, err := io.ReadAll(messageReader.UnverifiedBody)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("读取解密数据失败: %v", err)
                return nil, fmt.Errorf("读取解密数据失败: %w", err)
        }</span>

        <span class="cov8" title="1">return decryptedData, nil</span>
}

// GetFingerprint 获取密钥指纹
//
// 参数:
//   - keyPEM: PEM格式的密钥字符串（公钥或私钥）
//
// 返回:
//   - string: 密钥指纹（十六进制字符串）
//   - error: 错误信息
func GetFingerprint(keyPEM string) (string, error) <span class="cov8" title="1">{
        var entityList openpgp.EntityList
        var err error

        // 尝试作为公钥解析
        if strings.Contains(keyPEM, "PUBLIC KEY") </span><span class="cov8" title="1">{
                entityList, err = ReadPublicKey(keyPEM)
        }</span> else<span class="cov8" title="1"> if strings.Contains(keyPEM, "PRIVATE KEY") </span><span class="cov8" title="1">{
                entityList, err = ReadPrivateKey(keyPEM, "")
        }</span> else<span class="cov8" title="1"> {
                err = fmt.Errorf("无法识别的密钥格式")
                log.Error(err.Error())
                return "", err
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if len(entityList) == 0 </span><span class="cov8" title="1">{
                err = fmt.Errorf("没有找到有效的密钥")
                log.Error(err.Error())
                return "", err
        }</span>

        <span class="cov8" title="1">fingerprint := fmt.Sprintf("%X", entityList[0].PrimaryKey.Fingerprint)
        return fingerprint, nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
