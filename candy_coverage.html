
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>candy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lazygophers/utils/candy/abs.go (100.0%)</option>
				
				<option value="file1">github.com/lazygophers/utils/candy/all.go (100.0%)</option>
				
				<option value="file2">github.com/lazygophers/utils/candy/any.go (100.0%)</option>
				
				<option value="file3">github.com/lazygophers/utils/candy/average.go (100.0%)</option>
				
				<option value="file4">github.com/lazygophers/utils/candy/bottom.go (100.0%)</option>
				
				<option value="file5">github.com/lazygophers/utils/candy/cbrt.go (100.0%)</option>
				
				<option value="file6">github.com/lazygophers/utils/candy/chunk.go (100.0%)</option>
				
				<option value="file7">github.com/lazygophers/utils/candy/contains.go (100.0%)</option>
				
				<option value="file8">github.com/lazygophers/utils/candy/contains_using.go (100.0%)</option>
				
				<option value="file9">github.com/lazygophers/utils/candy/deep_copy.go (92.9%)</option>
				
				<option value="file10">github.com/lazygophers/utils/candy/deep_equal.go (98.1%)</option>
				
				<option value="file11">github.com/lazygophers/utils/candy/diff.go (100.0%)</option>
				
				<option value="file12">github.com/lazygophers/utils/candy/diff_slice.go (100.0%)</option>
				
				<option value="file13">github.com/lazygophers/utils/candy/drop.go (100.0%)</option>
				
				<option value="file14">github.com/lazygophers/utils/candy/each.go (100.0%)</option>
				
				<option value="file15">github.com/lazygophers/utils/candy/each_reverse.go (100.0%)</option>
				
				<option value="file16">github.com/lazygophers/utils/candy/each_stop_with_error.go (100.0%)</option>
				
				<option value="file17">github.com/lazygophers/utils/candy/filter.go (100.0%)</option>
				
				<option value="file18">github.com/lazygophers/utils/candy/filter_not.go (100.0%)</option>
				
				<option value="file19">github.com/lazygophers/utils/candy/first.go (100.0%)</option>
				
				<option value="file20">github.com/lazygophers/utils/candy/first_or.go (100.0%)</option>
				
				<option value="file21">github.com/lazygophers/utils/candy/index.go (100.0%)</option>
				
				<option value="file22">github.com/lazygophers/utils/candy/join.go (100.0%)</option>
				
				<option value="file23">github.com/lazygophers/utils/candy/last.go (100.0%)</option>
				
				<option value="file24">github.com/lazygophers/utils/candy/last_or.go (100.0%)</option>
				
				<option value="file25">github.com/lazygophers/utils/candy/map.go (100.0%)</option>
				
				<option value="file26">github.com/lazygophers/utils/candy/max.go (100.0%)</option>
				
				<option value="file27">github.com/lazygophers/utils/candy/min.go (100.0%)</option>
				
				<option value="file28">github.com/lazygophers/utils/candy/pluck_int.go (97.5%)</option>
				
				<option value="file29">github.com/lazygophers/utils/candy/pluck_int32.go (100.0%)</option>
				
				<option value="file30">github.com/lazygophers/utils/candy/pluck_int64.go (100.0%)</option>
				
				<option value="file31">github.com/lazygophers/utils/candy/pluck_string.go (100.0%)</option>
				
				<option value="file32">github.com/lazygophers/utils/candy/pluck_string_slice.go (100.0%)</option>
				
				<option value="file33">github.com/lazygophers/utils/candy/pluck_uint32.go (100.0%)</option>
				
				<option value="file34">github.com/lazygophers/utils/candy/pluck_uint64.go (100.0%)</option>
				
				<option value="file35">github.com/lazygophers/utils/candy/pow.go (100.0%)</option>
				
				<option value="file36">github.com/lazygophers/utils/candy/random.go (100.0%)</option>
				
				<option value="file37">github.com/lazygophers/utils/candy/reduce.go (100.0%)</option>
				
				<option value="file38">github.com/lazygophers/utils/candy/remove.go (100.0%)</option>
				
				<option value="file39">github.com/lazygophers/utils/candy/remove_index.go (100.0%)</option>
				
				<option value="file40">github.com/lazygophers/utils/candy/remove_slice.go (100.0%)</option>
				
				<option value="file41">github.com/lazygophers/utils/candy/reverse.go (100.0%)</option>
				
				<option value="file42">github.com/lazygophers/utils/candy/same.go (100.0%)</option>
				
				<option value="file43">github.com/lazygophers/utils/candy/shuffle.go (100.0%)</option>
				
				<option value="file44">github.com/lazygophers/utils/candy/slice_equal.go (94.1%)</option>
				
				<option value="file45">github.com/lazygophers/utils/candy/sort.go (100.0%)</option>
				
				<option value="file46">github.com/lazygophers/utils/candy/sort_using.go (100.0%)</option>
				
				<option value="file47">github.com/lazygophers/utils/candy/spare.go (100.0%)</option>
				
				<option value="file48">github.com/lazygophers/utils/candy/sqrt.go (100.0%)</option>
				
				<option value="file49">github.com/lazygophers/utils/candy/string.go (100.0%)</option>
				
				<option value="file50">github.com/lazygophers/utils/candy/sum.go (100.0%)</option>
				
				<option value="file51">github.com/lazygophers/utils/candy/to_array_string.go (100.0%)</option>
				
				<option value="file52">github.com/lazygophers/utils/candy/to_bool.go (100.0%)</option>
				
				<option value="file53">github.com/lazygophers/utils/candy/to_bytes.go (100.0%)</option>
				
				<option value="file54">github.com/lazygophers/utils/candy/to_float32.go (100.0%)</option>
				
				<option value="file55">github.com/lazygophers/utils/candy/to_float64.go (100.0%)</option>
				
				<option value="file56">github.com/lazygophers/utils/candy/to_float64_slice.go (100.0%)</option>
				
				<option value="file57">github.com/lazygophers/utils/candy/to_int.go (100.0%)</option>
				
				<option value="file58">github.com/lazygophers/utils/candy/to_int16.go (100.0%)</option>
				
				<option value="file59">github.com/lazygophers/utils/candy/to_int32.go (100.0%)</option>
				
				<option value="file60">github.com/lazygophers/utils/candy/to_int64.go (100.0%)</option>
				
				<option value="file61">github.com/lazygophers/utils/candy/to_int64_slice.go (100.0%)</option>
				
				<option value="file62">github.com/lazygophers/utils/candy/to_int8.go (100.0%)</option>
				
				<option value="file63">github.com/lazygophers/utils/candy/to_map.go (100.0%)</option>
				
				<option value="file64">github.com/lazygophers/utils/candy/to_map_int32_string.go (100.0%)</option>
				
				<option value="file65">github.com/lazygophers/utils/candy/to_map_int64_string.go (100.0%)</option>
				
				<option value="file66">github.com/lazygophers/utils/candy/to_map_string_any.go (100.0%)</option>
				
				<option value="file67">github.com/lazygophers/utils/candy/to_map_string_array_string.go (100.0%)</option>
				
				<option value="file68">github.com/lazygophers/utils/candy/to_map_string_int64.go (100.0%)</option>
				
				<option value="file69">github.com/lazygophers/utils/candy/to_map_string_string.go (100.0%)</option>
				
				<option value="file70">github.com/lazygophers/utils/candy/to_ptr.go (100.0%)</option>
				
				<option value="file71">github.com/lazygophers/utils/candy/to_string.go (100.0%)</option>
				
				<option value="file72">github.com/lazygophers/utils/candy/to_string_slice.go (100.0%)</option>
				
				<option value="file73">github.com/lazygophers/utils/candy/to_uint.go (100.0%)</option>
				
				<option value="file74">github.com/lazygophers/utils/candy/to_uint16.go (100.0%)</option>
				
				<option value="file75">github.com/lazygophers/utils/candy/to_uint32.go (100.0%)</option>
				
				<option value="file76">github.com/lazygophers/utils/candy/to_uint64.go (100.0%)</option>
				
				<option value="file77">github.com/lazygophers/utils/candy/to_uint8.go (100.0%)</option>
				
				<option value="file78">github.com/lazygophers/utils/candy/top.go (100.0%)</option>
				
				<option value="file79">github.com/lazygophers/utils/candy/unique.go (100.0%)</option>
				
				<option value="file80">github.com/lazygophers/utils/candy/unique_using.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Abs 计算数值的绝对值
func Abs[T constraints.Integer | constraints.Float](s T) T <span class="cov8" title="1">{
        if s &lt; 0 </span><span class="cov8" title="1">{
                return -s
        }</span>

        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package candy

// All 检查切片中的所有元素是否都满足指定条件
func All[T any](ss []T, f func(T) bool) bool <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">for _, s := range ss </span><span class="cov8" title="1">{
                if !f(s) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package candy

// Any 检查切片中是否存在至少一个元素满足指定条件
func Any[T any](ss []T, f func(T) bool) bool <span class="cov8" title="1">{
        for _, s := range ss </span><span class="cov8" title="1">{
                if f(s) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package candy

import "golang.org/x/exp/constraints"

// Average 计算数值切片的平均值
func Average[T constraints.Integer | constraints.Float](ss []T) (ret T) <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">var sum float64
        for _, s := range ss </span><span class="cov8" title="1">{
                sum += float64(s)
        }</span>
        <span class="cov8" title="1">return T(sum / float64(len(ss)))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package candy

// Bottom 返回切片的最后 n 个元素
func Bottom[T any](ss []T, n int) (ret []T) <span class="cov8" title="1">{
        if n &lt;= 0 </span><span class="cov8" title="1">{
                return []T{}
        }</span>
        <span class="cov8" title="1">if n &gt; len(ss) </span><span class="cov8" title="1">{
                n = len(ss)
        }</span>

        <span class="cov8" title="1">ret = make([]T, n)
        copy(ret, ss[len(ss)-n:])
        return ret</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package candy

import (
        "math"

        "golang.org/x/exp/constraints"
)

// Cbrt 计算数值的立方根
func Cbrt[T constraints.Integer | constraints.Float](s T) T <span class="cov8" title="1">{
        return T(math.Cbrt(float64(s)))
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package candy

// Chunk 将切片分割成指定大小的子切片
func Chunk[T any](ss []T, size int) (ret [][]T) <span class="cov8" title="1">{
        if len(ss) == 0 || size &lt;= 0 </span><span class="cov8" title="1">{
                return [][]T{}
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(ss); i += size </span><span class="cov8" title="1">{
                end := i + size
                if end &gt; len(ss) </span><span class="cov8" title="1">{
                        end = len(ss)
                }</span>

                <span class="cov8" title="1">ret = append(ret, ss[i:end])</span>
        }

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Contains 检查切片中是否包含指定元素
func Contains[T constraints.Ordered](ss []T, s T) bool <span class="cov8" title="1">{
        return ContainsUsing(ss, func(v T) bool </span><span class="cov8" title="1">{
                return s == v
        }</span>)
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package candy 提供了常用的工具函数和语法糖，简化日常 Go 开发中的常见操作
package candy

// ContainsUsing 使用自定义函数检查切片中是否包含满足条件的元素
//
// 泛型约束：T 可以是任意类型
// 参数：
//   - ss: 要搜索的切片
//   - f: 判断函数，如果函数返回 true，则表示找到匹配的元素
//
// 返回值：
//   - bool: 如果找到满足条件的元素返回 true，否则返回 false
//
// 示例：
//
//        numbers := []int{1, 2, 3, 4, 5}
//        found := ContainsUsing(numbers, func(v int) bool {
//            return v &gt; 3
//        }) // 返回 true
func ContainsUsing[T any](ss []T, f func(v T) bool) bool <span class="cov8" title="1">{
        // 遍历切片中的每个元素
        for _, v := range ss </span><span class="cov8" title="1">{
                // 使用自定义函数判断当前元素是否满足条件
                if f(v) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // 遍历完所有元素都没有找到满足条件的，返回 false
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package candy

import (
        "reflect"

        "github.com/lazygophers/log"
)

// deepCopyValue 是 DeepCopy 的内部实现核心。
// 它接收两个 reflect.Value (v1 为源, v2 为目标)，并递归地将内容从 v1 拷贝到 v2。
//
// 注意：此函数为 unexported，不应在包外直接调用。
func deepCopyValue(v1, v2 reflect.Value) <span class="cov8" title="1">{
        if !v1.IsValid() || !v2.IsValid() </span><span class="cov8" title="1">{
                return
        }</span>

        // 解引用指针，直到获取到实际的值
        <span class="cov8" title="1">for v1.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                // 如果源指针是 nil，则无需继续
                if v1.IsNil() </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">v1 = v1.Elem()</span>
        }
        <span class="cov8" title="1">for v2.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                // 如果目标指针是 nil，则为其分配新内存
                if v2.IsNil() </span><span class="cov8" title="1">{
                        v2.Set(reflect.New(v2.Type().Elem()))
                }</span>
                <span class="cov8" title="1">v2 = v2.Elem()</span>
        }

        // 确保解引用后值仍然有效
        <span class="cov8" title="1">if v1.Kind() == reflect.Invalid || v2.Kind() == reflect.Invalid </span><span class="cov0" title="0">{
                return
        }</span>

        // 类型必须匹配才能拷贝
        <span class="cov8" title="1">if v1.Type() != v2.Type() </span><span class="cov8" title="1">{
                log.Panicf("源类型 %s 与目标类型 %s 不匹配", v1.Type(), v2.Type())
        }</span>

        <span class="cov8" title="1">switch v1.Kind() </span>{
        // 拷贝 Map
        case reflect.Map:<span class="cov8" title="1">
                if v1.IsNil() </span><span class="cov8" title="1">{
                        v2.Set(reflect.Zero(v2.Type()))
                        return
                }</span>
                // 为目标 Map 创建实例
                <span class="cov8" title="1">v2.Set(reflect.MakeMap(v1.Type()))
                // 遍历 Map 并递归拷贝每一个键值对
                for _, k := range v1.MapKeys() </span><span class="cov8" title="1">{
                        val1 := v1.MapIndex(k)
                        val2 := reflect.New(val1.Type()).Elem()
                        deepCopyValue(val1, val2)
                        v2.SetMapIndex(k, val2)
                }</span>

        // 拷贝 Slice
        case reflect.Slice:<span class="cov8" title="1">
                if v1.IsNil() </span><span class="cov8" title="1">{
                        v2.Set(reflect.Zero(v2.Type()))
                        return
                }</span>
                // 为目标 Slice 创建实例
                <span class="cov8" title="1">v2.Set(reflect.MakeSlice(v1.Type(), v1.Len(), v1.Cap()))
                // 遍历 Slice 并递归拷贝每一个元素
                for i := 0; i &lt; v1.Len(); i++ </span><span class="cov8" title="1">{
                        deepCopyValue(v1.Index(i), v2.Index(i))
                }</span>

        // 拷贝 Array
        case reflect.Array:<span class="cov8" title="1">
                // 遍历 Array 并递归拷贝每一个元素
                for i := 0; i &lt; v1.Len(); i++ </span><span class="cov8" title="1">{
                        deepCopyValue(v1.Index(i), v2.Index(i))
                }</span>

        // 拷贝 Struct
        case reflect.Struct:<span class="cov8" title="1">
                // 遍历 Struct 并递归拷贝每一个字段
                for i := 0; i &lt; v1.NumField(); i++ </span><span class="cov8" title="1">{
                        deepCopyValue(v1.Field(i), v2.Field(i))
                }</span>

        // 拷贝 Interface
        case reflect.Interface:<span class="cov8" title="1">
                if v1.IsNil() </span><span class="cov8" title="1">{
                        return
                }</span>
                // 获取接口的实际值
                <span class="cov8" title="1">srcElem := v1.Elem()
                // 创建一个新的目标值，类型与源相同
                dstElem := reflect.New(srcElem.Type()).Elem()
                // 递归拷贝
                deepCopyValue(srcElem, dstElem)
                // 将拷贝后的值设置给目标接口
                v2.Set(dstElem)</span>

        // 拷贝基本类型
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                if v2.CanSet() </span><span class="cov8" title="1">{
                        v2.SetInt(v1.Int())
                }</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                if v2.CanSet() </span><span class="cov0" title="0">{
                        v2.SetUint(v1.Uint())
                }</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                if v2.CanSet() </span><span class="cov0" title="0">{
                        v2.SetFloat(v1.Float())
                }</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov8" title="1">
                if v2.CanSet() </span><span class="cov0" title="0">{
                        v2.SetComplex(v1.Complex())
                }</span>
        case reflect.String:<span class="cov8" title="1">
                if v2.CanSet() </span><span class="cov8" title="1">{
                        v2.SetString(v1.String())
                }</span>
        case reflect.Bool:<span class="cov8" title="1">
                if v2.CanSet() </span><span class="cov8" title="1">{
                        v2.SetBool(v1.Bool())
                }</span>

        case reflect.Invalid:<span class="cov0" title="0"></span>
                // 无效类型，不处理

        default:<span class="cov8" title="1">
                // 对于未处理的类型，直接 panic
                log.Panicf("未处理的类型: %s", v1.Kind())</span>
        }
}

// DeepCopy 通过深度递归的方式，将源对象 `src` 的内容完全复制到目标对象 `dst`。
//
// 此函数会创建一个源对象的完整、独立的副本。修改副本不会对原始对象产生任何影响。
// 它能够处理 Maps、Slices、Pointers、Structs 等各种复杂类型。
//
// **重要提示**:
// 参数 `dst` **必须**是一个指向目标对象的指针，且该指针必须已经被初始化（例如，通过 `new` 或 `&amp;`）。
// 如果 `dst` 是一个 nil 指针或者不是指针类型，函数将在运行时引发 `panic`，因为无法向无效的内存地址写入数据。
//
// 示例：
//
//        var src = map[string]int{"a": 1}
//        var dst map[string]int
//        DeepCopy(src, &amp;dst) // 正确用法
//
// @param src 源对象，待拷贝的数据。
// @param dst 目标对象的指针，用于接收拷贝后的数据。
func DeepCopy[M any](src, dst M) <span class="cov8" title="1">{
        v1 := reflect.ValueOf(src)
        v2 := reflect.ValueOf(dst)
        deepCopyValue(v1, v2)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package candy

import "reflect"

// deepValueEqual 是 DeepEqual 的内部实现核心。
// 它接收两个 reflect.Value，并递归地对它们进行深度比较。
//
// 注意：此函数为 unexported，不应在包外直接调用。
func deepValueEqual(v1, v2 reflect.Value) bool <span class="cov8" title="1">{
        // 检查值是否有效
        if !v1.IsValid() || !v2.IsValid() </span><span class="cov8" title="1">{
                return v1.IsValid() == v2.IsValid()
        }</span>

        // 比较类型是否一致
        <span class="cov8" title="1">if v1.Type() != v2.Type() </span><span class="cov8" title="1">{
                return false
        }</span>

        // 根据值的类型进行分类比较
        <span class="cov8" title="1">switch v1.Kind() </span>{
        // 比较 Map
        case reflect.Map:<span class="cov8" title="1">
                // 检查是否为 nil
                if v1.IsNil() || v2.IsNil() </span><span class="cov8" title="1">{
                        return v1.IsNil() == v2.IsNil()
                }</span>
                // 比较长度
                <span class="cov8" title="1">if v1.Len() != v2.Len() </span><span class="cov8" title="1">{
                        return false
                }</span>
                // 如果指针相同，则内容必然相同
                <span class="cov8" title="1">if v1.UnsafePointer() == v2.UnsafePointer() </span><span class="cov8" title="1">{
                        return true
                }</span>
                // 递归比较每一个键值对
                <span class="cov8" title="1">for _, k := range v1.MapKeys() </span><span class="cov8" title="1">{
                        val1 := v1.MapIndex(k)
                        val2 := v2.MapIndex(k)
                        if !val1.IsValid() || !val2.IsValid() || !deepValueEqual(val1, val2) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>

        // 比较 Slice
        case reflect.Slice:<span class="cov8" title="1">
                // 检查 nil 状态是否一致
                if v1.IsNil() != v2.IsNil() </span><span class="cov8" title="1">{
                        return false
                }</span>
                // 比较长度
                <span class="cov8" title="1">if v1.Len() != v2.Len() </span><span class="cov8" title="1">{
                        return false
                }</span>
                // 如果指针相同，则内容必然相同
                <span class="cov8" title="1">if v1.UnsafePointer() == v2.UnsafePointer() </span><span class="cov8" title="1">{
                        return true
                }</span>
                // 递归比较每一个元素
                <span class="cov8" title="1">for i := 0; i &lt; v1.Len(); i++ </span><span class="cov8" title="1">{
                        if !deepValueEqual(v1.Index(i), v2.Index(i)) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>

        // 比较指针
        case reflect.Ptr:<span class="cov8" title="1">
                // 检查是否为 nil
                if v1.IsNil() || v2.IsNil() </span><span class="cov8" title="1">{
                        return v1.IsNil() == v2.IsNil()
                }</span>
                // 递归比较指针指向的元素
                <span class="cov8" title="1">return deepValueEqual(v1.Elem(), v2.Elem())</span>

        // 比较数组
        case reflect.Array:<span class="cov8" title="1">
                // 递归比较每一个元素
                // 注意：不能对数组类型的 reflect.Value 使用 UnsafePointer
                for i := 0; i &lt; v1.Len(); i++ </span><span class="cov8" title="1">{
                        if !deepValueEqual(v1.Index(i), v2.Index(i)) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>

        // 比较结构体
        case reflect.Struct:<span class="cov8" title="1">
                // 递归比较每一个字段
                for i := 0; i &lt; v1.NumField(); i++ </span><span class="cov8" title="1">{
                        if !deepValueEqual(v1.Field(i), v2.Field(i)) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>

        // 比较接口
        case reflect.Interface:<span class="cov8" title="1">
                // 检查是否为 nil
                if v1.IsNil() || v2.IsNil() </span><span class="cov0" title="0">{
                        return v1.IsNil() == v2.IsNil()
                }</span>
                // 递归比较接口包含的元素
                <span class="cov8" title="1">return deepValueEqual(v1.Elem(), v2.Elem())</span>

        // 对于其他基本类型，直接比较接口值
        default:<span class="cov8" title="1">
                // 对于不可比较的类型（如函数、映射、切片），需要捕获panic
                var result bool
                var panicked bool

                func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if recover() != nil </span><span class="cov8" title="1">{
                                        panicked = true
                                }</span>
                        }()

                        // 尝试直接比较，如果类型不可比较会触发panic被上面捕获
                        <span class="cov8" title="1">result = v1.Interface() == v2.Interface()</span>
                }()

                // 如果发生了panic，说明类型不可比较，返回false
                <span class="cov8" title="1">if panicked </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">return result</span>
        }
}

// DeepEqual 使用深度递归比较的方式，判断两个任意类型的值 x 和 y 是否完全相等。
//
// 与标准的 `==` 运算符不同，`DeepEqual` 能够深入探索数据结构的内部，
// 对 Maps、Slices、Pointers、Structs 等复合类型的元素或字段进行逐一递归比较。
//
// 对于基本类型，它会直接比较其值。对于指针，它会比较所指向的实际内容。
// 两个 nil 值被视作相等。
//
// 示例：
//   - `DeepEqual(map[string]int{"a": 1}, map[string]int{"a": 1})` 返回 `true`
//   - `DeepEqual([]int{1, 2}, []int{1, 2})` 返回 `true`
//   - `DeepEqual(1, 1)` 返回 `true`
//   - `DeepEqual(1, 2)` 返回 `false`
//
// @param x 第一个待比较的值。
// @param y 第二个待比较的值。
// @return 如果两个值在结构和内容上完全相等，则返回 true，否则返回 false。
func DeepEqual[M any](x, y M) bool <span class="cov8" title="1">{
        v1 := reflect.ValueOf(x)
        v2 := reflect.ValueOf(y)
        return deepValueEqual(v1, v2)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Package candy 提供常用的工具函数和语法糖
// 本文件包含数组/切片差异比较相关的函数

// Diff 计算两个有序切片之间的差异
//
// 参数:
//   - ss: 第一个切片
//   - against: 第二个切片
//
// 返回值:
//   - added: 在 against 中存在但不在 ss 中的元素
//   - removed: 在 ss 中存在但不在 against 中的元素
//
// 示例:
//
//        ss := []int{1, 2, 3}
//        against := []int{2, 3, 4}
//        added, removed := Diff(ss, against)
//        // added = [4]
//        // removed = [1]
func Diff[T constraints.Ordered](ss []T, against []T) (added, removed []T) <span class="cov8" title="1">{
        removed = Remove(ss, against)
        added = Remove(against, ss)

        return
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package candy

import (
        "reflect"
)

// DiffSlice 比较两个切片的差异
// 返回第一个切片中存在但第二个切片中不存在的元素，以及第二个切片中存在但第一个切片中不存在的元素
func DiffSlice(a interface{}, b interface{}) (interface{}, interface{}) <span class="cov8" title="1">{
        at := reflect.TypeOf(a)
        if at.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                panic("a is not slice")</span>
        }

        <span class="cov8" title="1">bt := reflect.TypeOf(b)
        if bt.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                panic("b is not slice")</span>
        }

        <span class="cov8" title="1">atm := at.Elem()
        btm := bt.Elem()

        if atm.Kind() != btm.Kind() </span><span class="cov8" title="1">{
                panic("a and b are not same type")</span>
        }

        <span class="cov8" title="1">m := map[interface{}]reflect.Value{}

        bv := reflect.ValueOf(b)
        for i := 0; i &lt; bv.Len(); i++ </span><span class="cov8" title="1">{
                m[bv.Index(i).Interface()] = bv.Index(i)
        }</span>

        <span class="cov8" title="1">c := reflect.MakeSlice(at, 0, 0)
        d := reflect.MakeSlice(bt, 0, 0)
        av := reflect.ValueOf(a)
        for i := 0; i &lt; av.Len(); i++ </span><span class="cov8" title="1">{
                if !m[av.Index(i).Interface()].IsValid() </span><span class="cov8" title="1">{
                        c = reflect.Append(c, av.Index(i))
                }</span> else<span class="cov8" title="1"> {
                        delete(m, av.Index(i).Interface())
                }</span>
        }

        <span class="cov8" title="1">for _, value := range m </span><span class="cov8" title="1">{
                d = reflect.Append(d, value)
        }</span>

        <span class="cov8" title="1">return c.Interface(), d.Interface()</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

// Drop 丢弃切片前 n 个元素
//
// 参数:
//   - ss: 输入切片，支持任意类型
//   - n: 要丢弃的元素个数
//
// 返回值:
//   - []T: 丢弃前 n 个元素后的新切片
//
// 特点:
//   - 支持任意类型的切片
//   - 如果 n 为负数，当作 0 处理
//   - 如果 n 大于切片长度，返回空切片
//   - 不修改原切片，返回新切片
//
// 示例:
//
//        result := Drop([]int{1, 2, 3, 4, 5}, 2)      // 返回 [3, 4, 5]
//        result := Drop([]string{"a", "b", "c"}, 0)  // 返回 ["a", "b", "c"]
//        result := Drop([]int{1, 2, 3}, 5)      // 返回 []
//        result := Drop([]int{1, 2, 3}, -1)     // 返回 [1, 2, 3]
func Drop[T any](ss []T, n int) []T <span class="cov8" title="1">{
        if n &lt; 0 </span><span class="cov8" title="1">{
                n = 0
        }</span>

        <span class="cov8" title="1">if n &gt; len(ss) </span><span class="cov8" title="1">{
                n = len(ss)
        }</span>

        <span class="cov8" title="1">return ss[n:]</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package candy

import (
        "reflect"
)

// Each 遍历切片、数组或映射的每个元素，并对每个元素执行指定的函数
//
// 参数:
//   - collection: 要遍历的集合，支持切片、数组、映射
//   - fn: 对每个元素执行的函数，接收元素的索引和值
//
// 示例:
//
//        // 遍历切片
//        Each([]int{1, 2, 3}, func(index int, value int) {
//            fmt.Printf("索引 %d: 值 %d\n", index, value)
//        })
//
//        // 遍历映射
//        Each(map[string]int{"a": 1, "b": 2}, func(index int, value int) {
//            fmt.Printf("索引 %d: 值 %d\n", index, value)
//        })
//
// 注意:
//   - 如果 collection 不是切片、数组或映射，函数会 panic
//   - 对于映射，index 参数是连续的整数，从 0 开始
//   - 函数使用反射机制，性能上不如直接的 for 循环
func Each(collection interface{}, fn func(index int, value interface{})) <span class="cov8" title="1">{
        val := reflect.ValueOf(collection)

        switch val.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                for i := 0; i &lt; val.Len(); i++ </span><span class="cov8" title="1">{
                        fn(i, val.Index(i).Interface())
                }</span>
        case reflect.Map:<span class="cov8" title="1">
                keys := val.MapKeys()
                for i, key := range keys </span><span class="cov8" title="1">{
                        fn(i, val.MapIndex(key).Interface())
                }</span>
        default:<span class="cov8" title="1">
                panic("Each: collection must be a slice, array, or map")</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package candy

// EachReverse 反向遍历切片并对每个元素执行指定函数
// 从切片的最后一个元素开始，向前遍历到第一个元素
// 对于每个元素，都会调用传入的函数 f 进行处理
//
// 参数:
//   - ss: 要遍历的切片
//   - f: 对每个元素执行的函数，接收一个类型为 T 的参数
//
// 泛型参数:
//   - T: 切片中元素的类型，可以是任意类型
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        EachReverse(numbers, func(n int) {
//            fmt.Println(n) // 输出: 5, 4, 3, 2, 1
//        })
func EachReverse[T any](ss []T, f func(T)) <span class="cov8" title="1">{
        for i := len(ss) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                f(ss[i])
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package candy 提供了实用的工具函数和语法糖
package candy

// EachStopWithError 遍历切片并对每个元素执行指定函数，如果函数返回错误则立即停止遍历并返回该错误
//
// 参数：
//   - ss: 要遍历的切片
//   - f: 对每个元素执行的函数，如果返回错误则停止遍历
//
// 返回值：
//   - error: 如果遍历过程中出现错误则返回该错误，否则返回 nil
//
// 示例：
//
//        numbers := []int{1, 2, 3, 4, 5}
//        err := EachStopWithError(numbers, func(n int) error {
//            if n == 3 {
//                return fmt.Errorf("数字 3 不被允许")
//            }
//            fmt.Println(n)
//            return nil
//        })
func EachStopWithError[T any](ss []T, f func(T) (err error)) (err error) <span class="cov8" title="1">{
        for _, s := range ss </span><span class="cov8" title="1">{
                err = f(s)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package candy 提供了 Go 语言中常用的语法糖函数和工具方法
package candy

// Filter 函数用于过滤切片中的元素，返回满足条件的所有元素
//
// 参数：
//   - ss: 要过滤的切片，可以是任意类型的切片
//   - f: 过滤函数，接收一个元素并返回布尔值，true 表示保留该元素
//
// 返回值：
//   - []T: 包含所有满足条件的元素的新切片
//
// 示例：
//
//        numbers := []int{1, 2, 3, 4, 5}
//        evenNumbers := Filter(numbers, func(n int) bool {
//            return n%2 == 0
//        })
//        // evenNumbers = [2, 4]
//
// 注意事项：
//   - 使用 make 初始化返回切片，确保返回空切片而非 nil
//   - 该函数不会修改原始切片
//   - 时间复杂度为 O(n)，其中 n 为切片长度
func Filter[T any](ss []T, f func(T) bool) []T <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return []T{}
        }</span>

        // 使用原始长度的1/4作为初始容量预估，减少重新分配
        <span class="cov8" title="1">ret := make([]T, 0, len(ss)/4+1)
        for _, s := range ss </span><span class="cov8" title="1">{
                if f(s) </span><span class="cov8" title="1">{
                        ret = append(ret, s)
                }</span>
        }

        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

// FilterNot 对切片进行反向过滤，保留不满足指定条件的元素
//
// 参数:
//   - ss: 输入切片，支持任意类型
//   - f: 谓词函数，接收一个元素并返回布尔值
//
// 返回值:
//   - []T: 包含所有不满足谓词函数条件的新切片
//
// 特点:
//   - 支持任意类型的切片
//   - 是 Filter 函数的补集，用于语义上更清晰的反向过滤操作
//   - 不修改原切片，返回新切片
//   - 空切片输入返回空切片
//
// 示例:
//
//        // 过滤偶数，保留奇数
//        numbers := []int{1, 2, 3, 4, 5, 6}
//        result := FilterNot(numbers, func(n int) bool {
//            return n % 2 == 0
//        })
//        // result = [1, 3, 5]
//
//        // 过滤空字符串，保留非空字符串
//        strings := []string{"hello", "", "world", ""}
//        result := FilterNot(strings, func(s string) bool {
//            return s == ""
//        })
//        // result = ["hello", "world"]
//
//        // 过滤负数，保留非负数
//        nums := []int{-1, 0, 1, -2, 2}
//        result := FilterNot(nums, func(n int) bool {
//            return n &lt; 0
//        })
//        // result = [0, 1, 2]
func FilterNot[T any](ss []T, f func(T) bool) []T <span class="cov8" title="1">{
        // 使用 make 初始化，确保返回空切片而非 nil
        us := make([]T, 0)
        for _, s := range ss </span><span class="cov8" title="1">{
                if !f(s) </span><span class="cov8" title="1">{
                        us = append(us, s)
                }</span>
        }
        <span class="cov8" title="1">return us</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package candy 包含常用的语法糖函数，提供简洁的编程接口
package candy

// First 返回切片中的第一个元素
// 如果切片为空，返回类型的零值
//
// 泛型参数 T 可以是任意类型
//
// 示例：
//
//        nums := []int{1, 2, 3}
//        first := First(nums) // 返回 1
//
//        empty := []string{}
//        first := First(empty) // 返回 "" (string 的零值)
func First[T any](ss []T) (ret T) <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">return ss[0]</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package candy 包含语法糖工具函数，提供便捷的编程辅助功能
package candy

// FirstOr 返回切片的第一个元素，如果切片为空则返回指定的默认值
//
// 该函数使用泛型支持任意类型的切片，提供了安全的空切片处理机制。
// 在访问切片第一个元素之前，会先检查切片长度，避免 panic。
//
// 参数:
//   - ss: 任意类型的切片
//   - or: 当切片为空时返回的默认值
//
// 返回:
//   - 切片的第一个元素，如果切片为空则返回默认值
//
// 示例:
//
//        numbers := []int{1, 2, 3}
//        first := FirstOr(numbers, 0)     // 返回 1
//
//        empty := []int{}
//        defaultVal := FirstOr(empty, 0) // 返回 0
func FirstOr[T any](ss []T, or T) (ret T) <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return or
        }</span>

        <span class="cov8" title="1">return ss[0]</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Index 返回元素 sub 在切片 ss 中的索引位置
// 如果未找到，返回 -1
// 这是一个泛型函数，支持所有可排序的类型
func Index[T constraints.Ordered](ss []T, sub T) int <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return -1
        }</span>

        <span class="cov8" title="1">for i, s := range ss </span><span class="cov8" title="1">{
                if s == sub </span><span class="cov8" title="1">{
                        return i
                }</span>
        }

        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package candy

import (
        "strings"

        "golang.org/x/exp/constraints"
)

// Join 将有序类型的切片按指定分隔符连接成字符串
// 该函数提供了通用的切片连接功能，支持所有实现了 constraints.Ordered 接口的类型
// 包括整数、浮点数和字符串等基本类型
//
// 参数:
//   - ss: 输入切片，类型为 []T，其中 T 必须实现 constraints.Ordered 接口
//   - glue: 可选参数，指定连接分隔符，默认为 ","
//
// 返回:
//   - string: 连接后的字符串
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        result := Join(numbers, "-")
//        // result 为 "1-2-3-4-5"
//
//        words := []string{"Hello", "World", "Go"}
//        result := Join(words, " ")
//        // result 为 "Hello World Go"
func Join[T constraints.Ordered](ss []T, glue ...string) string <span class="cov8" title="1">{
        // 设置默认分隔符
        seq := ","
        if len(glue) &gt; 0 </span><span class="cov8" title="1">{
                seq = glue[0]
        }</span>

        // 使用 Map 函数将切片元素转换为字符串，然后用 strings.Join 连接
        <span class="cov8" title="1">return strings.Join(Map(ss, func(s T) string </span><span class="cov8" title="1">{
                return String(s)
        }</span>), seq)
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package candy 包含实用的语法糖函数，提供简洁高效的编程工具
package candy

// Last 返回切片中的最后一个元素
// 如果切片为空，返回类型的零值
// 该函数使用泛型实现，支持任意类型的切片
//
// 参数:
//   - ss: 任意类型的切片
//
// 返回:
//   - T: 切片中的最后一个元素，如果切片为空则返回类型零值
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        last := Last(numbers) // 返回 5
//
//        empty := []string{}
//        result := Last(empty) // 返回 ""
func Last[T any](ss []T) (ret T) <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">return ss[len(ss)-1]</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package candy 包含实用的语法糖函数，提供简洁高效的编程工具
package candy

// LastOr 返回切片中的最后一个元素
// 如果切片为空，返回指定的默认值
// 该函数使用泛型实现，支持任意类型的切片
//
// 参数:
//   - ss: 任意类型的切片
//   - or: 当切片为空时返回的默认值
//
// 返回:
//   - T: 切片中的最后一个元素，如果切片为空则返回指定的默认值
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        last := LastOr(numbers, 0) // 返回 5
//
//        empty := []string{}
//        result := LastOr(empty, "default") // 返回 "default"
func LastOr[T any](ss []T, or T) (ret T) <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return or
        }</span>

        <span class="cov8" title="1">return ss[len(ss)-1]</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package candy

// Map 对切片中的每个元素应用指定的函数，返回新的切片
// 该函数使用泛型支持任意类型的输入和输出
//
// 参数:
//   - ss: 输入切片，类型为 []T
//   - f: 映射函数，接收类型 T 的参数，返回类型 U 的结果
//
// 返回:
//   - []U: 应用映射函数后的新切片
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        doubled := Map(numbers, func(n int) int {
//            return n * 2
//        })
//        // doubled 为 []int{2, 4, 6, 8, 10}
func Map[T, U any](ss []T, f func(T) U) []U <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return []U{}
        }</span>

        // 直接分配最终长度的切片，避免 append 操作
        <span class="cov8" title="1">ret := make([]U, len(ss))
        for i, s := range ss </span><span class="cov8" title="1">{
                ret[i] = f(s)
        }</span>

        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package candy

import "golang.org/x/exp/constraints"

// Max 返回切片中的最大值
//
// 参数:
//   - ss: 输入切片，支持所有可排序类型
//
// 返回值:
//   - T: 切片中的最大值，如果切片为空则返回类型零值
//
// 特点:
//   - 支持整数、浮点数、字符串等所有可排序类型
//   - 空切片输入返回类型零值
//   - 时间复杂度 O(n)，单次遍历
//   - 不修改原切片
//
// 示例:
//
//        // 查找整数切片的最大值
//        numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}
//        result := Max(numbers)
//        // result = 9
//
//        // 查找字符串切片的最大值（按字典序）
//        strings := []string{"apple", "banana", "cherry", "date"}
//        result := Max(strings)
//        // result = "date"
//
//        // 查找浮点数切片的最大值
//        floats := []float64{3.14, 1.618, 2.718, 1.414}
//        result := Max(floats)
//        // result = 3.14
//
//        // 空切片处理
//        empty := []int{}
//        result := Max(empty)
//        // result = 0 (int类型的零值)
func Max[T constraints.Ordered](ss []T) (max T) <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">max = ss[0]
        for _, s := range ss </span><span class="cov8" title="1">{
                if s &gt; max </span><span class="cov8" title="1">{
                        max = s
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import "golang.org/x/exp/constraints"

// Min 返回切片中的最小值
//
// 参数:
//   - ss: 输入切片，支持所有可排序类型
//
// 返回值:
//   - T: 切片中的最小值，如果切片为空则返回类型零值
//
// 特点:
//   - 支持整数、浮点数、字符串等所有可排序类型
//   - 空切片输入返回类型零值
//   - 时间复杂度 O(n)，单次遍历
//   - 不修改原切片
//
// 示例:
//
//        // 查找整数切片的最小值
//        numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}
//        result := Min(numbers)
//        // result = 1
//
//        // 查找字符串切片的最小值（按字典序）
//        strings := []string{"apple", "banana", "cherry", "date"}
//        result := Min(strings)
//        // result = "apple"
//
//        // 查找浮点数切片的最小值
//        floats := []float64{3.14, 1.618, 2.718, 1.414}
//        result := Min(floats)
//        // result = 1.414
//
//        // 空切片处理
//        empty := []int{}
//        result := Min(empty)
//        // result = 0 (int类型的零值)
func Min[T constraints.Ordered](ss []T) (min T) <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">min = ss[0]
        for _, s := range ss </span><span class="cov8" title="1">{
                if s &lt; min </span><span class="cov8" title="1">{
                        min = s
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package candy

import (
        "fmt"
        "reflect"
)

func pluck(list interface{}, fieldName string, deferVal interface{}) interface{} <span class="cov8" title="1">{
        v := reflect.ValueOf(list)
        switch v.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                if v.Len() == 0 </span><span class="cov8" title="1">{
                        return deferVal
                }</span>

                <span class="cov8" title="1">ev := v.Type().Elem()
                evs := ev
                for evs.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        evs = evs.Elem()
                }</span>

                <span class="cov8" title="1">switch evs.Kind() </span>{
                case reflect.Struct:<span class="cov8" title="1">
                        field, ok := evs.FieldByName(fieldName)
                        if !ok </span><span class="cov8" title="1">{
                                panic(fmt.Sprintf("field %s not found", fieldName))</span>
                        }

                        <span class="cov8" title="1">result := reflect.MakeSlice(reflect.SliceOf(field.Type), v.Len(), v.Len())

                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                                ev := v.Index(i)
                                for ev.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                        ev = ev.Elem()
                                }</span>
                                <span class="cov8" title="1">if ev.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                                        panic("element is not a struct")</span>
                                }
                                <span class="cov8" title="1">if !ev.IsValid() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">result.Index(i).Set(ev.FieldByIndex(field.Index))</span>
                        }

                        <span class="cov8" title="1">return result.Interface()</span>
                case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                        var ev reflect.Value
                        var c int
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                                ev = v.Index(i)
                                for i := 0; i &lt; ev.Len(); i++ </span><span class="cov8" title="1">{
                                        c += ev.Index(i).Len()
                                }</span>
                        }

                        <span class="cov8" title="1">result := reflect.MakeSlice(ev.Type(), c, c)
                        var idx int
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                                ev := v.Index(i)
                                for i := 0; i &lt; ev.Len(); i++ </span><span class="cov8" title="1">{
                                        result.Index(idx).Set(ev.Index(i))
                                        idx++
                                }</span>
                        }

                        <span class="cov8" title="1">return result.Interface()</span>
                default:<span class="cov8" title="1">
                        panic("list element type is not supported")</span>
                }

        default:<span class="cov8" title="1">
                panic("list must be an array or slice")</span>
        }
}

// PluckInt 从结构体切片中提取指定字段的 int 值
func PluckInt(list interface{}, fieldName string) []int <span class="cov8" title="1">{
        return pluck(list, fieldName, []int{}).([]int)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package candy

// PluckInt32 从结构体切片中提取指定字段的 int32 值
func PluckInt32(list interface{}, fieldName string) []int32 <span class="cov8" title="1">{
        return pluck(list, fieldName, []int32{}).([]int32)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package candy

// PluckInt64 从结构体切片中提取指定字段的 int64 值
func PluckInt64(list interface{}, fieldName string) []int64 <span class="cov8" title="1">{
        return pluck(list, fieldName, []int64{}).([]int64)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package candy

// PluckString 从结构体切片中提取指定字段的 string 值
func PluckString(list interface{}, fieldName string) []string <span class="cov8" title="1">{
        return pluck(list, fieldName, []string{}).([]string)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package candy

// PluckStringSlice 从结构体切片中提取指定字段的 []string 值
func PluckStringSlice(list interface{}, fieldName string) [][]string <span class="cov8" title="1">{
        return pluck(list, fieldName, [][]string{}).([][]string)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package candy

// PluckUint32 从结构体切片中提取指定字段的 uint32 值
func PluckUint32(list interface{}, fileName string) []uint32 <span class="cov8" title="1">{
        return pluck(list, fileName, []uint32{}).([]uint32)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package candy

// PluckUint64 从结构体切片中提取指定字段的 uint64 值
func PluckUint64(list interface{}, fieldName string) []uint64 <span class="cov8" title="1">{
        return pluck(list, fieldName, []uint64{}).([]uint64)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package candy

import (
        "math"

        "golang.org/x/exp/constraints"
)

// Pow 返回 x 的 y 次幂
//
// 参数:
//   - x: 底数，支持整数和浮点数类型
//   - y: 指数，支持整数和浮点数类型
//
// 返回值:
//   - T: x 的 y 次幂结果，保持原类型
//
// 特点:
//   - 支持整数和浮点数类型的幂运算
//   - 底层使用 math.Pow 进行高精度计算
//   - 自动处理类型转换，保持类型一致性
//   - 支持负指数和分数指数
//
// 示例:
//
//        // 整数幂运算
//        result := Pow(2, 3)
//        // result = 8
//
//        // 浮点数幂运算
//        result := Pow(2.5, 2.0)
//        // result = 6.25
//
//        // 负指数运算
//        result := Pow(2.0, -2.0)
//        // result = 0.25
//
//        // 分数指数运算
//        result := Pow(4.0, 0.5)
//        // result = 2.0 (平方根)
//
//        // 大数幂运算
//        result := Pow(10, 6)
//        // result = 1000000
func Pow[T constraints.Integer | constraints.Float](x, y T) T <span class="cov8" title="1">{
        return T(math.Pow(float64(x), float64(y)))
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package candy

import (
        "math/rand"
)

// Random 从切片中随机返回一个元素
func Random[T any](ss []T) (ret T) <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">return ss[rand.Intn(len(ss))]</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package candy

// Reduce 对切片进行归约操作，使用指定的二元函数将切片元素合并为单个值
func Reduce[T any](ss []T, f func(T, T) T) T <span class="cov8" title="1">{
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return *new(T)
        }</span>

        <span class="cov8" title="1">result := ss[0]
        for _, s := range ss[1:] </span><span class="cov8" title="1">{
                result = f(result, s)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Remove 移除 ss 存在也 against 存在的部分
// 返回在 against 中但不在 ss 中的元素
func Remove[T constraints.Ordered](ss []T, against []T) (result []T) <span class="cov8" title="1">{
        // 使用 make 初始化，确保返回空切片而非 nil
        result = make([]T, 0)
        set := make(map[T]struct{}, len(ss))

        for _, s := range ss </span><span class="cov8" title="1">{
                set[s] = struct{}{}
        }</span>

        <span class="cov8" title="1">for _, s := range against </span><span class="cov8" title="1">{
                if _, ok := set[s]; !ok </span><span class="cov8" title="1">{
                        result = append(result, s)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package candy

// RemoveIndex 移除指定索引的元素
// 该函数从切片中移除指定索引位置的元素，并返回新的切片
// 如果索引无效（超出范围或为负数），则返回空切片
func RemoveIndex[T any](ss []T, index int) []T <span class="cov8" title="1">{
        // 边界检查：如果切片为空或索引无效，返回空切片
        if len(ss) == 0 || index &lt; 0 || index &gt;= len(ss) </span><span class="cov8" title="1">{
                return make([]T, 0)
        }</span>

        // 处理移除第一个元素的特殊情况
        <span class="cov8" title="1">if index == 0 </span><span class="cov8" title="1">{
                return ss[1:]
        }</span>

        // 处理移除最后一个元素的特殊情况
        <span class="cov8" title="1">if index == len(ss)-1 </span><span class="cov8" title="1">{
                return ss[:len(ss)-1]
        }</span>

        // 一般情况：使用 append 将索引前后的元素拼接起来
        <span class="cov8" title="1">return append(ss[:index], ss[index+1:]...)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package candy

import (
        "reflect"
)

// RemoveSlice 从源切片中移除指定的元素
// src 是源切片，rm 是要移除的元素切片
// 返回移除指定元素后的新切片
func RemoveSlice(src interface{}, rm interface{}) interface{} <span class="cov8" title="1">{
        at := reflect.TypeOf(src)
        if at.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                panic("a is not slice")</span>
        }

        <span class="cov8" title="1">bt := reflect.TypeOf(rm)
        if bt.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                panic("b is not slice")</span>
        }

        <span class="cov8" title="1">atm := at.Elem()
        btm := bt.Elem()

        if atm.Kind() != btm.Kind() </span><span class="cov8" title="1">{
                panic("a and b are not same type")</span>
        }

        <span class="cov8" title="1">m := map[interface{}]bool{}

        bv := reflect.ValueOf(rm)
        for i := 0; i &lt; bv.Len(); i++ </span><span class="cov8" title="1">{
                m[bv.Index(i).Interface()] = true
        }</span>

        <span class="cov8" title="1">c := reflect.MakeSlice(at, 0, 0)
        av := reflect.ValueOf(src)
        for i := 0; i &lt; av.Len(); i++ </span><span class="cov8" title="1">{
                if !m[av.Index(i).Interface()] </span><span class="cov8" title="1">{
                        c = reflect.Append(c, av.Index(i))
                        delete(m, av.Index(i).Interface())
                }</span>
        }

        <span class="cov8" title="1">return c.Interface()</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package reverse 提供了反转切片的工具函数
package candy

// Reverse 返回一个反转后的切片，原切片保持不变
// 该函数使用泛型支持任意类型的切片，返回一个新的反转后的切片
// 使用 make 预分配容量以确保性能最优
func Reverse[T any](ss []T) (ret []T) <span class="cov8" title="1">{
        // 使用 make 初始化，确保返回空切片而非 nil
        ret = make([]T, 0, len(ss))
        for i := len(ss) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                ret = append(ret, ss[i])
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Same 返回在 against 和 ss 中都存在的元素
// 用于查找两个有序集合的交集
func Same[T constraints.Ordered](against []T, ss []T) (result []T) <span class="cov8" title="1">{
        // 使用 make 初始化，确保返回空切片而非 nil
        result = make([]T, 0)
        set := make(map[T]struct{}, len(ss))

        for _, s := range ss </span><span class="cov8" title="1">{
                set[s] = struct{}{}
        }</span>

        <span class="cov8" title="1">for _, s := range against </span><span class="cov8" title="1">{
                if _, ok := set[s]; ok </span><span class="cov8" title="1">{
                        result = append(result, s)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import "github.com/lazygophers/utils/randx"

// Shuffle 随机打乱切片中的元素顺序
//
// 类型参数：
//   - T: 任意类型
//
// 参数：
//   - ss: 待打乱的切片，可以是任意类型
//
// 返回值：
//   - []T: 打乱后的切片（原地修改，返回原切片的引用）
//
// 特点：
//   - 使用 Fisher-Yates 洗牌算法，确保均匀随机分布
//   - 原地修改，不创建新切片，内存效率高
//   - 支持任意类型的切片
//   - 对于空切片或单元素切片，直接返回原切片
//   - 高性能优化：使用 randx 包的高性能随机数生成器
//
// 示例：
//
//        // 打乱整数切片
//        data := []int{1, 2, 3, 4, 5}
//        result := Shuffle(data)
//        // result 是打乱后的切片，与 data 是同一个切片
//
//        // 打乱字符串切片
//        names := []string{"Alice", "Bob", "Charlie", "David"}
//        shuffled := Shuffle(names)
//        // shuffled 包含随机顺序的名字
func Shuffle[T any](ss []T) []T <span class="cov8" title="1">{
        if len(ss) &lt;= 1 </span><span class="cov8" title="1">{
                return ss
        }</span>

        <span class="cov8" title="1">for i := len(ss) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                j := randx.FastIntn(i + 1)
                ss[i], ss[j] = ss[j], ss[i]
        }</span>

        <span class="cov8" title="1">return ss</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package candy

// SliceEqual 判断两个切片是否相等，不考虑元素顺序
// 使用 map 来统计元素出现次数，确保每个元素在两个切片中出现次数相同
// 处理了 nil 切片的特殊情况：nil 和空切片视为相等
func SliceEqual[T any](a, b []T) bool <span class="cov8" title="1">{
        // 处理 nil 切片的情况：nil 和空切片视为相等
        if a == nil &amp;&amp; b == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if a == nil || b == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>

        // 使用 map 来跟踪每个元素的出现次数
        <span class="cov8" title="1">am := make(map[any]int, len(a))
        for _, v := range a </span><span class="cov8" title="1">{
                am[v]++
        }</span>

        <span class="cov8" title="1">for _, v := range b </span><span class="cov8" title="1">{
                if count, ok := am[v]; !ok || count == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">am[v]--</span>
        }

        // 检查所有元素的计数是否都为0
        <span class="cov8" title="1">for _, count := range am </span><span class="cov8" title="1">{
                if count != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package candy

import (
        "sort"

        "golang.org/x/exp/constraints"
)

// Sort 对有序类型的切片进行排序
// 接受一个实现了 constraints.Ordered 接口的切片，返回一个新的已排序切片
// 原始切片不会被修改，返回的是排序后的副本
func Sort[T constraints.Ordered](ss []T) []T <span class="cov8" title="1">{
        // 如果切片长度小于2，直接返回副本
        if len(ss) &lt; 2 </span><span class="cov8" title="1">{
                return ss
        }</span>

        // 创建新的切片用于排序
        <span class="cov8" title="1">sorted := make([]T, len(ss))
        copy(sorted, ss)

        // 使用 sort.Slice 进行排序
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                return sorted[i] &lt; sorted[j]
        }</span>)

        <span class="cov8" title="1">return sorted</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package candy

import (
        "sort"
)

// SortUsing 使用自定义比较函数对切片进行排序
func SortUsing[T any](slice []T, less func(T, T) bool) []T <span class="cov8" title="1">{
        if len(slice) &lt; 2 </span><span class="cov8" title="1">{
                return slice
        }</span>

        <span class="cov8" title="1">sorted := make([]T, len(slice))
        copy(sorted, slice)

        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                return less(sorted[i], sorted[j])
        }</span>)

        <span class="cov8" title="1">return sorted</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package candy

import "golang.org/x/exp/constraints"

// Spare 返回在 against 中但不在 ss 中的元素
// 该函数实现了集合差集操作，返回在 against 切片中存在但在 ss 切片中不存在的所有元素
// 注意：该函数与 Remove 函数功能相同，都是返回差集结果
//
// 参数：
//   - ss: 作为参考集合的切片
//   - against: 作为被比较集合的切片
//
// 返回：
//   - []T: 在 against 中但不在 ss 中的元素组成的切片
//
// 示例：
//
//        ss := []int{1, 2, 3}
//        against := []int{2, 3, 4, 5}
//        result := Spare(ss, against) // 返回 [4, 5]
func Spare[T constraints.Ordered](ss []T, against []T) (result []T) <span class="cov8" title="1">{
        // 使用 make 初始化，确保返回空切片而非 nil
        result = make([]T, 0)
        set := make(map[T]struct{}, len(ss))

        // 将 ss 中的所有元素添加到 map 中用于快速查找
        for _, s := range ss </span><span class="cov8" title="1">{
                set[s] = struct{}{}
        }</span>

        // 遍历 against 切片，找出不在 ss 中的元素
        <span class="cov8" title="1">for _, s := range against </span><span class="cov8" title="1">{
                if _, ok := set[s]; !ok </span><span class="cov8" title="1">{
                        result = append(result, s)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package candy

import (
        "math"

        "golang.org/x/exp/constraints"
)

// Sqrt 计算数值的平方根
func Sqrt[T constraints.Integer | constraints.Float](s T) T <span class="cov8" title="1">{
        return T(math.Sqrt(float64(s)))
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package candy

import (
        "fmt"

        "golang.org/x/exp/constraints"
)

// String 将任意有序类型转换为字符串
// 该函数提供了通用的类型转字符串功能，支持所有实现了 constraints.Ordered 接口的类型
// 包括整数、浮点数和字符串等基本类型
func String[T constraints.Ordered](s T) string <span class="cov8" title="1">{
        return fmt.Sprintf("%v", s)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package candy 包含语法糖工具函数
package candy

import "golang.org/x/exp/constraints"

// Sum 计算数值切片中所有元素的总和
// 支持整数和浮点数类型，使用泛型实现类型安全
//
// 参数：
//   - ss: 数值切片，支持整数和浮点数类型
//
// 返回值：
//   - T: 切片中所有元素的总和
//
// 示例：
//
//        sum := Sum([]int{1, 2, 3})  // 返回 6
//        sum := Sum([]float64{1.5, 2.5})  // 返回 4.0
func Sum[T constraints.Integer | constraints.Float](ss []T) (ret T) <span class="cov8" title="1">{
        for _, s := range ss </span><span class="cov8" title="1">{
                ret += s
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package candy

import (
        "reflect"
        "strings"
)

// ToArrayString 将任意类型转换为字符串数组
// 对于切片类型，将每个元素转换为字符串
// 对于字符串类型，如果包含逗号则按逗号分割，否则返回单个元素的切片
// 对于其他类型，转换为字符串后返回单个元素的切片
func ToArrayString(v interface{}) []string <span class="cov8" title="1">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                // 处理非切片类型
                switch x := v.(type) </span>{
                case string:<span class="cov8" title="1">
                        if strings.Contains(x, ",") </span><span class="cov8" title="1">{
                                // 如果包含逗号，按逗号分割
                                return strings.Split(x, ",")
                        }</span>
                        // 否则返回单个元素的切片
                        <span class="cov8" title="1">return []string{x}</span>
                case nil:<span class="cov8" title="1">
                        return nil</span>
                default:<span class="cov8" title="1">
                        // 其他非切片类型，转换为字符串后返回单个元素的切片
                        return []string{ToString(x)}</span>
                }
        }

        // 处理 nil 切片
        <span class="cov8" title="1">if vv.IsNil() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">ss := make([]string, 0, vv.Len())
        for i := 0; i &lt; vv.Len(); i++ </span><span class="cov8" title="1">{
                ss = append(ss, ToString(vv.Index(i).Interface()))
        }</span>

        <span class="cov8" title="1">return ss</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package candy

import (
        "bytes"
        "math"
        "strings"
)

// ToBool 尝试将任意类型 (interface{}) 的输入值转换为布尔值 (bool)。
//
// 转换规则如下:
//
//   - **bool**:
//     直接返回原始值。
//
//   - **整型** (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64):
//     如果值为 0，则返回 false，否则返回 true。
//
//   - **浮点型** (float32, float64):
//     如果值为 0.0 或 NaN (Not-a-Number)，则返回 false，否则返回 true。
//
//   - **字符串 (string) 和字节切片 ([]byte)**:
//     首先会转换为小写并移除首尾空白字符。
//
//   - "true", "1", "t", "y", "yes", "on" 被视为 true。
//
//   - "false", "0", "f", "n", "no", "off" 被视为 false。
//
//   - 对于其他非空字符串，返回 true。
//
//   - 对于空字符串或仅包含空白字符的字符串，返回 false。
//
//   - **nil**:
//     返回 false。
//
//   - **其他所有类型**:
//     均返回 false (例如: struct, map, slice 等)。
//
// 示例:
//
//        candy.ToBool(true)    // true
//        candy.ToBool(0)       // false
//        candy.ToBool("yes")   // true
//        candy.ToBool("off")   // false
//        candy.ToBool("hello") // true
//        candy.ToBool(nil)     // false
func ToBool(val interface{}) bool <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                return x</span>
        case int:<span class="cov8" title="1">
                return x != 0</span>
        case int8:<span class="cov8" title="1">
                return x != 0</span>
        case int16:<span class="cov8" title="1">
                return x != 0</span>
        case int32:<span class="cov8" title="1">
                return x != 0</span>
        case int64:<span class="cov8" title="1">
                return x != 0</span>
        case uint:<span class="cov8" title="1">
                return x != 0</span>
        case uint8:<span class="cov8" title="1">
                return x != 0</span>
        case uint16:<span class="cov8" title="1">
                return x != 0</span>
        case uint32:<span class="cov8" title="1">
                return x != 0</span>
        case uint64:<span class="cov8" title="1">
                return x != 0</span>
        case float32:<span class="cov8" title="1">
                return !math.IsNaN(float64(x)) &amp;&amp; x != 0.0</span>
        case float64:<span class="cov8" title="1">
                return !math.IsNaN(x) &amp;&amp; x != 0.0</span>
        case string:<span class="cov8" title="1">
                switch strings.ToLower(x) </span>{
                case "true", "1", "t", "y", "yes", "on":<span class="cov8" title="1">
                        return true</span>
                case "false", "0", "f", "n", "no", "off":<span class="cov8" title="1">
                        return false</span>
                default:<span class="cov8" title="1">
                        return strings.TrimSpace(x) != ""</span>
                }
        case []byte:<span class="cov8" title="1">
                switch string(bytes.ToLower(x)) </span>{
                case "true", "1", "t", "y", "yes", "on":<span class="cov8" title="1">
                        return true</span>
                case "false", "0", "f", "n", "no", "off":<span class="cov8" title="1">
                        return false</span>
                default:<span class="cov8" title="1">
                        return len(bytes.TrimSpace(x)) != 0</span>
                }
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package candy

import (
        "fmt"
        "math"
        "strconv"
        "time"
        "unsafe"

        "github.com/lazygophers/utils/json"
)

// ToBytes 将任意类型转换为字节切片
// 支持的类型包括：
// - 布尔值：true -&gt; []byte("1"), false -&gt; []byte("0")
// - 整数类型：int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64
// - 浮点数：float32, float64（自动处理精度）
// - 时间类型：time.Duration
// - 字符串：转换为字节切片
// - 字节切片：直接返回
// - nil：返回nil
// - error：返回错误信息的字节切片
// - 其他类型：使用 JSON 序列化
func ToBytes(val interface{}) []byte <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                if x </span><span class="cov8" title="1">{
                        return []byte("1")
                }</span>
                <span class="cov8" title="1">return []byte("0")</span>
        case int:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int8:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int16:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int32:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int64:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint8:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint16:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint32:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint64:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case float32:<span class="cov8" title="1">
                if math.Floor(float64(x)) == float64(x) </span><span class="cov8" title="1">{
                        return []byte(strconv.FormatFloat(float64(x), 'f', 0, 32))
                }</span>

                <span class="cov8" title="1">return []byte(strconv.FormatFloat(float64(x), 'f', 15, 32))</span>
        case float64:<span class="cov8" title="1">
                if math.Floor(x) == x </span><span class="cov8" title="1">{
                        return []byte(fmt.Sprintf("%.0f", x))
                }</span>

                <span class="cov8" title="1">return []byte(strconv.FormatFloat(x, 'f', 6, 64))</span>
        case time.Duration:<span class="cov8" title="1">
                return []byte(x.String())</span>
        case string:<span class="cov8" title="1">
                return []byte(x)</span>
        case []byte:<span class="cov8" title="1">
                return x</span>
        case nil:<span class="cov8" title="1">
                return nil</span>
        case error:<span class="cov8" title="1">
                return []byte(x.Error())</span>

        default:<span class="cov8" title="1">
                buf, err := json.Marshal(x)
                if err != nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">return buf</span>
        }
}

func toString(b []byte) string <span class="cov8" title="1">{
        return *(*string)(unsafe.Pointer(&amp;b))
}</span>

func toBytes(s string) []byte <span class="cov8" title="1">{
        return *(*[]byte)(unsafe.Pointer(&amp;s))
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package candy

import (
        "strconv"
        "strings"
)

// ToFloat32 将任何类型的值尽力转换为 float32。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1.0, false 转换为 0.0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为浮点数，若解析失败则返回 0.0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0.0。
func ToFloat32(val interface{}) float32 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                return float32(x)</span>
        case int8:<span class="cov8" title="1">
                return float32(x)</span>
        case int16:<span class="cov8" title="1">
                return float32(x)</span>
        case int32:<span class="cov8" title="1">
                return float32(x)</span>
        case int64:<span class="cov8" title="1">
                return float32(x)</span>
        case uint:<span class="cov8" title="1">
                return float32(x)</span>
        case uint8:<span class="cov8" title="1">
                return float32(x)</span>
        case uint16:<span class="cov8" title="1">
                return float32(x)</span>
        case uint32:<span class="cov8" title="1">
                return float32(x)</span>
        case uint64:<span class="cov8" title="1">
                return float32(x)</span>
        case float32:<span class="cov8" title="1">
                return x</span>
        case float64:<span class="cov8" title="1">
                return float32(x)</span>
        case string:<span class="cov8" title="1">
                v := strings.TrimSpace(x)
                val, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return float32(val)</span>
        case []byte:<span class="cov8" title="1">
                v := strings.TrimSpace(string(x))
                val, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return float32(val)</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package candy

import (
        "strconv"
        "strings"
)

// ToFloat64 将任何类型的值尽力转换为 float64。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1.0, false 转换为 0.0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为浮点数。若解析失败，会进一步尝试解析为整数。如果两种解析都失败，则返回 0.0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0.0。
func ToFloat64(val interface{}) float64 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                return float64(x)</span>
        case int8:<span class="cov8" title="1">
                return float64(x)</span>
        case int16:<span class="cov8" title="1">
                return float64(x)</span>
        case int32:<span class="cov8" title="1">
                return float64(x)</span>
        case int64:<span class="cov8" title="1">
                return float64(x)</span>
        case uint:<span class="cov8" title="1">
                return float64(x)</span>
        case uint8:<span class="cov8" title="1">
                return float64(x)</span>
        case uint16:<span class="cov8" title="1">
                return float64(x)</span>
        case uint32:<span class="cov8" title="1">
                return float64(x)</span>
        case uint64:<span class="cov8" title="1">
                return float64(x)</span>
        case float32:<span class="cov8" title="1">
                return float64(x)</span>
        case float64:<span class="cov8" title="1">
                return x</span>
        case string:<span class="cov8" title="1">
                v := strings.TrimSpace(x)
                val, err := strconv.ParseFloat(v, 64)
                if err == nil </span><span class="cov8" title="1">{
                        return val
                }</span>

                <span class="cov8" title="1">intVal, intErr := strconv.ParseInt(v, 0, 64)
                if intErr == nil </span><span class="cov8" title="1">{
                        return float64(intVal)
                }</span>

                <span class="cov8" title="1">return 0</span>
        case []byte:<span class="cov8" title="1">
                v := strings.TrimSpace(string(x))
                val, err := strconv.ParseFloat(v, 64)
                if err == nil </span><span class="cov8" title="1">{
                        return val
                }</span>

                <span class="cov8" title="1">intVal, intErr := strconv.ParseInt(v, 0, 64)
                if intErr == nil </span><span class="cov8" title="1">{
                        return float64(intVal)
                }</span>

                <span class="cov8" title="1">return 0</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package candy

// ToFloat64Slice 将一个切片接口尽力转换为 []float64。
//
// 支持的输入切片类型包括：
//   - []bool, []int, []int8, ..., []uint64, []float32, []float64, []string, [][]byte, []interface{}
//
// 切片中的每一个元素都会通过 ToFloat64 函数进行转换。
// 如果输入为 nil，将直接返回 nil。
// 如果输入为不支持的类型，将返回一个空的 []float64{}。
func ToFloat64Slice(val interface{}) []float64 <span class="cov8" title="1">{
        if val == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">switch x := val.(type) </span>{
        case []bool:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int8:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int16:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int32:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int64:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint8:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint16:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint32:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint64:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float32:<span class="cov8" title="1">
                v := make([]float64, len(x))
                for i, val := range x </span><span class="cov8" title="1">{
                        v[i] = ToFloat64(val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float64:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []string:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case [][]byte:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []interface{}:<span class="cov8" title="1">
                var v []float64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        default:<span class="cov8" title="1">
                return []float64{}</span>
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package candy

import "strconv"

// ToInt 将任何类型的值尽力转换为 int。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1, false 转换为 0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为无符号整数，若解析失败则返回 0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0。
func ToInt(val interface{}) int <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                return x</span>
        case int8:<span class="cov8" title="1">
                return int(x)</span>
        case int16:<span class="cov8" title="1">
                return int(x)</span>
        case int32:<span class="cov8" title="1">
                return int(x)</span>
        case int64:<span class="cov8" title="1">
                return int(x)</span>
        case uint:<span class="cov8" title="1">
                return int(x)</span>
        case uint8:<span class="cov8" title="1">
                return int(x)</span>
        case uint16:<span class="cov8" title="1">
                return int(x)</span>
        case uint32:<span class="cov8" title="1">
                return int(x)</span>
        case uint64:<span class="cov8" title="1">
                return int(x)</span>
        case float32:<span class="cov8" title="1">
                return int(x)</span>
        case float64:<span class="cov8" title="1">
                return int(x)</span>
        case string:<span class="cov8" title="1">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return int(val)</span>
        case []byte:<span class="cov8" title="1">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return int(val)</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package candy

import "strconv"

// ToInt16 将任何类型的值尽力转换为 int16。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1, false 转换为 0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为无符号整数，若解析失败则返回 0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0。
func ToInt16(val interface{}) int16 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                return int16(x)</span>
        case int8:<span class="cov8" title="1">
                return int16(x)</span>
        case int16:<span class="cov8" title="1">
                return x</span>
        case int32:<span class="cov8" title="1">
                return int16(x)</span>
        case int64:<span class="cov8" title="1">
                return int16(x)</span>
        case uint:<span class="cov8" title="1">
                return int16(x)</span>
        case uint8:<span class="cov8" title="1">
                return int16(x)</span>
        case uint16:<span class="cov8" title="1">
                return int16(x)</span>
        case uint32:<span class="cov8" title="1">
                return int16(x)</span>
        case uint64:<span class="cov8" title="1">
                return int16(x)</span>
        case float32:<span class="cov8" title="1">
                return int16(x)</span>
        case float64:<span class="cov8" title="1">
                return int16(x)</span>
        case string:<span class="cov8" title="1">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return int16(val)</span>
        case []byte:<span class="cov8" title="1">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return int16(val)</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package candy

import "strconv"

// ToInt32 将任何类型的值尽力转换为 int32。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1, false 转换为 0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为无符号整数，若解析失败则返回 0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0。
func ToInt32(val interface{}) int32 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                return int32(x)</span>
        case int8:<span class="cov8" title="1">
                return int32(x)</span>
        case int16:<span class="cov8" title="1">
                return int32(x)</span>
        case int32:<span class="cov8" title="1">
                return x</span>
        case int64:<span class="cov8" title="1">
                return int32(x)</span>
        case uint:<span class="cov8" title="1">
                return int32(x)</span>
        case uint8:<span class="cov8" title="1">
                return int32(x)</span>
        case uint16:<span class="cov8" title="1">
                return int32(x)</span>
        case uint32:<span class="cov8" title="1">
                return int32(x)</span>
        case uint64:<span class="cov8" title="1">
                return int32(x)</span>
        case float32:<span class="cov8" title="1">
                return int32(x)</span>
        case float64:<span class="cov8" title="1">
                return int32(x)</span>
        case string:<span class="cov8" title="1">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return int32(val)</span>
        case []byte:<span class="cov8" title="1">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return int32(val)</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package candy

import (
        "strconv"
        "time"
)

// ToInt64 将任何类型的值尽力转换为 int64。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1, false 转换为 0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - time.Duration: 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为有符号整数，若解析失败则返回 0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0。
func ToInt64(val interface{}) int64 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                return int64(x)</span>
        case int8:<span class="cov8" title="1">
                return int64(x)</span>
        case int16:<span class="cov8" title="1">
                return int64(x)</span>
        case int32:<span class="cov8" title="1">
                return int64(x)</span>
        case int64:<span class="cov8" title="1">
                return x</span>
        case uint:<span class="cov8" title="1">
                return int64(x)</span>
        case uint8:<span class="cov8" title="1">
                return int64(x)</span>
        case uint16:<span class="cov8" title="1">
                return int64(x)</span>
        case uint32:<span class="cov8" title="1">
                return int64(x)</span>
        case uint64:<span class="cov8" title="1">
                return int64(x)</span>
        case time.Duration:<span class="cov8" title="1">
                return int64(x)</span>
        case float32:<span class="cov8" title="1">
                return int64(x)</span>
        case float64:<span class="cov8" title="1">
                return int64(x)</span>
        case string:<span class="cov8" title="1">
                val, err := strconv.ParseInt(x, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return val</span>
        case []byte:<span class="cov8" title="1">
                val, err := strconv.ParseInt(string(x), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return val</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package candy

// ToInt64Slice 将一个切片接口尽力转换为 []int64。
//
// 支持的输入切片类型包括：
//   - []bool, []int, []int8, ..., []uint64, []float32, []float64, []string, [][]byte, []interface{}
//
// 切片中的每一个元素都会通过 ToInt64 函数进行转换。
// 如果输入为 nil，将直接返回 nil。
// 如果输入为不支持的类型，将返回一个空的 []int64{}。
func ToInt64Slice(val interface{}) []int64 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case []bool:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int8:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int16:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int32:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int64:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint8:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint16:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint32:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint64:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float32:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float64:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []string:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case [][]byte:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []interface{}:<span class="cov8" title="1">
                var v []int64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        default:<span class="cov8" title="1">
                return []int64{}</span>
        }
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package candy

import "strconv"

// ToInt8 将任何类型的值尽力转换为 int8。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1, false 转换为 0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为无符号整数，若解析失败则返回 0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0。
func ToInt8(val interface{}) int8 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                return int8(x)</span>
        case int8:<span class="cov8" title="1">
                return x</span>
        case int16:<span class="cov8" title="1">
                return int8(x)</span>
        case int32:<span class="cov8" title="1">
                return int8(x)</span>
        case int64:<span class="cov8" title="1">
                return int8(x)</span>
        case uint:<span class="cov8" title="1">
                return int8(x)</span>
        case uint8:<span class="cov8" title="1">
                return int8(x)</span>
        case uint16:<span class="cov8" title="1">
                return int8(x)</span>
        case uint32:<span class="cov8" title="1">
                return int8(x)</span>
        case uint64:<span class="cov8" title="1">
                return int8(x)</span>
        case float32:<span class="cov8" title="1">
                return int8(x)</span>
        case float64:<span class="cov8" title="1">
                return int8(x)</span>
        case string:<span class="cov8" title="1">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return int8(val)</span>
        case []byte:<span class="cov8" title="1">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return int8(val)</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package candy

import "github.com/lazygophers/utils/json"

// ToMap 将任何类型的值转换为 map[string]interface{}。
//
// 支持的输入类型包括：
//   - []byte: 尝试JSON反序列化为map，失败则通过ToMapStringAny转换
//   - string: 尝试JSON反序列化为map，失败则通过ToMapStringAny转换
//   - 其他类型: 通过ToMapStringAny函数转换
//
// 如果输入为 nil 或转换失败，将返回相应的默认值。
func ToMap(v interface{}) map[string]interface{} <span class="cov8" title="1">{
        switch x := v.(type) </span>{
        case []byte:<span class="cov8" title="1">
                var m map[string]interface{}
                err := json.Unmarshal(x, &amp;m)
                if err == nil </span><span class="cov8" title="1">{
                        return m
                }</span>

        case string:<span class="cov8" title="1">
                var m map[string]interface{}
                err := json.UnmarshalString(x, &amp;m)
                if err == nil </span><span class="cov8" title="1">{
                        return m
                }</span>

        }
        <span class="cov8" title="1">return ToMapStringAny(v)</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package candy

import "reflect"

// ToMapInt32String 将任何类型的 map 转换为 map[int32]string。
//
// 如果输入不是 map 类型，将返回一个空的 map[int32]string{}。
// map 的 key 会通过 ToInt32 函数转换为 int32，value 会通过 ToString 函数转换为字符串。
func ToMapInt32String(v interface{}) map[int32]string <span class="cov8" title="1">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov8" title="1">{
                return map[int32]string{}
        }</span>

        <span class="cov8" title="1">m := make(map[int32]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov8" title="1">{
                m[ToInt32(mg.Key().Interface())] = ToString(mg.Value().Interface())
        }</span>

        <span class="cov8" title="1">return m</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package candy

import "reflect"

// ToMapInt64String 将任何类型的 map 转换为 map[int64]string。
//
// 如果输入不是 map 类型，将返回一个空的 map[int64]string{}。
// map 的 key 会通过 ToInt64 函数转换为 int64，value 会通过 ToString 函数转换为字符串。
func ToMapInt64String(v interface{}) map[int64]string <span class="cov8" title="1">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov8" title="1">{
                return map[int64]string{}
        }</span>

        <span class="cov8" title="1">m := make(map[int64]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov8" title="1">{
                m[ToInt64(mg.Key().Interface())] = ToString(mg.Value().Interface())
        }</span>

        <span class="cov8" title="1">return m</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package candy

import "reflect"

// ToMapStringAny 将任何类型的 map 转换为 map[string]interface{}。
//
// 如果输入为 nil，将返回 nil。
// 如果输入不是 map 类型，将返回一个空的 map[string]interface{}{}。
// map 的 key 会通过 ToString 函数转换为字符串，value 保持原始类型。
func ToMapStringAny(v interface{}) map[string]interface{} <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov8" title="1">{
                return map[string]interface{}{}
        }</span>

        <span class="cov8" title="1">m := make(map[string]interface{})

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov8" title="1">{
                m[ToString(mg.Key().Interface())] = mg.Value().Interface()
        }</span>

        <span class="cov8" title="1">return m</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package candy

import "reflect"

// ToMapStringArrayString 将任何类型的 map 转换为 map[string][]string。
//
// 如果输入为 nil，将返回 nil。
// 如果输入不是 map 类型，将会 panic。
// map 的 key 会通过 ToString 函数转换为字符串，value 会通过 ToArrayString 函数转换为 []string。
func ToMapStringArrayString(v interface{}) map[string][]string <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }

        <span class="cov8" title="1">m := make(map[string][]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov8" title="1">{
                m[ToString(mg.Key().Interface())] = ToArrayString(mg.Value().Interface())
        }</span>

        <span class="cov8" title="1">return m</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package candy

import "reflect"

// ToMapStringInt64 将任何类型的 map 转换为 map[string]int64。
//
// 如果输入不是 map 类型，将返回一个空的 map[string]int64{}。
// map 的 key 会通过 ToString 函数转换为字符串，value 会通过 ToInt64 函数转换为 int64。
func ToMapStringInt64(v interface{}) map[string]int64 <span class="cov8" title="1">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov8" title="1">{
                return map[string]int64{}
        }</span>

        <span class="cov8" title="1">m := make(map[string]int64)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov8" title="1">{
                m[ToString(mg.Key().Interface())] = ToInt64(mg.Value().Interface())
        }</span>

        <span class="cov8" title="1">return m</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package candy

import "reflect"

// ToMapStringString 将任何类型的 map 转换为 map[string]string。
//
// 如果输入不是 map 类型，将返回一个空的 map[string]string{}。
// map 的 key 和 value 都会通过 ToString 函数转换为字符串。
func ToMapStringString(v interface{}) map[string]string <span class="cov8" title="1">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov8" title="1">{
                return map[string]string{}
        }</span>

        <span class="cov8" title="1">m := make(map[string]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov8" title="1">{
                m[ToString(mg.Key().Interface())] = ToString(mg.Value().Interface())
        }</span>

        <span class="cov8" title="1">return m</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package candy

// ToPtr 将值转换为指针
// 接受任意类型的值并返回其指针
func ToPtr[T any](v T) *T <span class="cov8" title="1">{
        return &amp;v
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package candy

import (
        "math"
        "strconv"
        "time"

        "github.com/lazygophers/utils/json"
)

// ToString 将任意类型转换为字符串
// 支持的类型包括：
// - 布尔值：true -&gt; "1", false -&gt; "0"
// - 整数类型：int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64
// - 浮点数：float32, float64（自动处理精度）
// - 时间类型：time.Duration
// - 字符串：直接返回
// - 字节切片：转换为字符串
// - nil：返回空字符串
// - error：返回错误信息
// - 其他类型：使用 JSON 序列化
func ToString(val interface{}) string <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                if x </span><span class="cov8" title="1">{
                        return "1"
                }</span>
                <span class="cov8" title="1">return "0"</span>
        case int:<span class="cov8" title="1">
                return strconv.FormatInt(int64(x), 10)</span>
        case int8:<span class="cov8" title="1">
                return strconv.FormatInt(int64(x), 10)</span>
        case int16:<span class="cov8" title="1">
                return strconv.FormatInt(int64(x), 10)</span>
        case int32:<span class="cov8" title="1">
                return strconv.FormatInt(int64(x), 10)</span>
        case int64:<span class="cov8" title="1">
                return strconv.FormatInt(x, 10)</span>
        case uint:<span class="cov8" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint8:<span class="cov8" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint16:<span class="cov8" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint32:<span class="cov8" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint64:<span class="cov8" title="1">
                return strconv.FormatUint(x, 10)</span>
        case float32:<span class="cov8" title="1">
                if math.Floor(float64(x)) == float64(x) </span><span class="cov8" title="1">{
                        return strconv.FormatFloat(float64(x), 'f', 0, 32)
                }</span>

                <span class="cov8" title="1">return strconv.FormatFloat(float64(x), 'f', 15, 32)</span>
        case float64:<span class="cov8" title="1">
                if math.Floor(x) == x </span><span class="cov8" title="1">{
                        return strconv.FormatFloat(x, 'f', 0, 64)
                }</span>

                <span class="cov8" title="1">return strconv.FormatFloat(x, 'f', 6, 64)</span>
        case time.Duration:<span class="cov8" title="1">
                return x.String()</span>
        case string:<span class="cov8" title="1">
                return x</span>
        case []byte:<span class="cov8" title="1">
                return string(x)</span>
        case nil:<span class="cov8" title="1">
                return ""</span>
        case error:<span class="cov8" title="1">
                return x.Error()</span>

        default:<span class="cov8" title="1">
                buf, err := json.Marshal(x)
                if err != nil </span><span class="cov8" title="1">{
                        return ""
                }</span>

                <span class="cov8" title="1">return string(buf)</span>
        }
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package candy

import (
        "bytes"
        "math"
        "strconv"
        "strings"

        "github.com/lazygophers/utils/json"
)

// ToStringSlice 将任意类型转换为字符串切片
// 支持的类型包括各种基础类型的切片、字符串、字节切片等
// seqs 参数用于指定分隔符，默认为逗号
func ToStringSlice(val interface{}, seqs ...string) []string <span class="cov8" title="1">{
        var seq string
        if len(seqs) &gt; 0 </span><span class="cov8" title="1">{
                seq = seqs[0]
        }</span> else<span class="cov8" title="1"> {
                seq = ","
        }</span>

        <span class="cov8" title="1">switch x := val.(type) </span>{
        case []bool:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        if v </span><span class="cov8" title="1">{
                                ss = append(ss, "1")
                        }</span> else<span class="cov8" title="1"> {
                                ss = append(ss, "0")
                        }</span>
                }
                <span class="cov8" title="1">return ss</span>

        case []int:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        ss = append(ss, strconv.Itoa(v))
                }</span>
                <span class="cov8" title="1">return ss</span>

        case []int8:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        ss = append(ss, strconv.FormatInt(int64(v), 10))
                }</span>
                <span class="cov8" title="1">return ss</span>

        case []int16:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        ss = append(ss, strconv.FormatInt(int64(v), 10))
                }</span>
                <span class="cov8" title="1">return ss</span>

        case []int32:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        ss = append(ss, strconv.FormatInt(int64(v), 10))
                }</span>
                <span class="cov8" title="1">return ss</span>

        case []int64:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        ss = append(ss, strconv.FormatInt(v, 10))
                }</span>
                <span class="cov8" title="1">return ss</span>

        case []uint:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        ss = append(ss, strconv.FormatUint(uint64(v), 10))
                }</span>
                <span class="cov8" title="1">return ss</span>

        case []uint16:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        ss = append(ss, strconv.FormatUint(uint64(v), 10))
                }</span>
                <span class="cov8" title="1">return ss</span>

        case []uint32:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        ss = append(ss, strconv.FormatUint(uint64(v), 10))
                }</span>
                <span class="cov8" title="1">return ss</span>

        case []uint64:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        ss = append(ss, strconv.FormatUint(v, 10))
                }</span>
                <span class="cov8" title="1">return ss</span>

        case []float32:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        if math.Floor(float64(v)) == float64(v) </span><span class="cov8" title="1">{
                                ss = append(ss, strconv.FormatInt(int64(v), 10))
                        }</span> else<span class="cov8" title="1"> {
                                ss = append(ss, strconv.FormatFloat(float64(v), 'f', -1, 32))
                        }</span>
                }
                <span class="cov8" title="1">return ss</span>

        case []float64:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        if math.Floor(v) == (v) </span><span class="cov8" title="1">{
                                ss = append(ss, strconv.FormatInt(int64(v), 10))
                        }</span> else<span class="cov8" title="1"> {
                                ss = append(ss, strconv.FormatFloat(v, 'f', -1, 32))
                        }</span>
                }
                <span class="cov8" title="1">return ss</span>

        case []string:<span class="cov8" title="1">
                return x</span>

        case []byte:<span class="cov8" title="1">
                if bytes.HasPrefix(x, []byte("[")) &amp;&amp; bytes.HasSuffix(x, []byte("]")) </span><span class="cov8" title="1">{
                        var values []any
                        err := json.Unmarshal(x, &amp;values)
                        if err == nil </span><span class="cov8" title="1">{
                                return ToStringSlice(values)
                        }</span>
                }

                <span class="cov8" title="1">if seq == "" </span><span class="cov8" title="1">{
                        return []string{toString(x)}
                }</span>

                <span class="cov8" title="1">return strings.Split(toString(x), seq)</span>

        case string:<span class="cov8" title="1">
                if strings.HasPrefix(x, "[") &amp;&amp; strings.HasSuffix(x, "]") </span><span class="cov8" title="1">{
                        var values []any
                        err := json.UnmarshalString(x, &amp;values)
                        if err == nil </span><span class="cov8" title="1">{
                                return ToStringSlice(values)
                        }</span>
                }

                <span class="cov8" title="1">if seq == "" </span><span class="cov8" title="1">{
                        return []string{x}
                }</span>

                <span class="cov8" title="1">return strings.Split(x, seq)</span>

        case []interface{}:<span class="cov8" title="1">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="1">{
                        ss = append(ss, ToString(v))
                }</span>
                <span class="cov8" title="1">return ss</span>

        default:<span class="cov8" title="1">
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package candy

import "strconv"

// ToUint 将任意类型的值转换为 uint 类型
// 支持的类型包括：bool、所有整数类型、浮点数、字符串、字节切片
// 对于不支持的类型或转换失败的情况，返回 0
func ToUint(val interface{}) uint <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                // 布尔值转换：true -&gt; 1，false -&gt; 0
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                // 有符号整数直接转换为 uint
                return uint(x)</span>
        case int8:<span class="cov8" title="1">
                return uint(x)</span>
        case int16:<span class="cov8" title="1">
                return uint(x)</span>
        case int32:<span class="cov8" title="1">
                return uint(x)</span>
        case int64:<span class="cov8" title="1">
                return uint(x)</span>
        case uint:<span class="cov8" title="1">
                // 无符号整数直接返回
                return x</span>
        case uint8:<span class="cov8" title="1">
                return uint(x)</span>
        case uint16:<span class="cov8" title="1">
                return uint(x)</span>
        case uint32:<span class="cov8" title="1">
                return uint(x)</span>
        case uint64:<span class="cov8" title="1">
                return uint(x)</span>
        case float32:<span class="cov8" title="1">
                // 浮点数转换为 uint，会截断小数部分
                return uint(x)</span>
        case float64:<span class="cov8" title="1">
                return uint(x)</span>
        case string:<span class="cov8" title="1">
                // 字符串解析为 uint，使用十进制格式
                // 解析失败时返回 0
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return uint(val)</span>
        case []byte:<span class="cov8" title="1">
                // 字节切片转换为字符串后再解析为 uint
                // 解析失败时返回 0
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return uint(val)</span>
        default:<span class="cov8" title="1">
                // 不支持的类型返回 0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file74" style="display: none">// Package candy 提供语法糖和便捷的类型转换工具函数
package candy

import "strconv"

// ToUint16 将各种类型的值转换为 uint16 类型
//
// 支持的输入类型：
//   - bool: true 转换为 1，false 转换为 0
//   - 整数类型 (int, int8, int16, int32, int64): 直接转换
//   - 无符号整数 (uint, uint8, uint16, uint32, uint64): 直接转换
//   - 浮点数 (float32, float64): 截断小数部分后转换
//   - string: 使用 strconv.ParseUint 解析十进制字符串，失败返回 0
//   - []byte: 转换为字符串后解析，失败返回 0
//   - 其他类型: 返回 0
//
// 参数:
//
//        val: 要转换的值，支持多种类型
//
// 返回:
//
//        uint16: 转换后的 uint16 值，转换失败时返回 0
//
// 示例:
//
//        ToUint16(42)        // 返回 42
//        ToUint16("100")     // 返回 100
//        ToUint16(true)      // 返回 1
//        ToUint16(3.14)      // 返回 3
//        ToUint16("invalid") // 返回 0
func ToUint16(val interface{}) uint16 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                // 布尔值转换：true -&gt; 1, false -&gt; 0
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                // 有符号整数直接转换
                return uint16(x)</span>
        case int8:<span class="cov8" title="1">
                // 8位有符号整数直接转换
                return uint16(x)</span>
        case int16:<span class="cov8" title="1">
                // 16位有符号整数直接转换
                return uint16(x)</span>
        case int32:<span class="cov8" title="1">
                // 32位有符号整数直接转换
                return uint16(x)</span>
        case int64:<span class="cov8" title="1">
                // 64位有符号整数直接转换
                return uint16(x)</span>
        case uint:<span class="cov8" title="1">
                // 无符号整数直接转换
                return uint16(x)</span>
        case uint8:<span class="cov8" title="1">
                // 8位无符号整数直接转换
                return uint16(x)</span>
        case uint16:<span class="cov8" title="1">
                // 如果已经是 uint16 类型，直接返回
                return x</span>
        case uint32:<span class="cov8" title="1">
                // 32位无符号整数直接转换
                return uint16(x)</span>
        case uint64:<span class="cov8" title="1">
                // 64位无符号整数直接转换
                return uint16(x)</span>
        case float32:<span class="cov8" title="1">
                // 32位浮点数转换，截断小数部分
                return uint16(x)</span>
        case float64:<span class="cov8" title="1">
                // 64位浮点数转换，截断小数部分
                return uint16(x)</span>
        case string:<span class="cov8" title="1">
                // 字符串解析为无符号整数
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        // 解析失败返回 0
                        return 0
                }</span>
                <span class="cov8" title="1">return uint16(val)</span>
        case []byte:<span class="cov8" title="1">
                // 字节切片转换为字符串后解析
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        // 解析失败返回 0
                        return 0
                }</span>
                <span class="cov8" title="1">return uint16(val)</span>
        default:<span class="cov8" title="1">
                // 不支持的类型返回 0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package candy

import "strconv"

// ToUint32 将任意类型转换为 uint32 类型
// 支持的类型包括：bool、所有整数类型、浮点数、字符串、字节数组
// 转换失败时返回 0
func ToUint32(val interface{}) uint32 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                // 布尔值转换：true -&gt; 1，false -&gt; 0
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                // 有符号整数转换为 uint32
                return uint32(x)</span>
        case int8:<span class="cov8" title="1">
                // 8位有符号整数转换为 uint32
                return uint32(x)</span>
        case int16:<span class="cov8" title="1">
                // 16位有符号整数转换为 uint32
                return uint32(x)</span>
        case int32:<span class="cov8" title="1">
                // 32位有符号整数转换为 uint32
                return uint32(x)</span>
        case int64:<span class="cov8" title="1">
                // 64位有符号整数转换为 uint32
                return uint32(x)</span>
        case uint:<span class="cov8" title="1">
                // 无符号整数转换为 uint32
                return uint32(x)</span>
        case uint8:<span class="cov8" title="1">
                // 8位无符号整数转换为 uint32
                return uint32(x)</span>
        case uint16:<span class="cov8" title="1">
                // 16位无符号整数转换为 uint32
                return uint32(x)</span>
        case uint32:<span class="cov8" title="1">
                // 如果已经是 uint32 类型，直接返回
                return x</span>
        case uint64:<span class="cov8" title="1">
                // 64位无符号整数转换为 uint32，可能发生截断
                return uint32(x)</span>
        case float32:<span class="cov8" title="1">
                // 32位浮点数转换为 uint32
                return uint32(x)</span>
        case float64:<span class="cov8" title="1">
                // 64位浮点数转换为 uint32
                return uint32(x)</span>
        case string:<span class="cov8" title="1">
                // 字符串解析为 uint32
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return uint32(val)</span>
        case []byte:<span class="cov8" title="1">
                // 字节数组转换为字符串后解析为 uint32
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return uint32(val)</span>
        default:<span class="cov8" title="1">
                // 不支持的类型返回 0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file76" style="display: none">// Package candy 提供语法糖和便捷的类型转换工具函数
package candy

import "strconv"

// ToUint64 将各种类型的值转换为 uint64 类型
//
// 支持的输入类型：
//   - bool: true 转换为 1，false 转换为 0
//   - 整数类型 (int, int8, int16, int32, int64): 直接转换
//   - 无符号整数 (uint, uint8, uint16, uint32, uint64): 直接转换
//   - 浮点数 (float32, float64): 截断小数部分后转换
//   - string: 使用 strconv.ParseUint 解析十进制字符串，失败返回 0
//   - []byte: 转换为字符串后解析，失败返回 0
//   - 其他类型: 返回 0
//
// 参数:
//
//        val: 要转换的值，支持多种类型
//
// 返回:
//
//        uint64: 转换后的 uint64 值，转换失败时返回 0
//
// 示例:
//
//        ToUint64(42)         // 返回 42
//        ToUint64("100")      // 返回 100
//        ToUint64(true)       // 返回 1
//        ToUint64(3.14)       // 返回 3
//        ToUint64("invalid")  // 返回 0
func ToUint64(val interface{}) uint64 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                // 布尔值转换：true -&gt; 1, false -&gt; 0
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                // 有符号整数直接转换
                return uint64(x)</span>
        case int8:<span class="cov8" title="1">
                // 8位有符号整数直接转换
                return uint64(x)</span>
        case int16:<span class="cov8" title="1">
                // 16位有符号整数直接转换
                return uint64(x)</span>
        case int32:<span class="cov8" title="1">
                // 32位有符号整数直接转换
                return uint64(x)</span>
        case int64:<span class="cov8" title="1">
                // 64位有符号整数直接转换
                return uint64(x)</span>
        case uint:<span class="cov8" title="1">
                // 无符号整数直接转换
                return uint64(x)</span>
        case uint8:<span class="cov8" title="1">
                // 8位无符号整数直接转换
                return uint64(x)</span>
        case uint16:<span class="cov8" title="1">
                // 16位无符号整数直接转换
                return uint64(x)</span>
        case uint32:<span class="cov8" title="1">
                // 32位无符号整数直接转换
                return uint64(x)</span>
        case uint64:<span class="cov8" title="1">
                // 如果已经是 uint64 类型，直接返回
                return x</span>
        case float32:<span class="cov8" title="1">
                // 32位浮点数转换，截断小数部分
                return uint64(x)</span>
        case float64:<span class="cov8" title="1">
                // 64位浮点数转换，截断小数部分
                return uint64(x)</span>
        case string:<span class="cov8" title="1">
                // 字符串解析为无符号整数
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        // 解析失败返回 0
                        return 0
                }</span>
                <span class="cov8" title="1">return val</span>
        case []byte:<span class="cov8" title="1">
                // 字节切片转换为字符串后解析
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        // 解析失败返回 0
                        return 0
                }</span>
                <span class="cov8" title="1">return val</span>
        default:<span class="cov8" title="1">
                // 不支持的类型返回 0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package candy

import "strconv"

// ToUint8 将任意类型的值转换为 uint8 类型
// 支持的类型包括：bool、所有整数类型、浮点数、字符串、字节切片
// 对于不支持的类型或转换失败的情况，返回 0
func ToUint8(val interface{}) uint8 <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                // 布尔值转换：true -&gt; 1，false -&gt; 0
                if x </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int:<span class="cov8" title="1">
                // 有符号整数直接转换为 uint8
                return uint8(x)</span>
        case int8:<span class="cov8" title="1">
                return uint8(x)</span>
        case int16:<span class="cov8" title="1">
                return uint8(x)</span>
        case int32:<span class="cov8" title="1">
                return uint8(x)</span>
        case int64:<span class="cov8" title="1">
                return uint8(x)</span>
        case uint:<span class="cov8" title="1">
                // 无符号整数转换为 uint8，可能会截断高位
                return uint8(x)</span>
        case uint8:<span class="cov8" title="1">
                // uint8 类型直接返回
                return x</span>
        case uint16:<span class="cov8" title="1">
                // uint16 转换为 uint8，可能会截断高位
                return uint8(x)</span>
        case uint32:<span class="cov8" title="1">
                // uint32 转换为 uint8，可能会截断高位
                return uint8(x)</span>
        case uint64:<span class="cov8" title="1">
                // uint64 转换为 uint8，可能会截断高位
                return uint8(x)</span>
        case float32:<span class="cov8" title="1">
                // 浮点数转换为 uint8，会截断小数部分
                return uint8(x)</span>
        case float64:<span class="cov8" title="1">
                // 浮点数转换为 uint8，会截断小数部分
                return uint8(x)</span>
        case string:<span class="cov8" title="1">
                // 字符串解析为 uint8，使用十进制格式
                // 解析失败时返回 0
                val, err := strconv.ParseUint(x, 10, 8)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return uint8(val)</span>
        case []byte:<span class="cov8" title="1">
                // 字节切片转换为字符串后再解析为 uint8
                // 解析失败时返回 0
                val, err := strconv.ParseUint(string(x), 10, 8)
                if err != nil </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">return uint8(val)</span>
        default:<span class="cov8" title="1">
                // 不支持的类型返回 0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package candy

// Top 返回切片中的前 n 个元素
// 如果 n 大于切片长度，则返回整个切片的副本
// 使用 copy 确保返回的是新切片，避免修改原切片
func Top[T any](ss []T, n int) (ret []T) <span class="cov8" title="1">{
        if n &lt;= 0 </span><span class="cov8" title="1">{
                return []T{}
        }</span>
        <span class="cov8" title="1">if n &gt; len(ss) </span><span class="cov8" title="1">{
                n = len(ss)
        }</span>

        <span class="cov8" title="1">ret = make([]T, n)
        copy(ret, ss[:n])
        return ret</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import (
        "golang.org/x/exp/constraints"
)

// Unique 返回切片中的唯一元素，保持原始顺序
//
// 类型参数：
//   - T: 可排序的类型，支持所有可比较的内置类型
//
// 参数：
//   - ss: 输入切片，包含可排序类型的元素
//
// 返回值：
//   - []T: 去重后的切片，保持原始顺序
//
// 特点：
//   - 保持原始元素的顺序
//   - 使用 map 高效去重，时间复杂度 O(n)
//   - 空切片安全，返回空切片而非 nil
//   - 只支持可排序类型，确保类型安全
//
// 示例：
//
//        // 对整数切片去重
//        numbers := []int{1, 2, 2, 3, 4, 4, 5}
//        unique := Unique(numbers)
//        // unique 的值为 []int{1, 2, 3, 4, 5}
//
//        // 对字符串切片去重
//        names := []string{"Alice", "Bob", "Alice", "Charlie", "Bob"}
//        uniqueNames := Unique(names)
//        // uniqueNames 的值为 []string{"Alice", "Bob", "Charlie"}
//
//        // 对浮点数切片去重
//        floats := []float64{1.1, 2.2, 1.1, 3.3, 2.2}
//        uniqueFloats := Unique(floats)
//        // uniqueFloats 的值为 []float64{1.1, 2.2, 3.3}
func Unique[T constraints.Ordered](ss []T) (ret []T) <span class="cov8" title="1">{
        // 使用 make 初始化，确保返回空切片而非 nil
        ret = make([]T, 0)
        m := make(map[T]struct{}, len(ss))
        for _, s := range ss </span><span class="cov8" title="1">{
                if _, ok := m[s]; !ok </span><span class="cov8" title="1">{
                        m[s] = struct{}{}
                        ret = append(ret, s)
                }</span>
        }

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

// UniqueUsing 返回切片中的唯一元素，保持原始顺序，使用提供的函数来生成用于比较的键
//
// 类型参数：
//   - T: 任意类型，支持所有可比较的类型
//
// 参数：
//   - ss: 输入切片，包含任意类型的元素
//   - f: 键生成函数，用于从元素中提取比较键
//
// 返回值：
//   - []T: 去重后的切片，保持原始顺序
//
// 特点：
//   - 保持原始元素的顺序
//   - 使用自定义键生成函数，支持复杂类型去重
//   - 空切片安全，返回空切片而非 nil
//   - 适用于结构体、自定义类型等复杂类型
//   - 时间复杂度 O(n)，空间复杂度 O(n)
//
// 示例：
//
//        // 对结构体切片去重（按 ID）
//        type User struct {
//            ID   int
//            Name string
//        }
//        users := []User{{1, "Alice"}, {2, "Bob"}, {1, "Alice2"}}
//        uniqueUsers := UniqueUsing(users, func(u User) any { return u.ID })
//        // uniqueUsers 的值为 []User{{1, "Alice"}, {2, "Bob"}}
//
//        // 对字符串切片按长度去重
//        words := []string{"apple", "banana", "orange", "kiwi"}
//        uniqueLengths := UniqueUsing(words, func(s string) any { return len(s) })
//        // uniqueLengths 的值为 []string{"apple", "banana", "orange"}
//
//        // 对切片按首字母去重
//        names := []string{"Alice", "Bob", "Anna", "Charlie", "Bob"}
//        uniqueFirstLetters := UniqueUsing(names, func(s string) any { return s[0] })
//        // uniqueFirstLetters 的值为 []string{"Alice", "Bob", "Charlie"}
func UniqueUsing[T any](ss []T, f func(T) any) (ret []T) <span class="cov8" title="1">{
        // 空切片检查，返回空切片而非 nil
        if len(ss) == 0 </span><span class="cov8" title="1">{
                return []T{}
        }</span>

        // 创建映射用于记录已出现的键值
        <span class="cov8" title="1">m := make(map[any]struct{})

        // 遍历输入切片
        for _, s := range ss </span><span class="cov8" title="1">{
                // 使用映射函数提取键值
                key := f(s)

                // 如果键值未出现过，则添加到结果切片
                if _, ok := m[key]; !ok </span><span class="cov8" title="1">{
                        m[key] = struct{}{}
                        ret = append(ret, s)
                }</span>
        }

        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
