
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>anyx: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lazygophers/utils/anyx/map.go (98.6%)</option>
				
				<option value="file1">github.com/lazygophers/utils/anyx/map_any.go (99.3%)</option>
				
				<option value="file2">github.com/lazygophers/utils/app/info.go (0.0%)</option>
				
				<option value="file3">github.com/lazygophers/utils/atexit/atexit_darwin.go (100.0%)</option>
				
				<option value="file4">github.com/lazygophers/utils/bufiox/scan.go (100.0%)</option>
				
				<option value="file5">github.com/lazygophers/utils/candy/abs.go (100.0%)</option>
				
				<option value="file6">github.com/lazygophers/utils/candy/all.go (100.0%)</option>
				
				<option value="file7">github.com/lazygophers/utils/candy/any.go (100.0%)</option>
				
				<option value="file8">github.com/lazygophers/utils/candy/average.go (100.0%)</option>
				
				<option value="file9">github.com/lazygophers/utils/candy/bottom.go (100.0%)</option>
				
				<option value="file10">github.com/lazygophers/utils/candy/cbrt.go (100.0%)</option>
				
				<option value="file11">github.com/lazygophers/utils/candy/chunk.go (100.0%)</option>
				
				<option value="file12">github.com/lazygophers/utils/candy/contains.go (100.0%)</option>
				
				<option value="file13">github.com/lazygophers/utils/candy/contains_using.go (100.0%)</option>
				
				<option value="file14">github.com/lazygophers/utils/candy/deep_copy.go (92.9%)</option>
				
				<option value="file15">github.com/lazygophers/utils/candy/deep_equal.go (98.1%)</option>
				
				<option value="file16">github.com/lazygophers/utils/candy/diff.go (100.0%)</option>
				
				<option value="file17">github.com/lazygophers/utils/candy/diff_slice.go (100.0%)</option>
				
				<option value="file18">github.com/lazygophers/utils/candy/drop.go (100.0%)</option>
				
				<option value="file19">github.com/lazygophers/utils/candy/each.go (100.0%)</option>
				
				<option value="file20">github.com/lazygophers/utils/candy/each_reverse.go (100.0%)</option>
				
				<option value="file21">github.com/lazygophers/utils/candy/each_stop_with_error.go (100.0%)</option>
				
				<option value="file22">github.com/lazygophers/utils/candy/filter.go (100.0%)</option>
				
				<option value="file23">github.com/lazygophers/utils/candy/filter_not.go (100.0%)</option>
				
				<option value="file24">github.com/lazygophers/utils/candy/first.go (100.0%)</option>
				
				<option value="file25">github.com/lazygophers/utils/candy/first_or.go (100.0%)</option>
				
				<option value="file26">github.com/lazygophers/utils/candy/index.go (100.0%)</option>
				
				<option value="file27">github.com/lazygophers/utils/candy/join.go (100.0%)</option>
				
				<option value="file28">github.com/lazygophers/utils/candy/last.go (100.0%)</option>
				
				<option value="file29">github.com/lazygophers/utils/candy/last_or.go (100.0%)</option>
				
				<option value="file30">github.com/lazygophers/utils/candy/map.go (100.0%)</option>
				
				<option value="file31">github.com/lazygophers/utils/candy/max.go (100.0%)</option>
				
				<option value="file32">github.com/lazygophers/utils/candy/min.go (100.0%)</option>
				
				<option value="file33">github.com/lazygophers/utils/candy/pluck_int.go (97.5%)</option>
				
				<option value="file34">github.com/lazygophers/utils/candy/pluck_int32.go (100.0%)</option>
				
				<option value="file35">github.com/lazygophers/utils/candy/pluck_int64.go (100.0%)</option>
				
				<option value="file36">github.com/lazygophers/utils/candy/pluck_string.go (100.0%)</option>
				
				<option value="file37">github.com/lazygophers/utils/candy/pluck_string_slice.go (100.0%)</option>
				
				<option value="file38">github.com/lazygophers/utils/candy/pluck_uint32.go (100.0%)</option>
				
				<option value="file39">github.com/lazygophers/utils/candy/pluck_uint64.go (100.0%)</option>
				
				<option value="file40">github.com/lazygophers/utils/candy/pow.go (100.0%)</option>
				
				<option value="file41">github.com/lazygophers/utils/candy/random.go (100.0%)</option>
				
				<option value="file42">github.com/lazygophers/utils/candy/reduce.go (100.0%)</option>
				
				<option value="file43">github.com/lazygophers/utils/candy/remove.go (100.0%)</option>
				
				<option value="file44">github.com/lazygophers/utils/candy/remove_index.go (100.0%)</option>
				
				<option value="file45">github.com/lazygophers/utils/candy/remove_slice.go (100.0%)</option>
				
				<option value="file46">github.com/lazygophers/utils/candy/reverse.go (100.0%)</option>
				
				<option value="file47">github.com/lazygophers/utils/candy/same.go (100.0%)</option>
				
				<option value="file48">github.com/lazygophers/utils/candy/shuffle.go (100.0%)</option>
				
				<option value="file49">github.com/lazygophers/utils/candy/slice_equal.go (94.1%)</option>
				
				<option value="file50">github.com/lazygophers/utils/candy/sort.go (100.0%)</option>
				
				<option value="file51">github.com/lazygophers/utils/candy/sort_using.go (100.0%)</option>
				
				<option value="file52">github.com/lazygophers/utils/candy/spare.go (100.0%)</option>
				
				<option value="file53">github.com/lazygophers/utils/candy/sqrt.go (100.0%)</option>
				
				<option value="file54">github.com/lazygophers/utils/candy/string.go (100.0%)</option>
				
				<option value="file55">github.com/lazygophers/utils/candy/sum.go (100.0%)</option>
				
				<option value="file56">github.com/lazygophers/utils/candy/to_array_string.go (100.0%)</option>
				
				<option value="file57">github.com/lazygophers/utils/candy/to_bool.go (100.0%)</option>
				
				<option value="file58">github.com/lazygophers/utils/candy/to_bytes.go (100.0%)</option>
				
				<option value="file59">github.com/lazygophers/utils/candy/to_float32.go (100.0%)</option>
				
				<option value="file60">github.com/lazygophers/utils/candy/to_float64.go (100.0%)</option>
				
				<option value="file61">github.com/lazygophers/utils/candy/to_float64_slice.go (100.0%)</option>
				
				<option value="file62">github.com/lazygophers/utils/candy/to_int.go (100.0%)</option>
				
				<option value="file63">github.com/lazygophers/utils/candy/to_int16.go (100.0%)</option>
				
				<option value="file64">github.com/lazygophers/utils/candy/to_int32.go (100.0%)</option>
				
				<option value="file65">github.com/lazygophers/utils/candy/to_int64.go (100.0%)</option>
				
				<option value="file66">github.com/lazygophers/utils/candy/to_int64_slice.go (100.0%)</option>
				
				<option value="file67">github.com/lazygophers/utils/candy/to_int8.go (100.0%)</option>
				
				<option value="file68">github.com/lazygophers/utils/candy/to_map.go (100.0%)</option>
				
				<option value="file69">github.com/lazygophers/utils/candy/to_map_int32_string.go (100.0%)</option>
				
				<option value="file70">github.com/lazygophers/utils/candy/to_map_int64_string.go (100.0%)</option>
				
				<option value="file71">github.com/lazygophers/utils/candy/to_map_string_any.go (100.0%)</option>
				
				<option value="file72">github.com/lazygophers/utils/candy/to_map_string_array_string.go (100.0%)</option>
				
				<option value="file73">github.com/lazygophers/utils/candy/to_map_string_int64.go (100.0%)</option>
				
				<option value="file74">github.com/lazygophers/utils/candy/to_map_string_string.go (100.0%)</option>
				
				<option value="file75">github.com/lazygophers/utils/candy/to_ptr.go (100.0%)</option>
				
				<option value="file76">github.com/lazygophers/utils/candy/to_string.go (100.0%)</option>
				
				<option value="file77">github.com/lazygophers/utils/candy/to_string_slice.go (98.8%)</option>
				
				<option value="file78">github.com/lazygophers/utils/candy/to_uint.go (100.0%)</option>
				
				<option value="file79">github.com/lazygophers/utils/candy/to_uint16.go (100.0%)</option>
				
				<option value="file80">github.com/lazygophers/utils/candy/to_uint32.go (100.0%)</option>
				
				<option value="file81">github.com/lazygophers/utils/candy/to_uint64.go (100.0%)</option>
				
				<option value="file82">github.com/lazygophers/utils/candy/to_uint8.go (100.0%)</option>
				
				<option value="file83">github.com/lazygophers/utils/candy/top.go (100.0%)</option>
				
				<option value="file84">github.com/lazygophers/utils/candy/unique.go (100.0%)</option>
				
				<option value="file85">github.com/lazygophers/utils/candy/unique_using.go (100.0%)</option>
				
				<option value="file86">github.com/lazygophers/utils/config/load.go (95.7%)</option>
				
				<option value="file87">github.com/lazygophers/utils/cryptox/aes.go (100.0%)</option>
				
				<option value="file88">github.com/lazygophers/utils/cryptox/blowfish.go (100.0%)</option>
				
				<option value="file89">github.com/lazygophers/utils/cryptox/chacha20.go (100.0%)</option>
				
				<option value="file90">github.com/lazygophers/utils/cryptox/des.go (100.0%)</option>
				
				<option value="file91">github.com/lazygophers/utils/cryptox/ecdh.go (100.0%)</option>
				
				<option value="file92">github.com/lazygophers/utils/cryptox/ecdsa.go (100.0%)</option>
				
				<option value="file93">github.com/lazygophers/utils/cryptox/hash_basic.go (100.0%)</option>
				
				<option value="file94">github.com/lazygophers/utils/cryptox/hash_blake2.go (100.0%)</option>
				
				<option value="file95">github.com/lazygophers/utils/cryptox/hash_crc.go (100.0%)</option>
				
				<option value="file96">github.com/lazygophers/utils/cryptox/hash_fnv.go (100.0%)</option>
				
				<option value="file97">github.com/lazygophers/utils/cryptox/hash_hmac.go (100.0%)</option>
				
				<option value="file98">github.com/lazygophers/utils/cryptox/hash_sha3.go (100.0%)</option>
				
				<option value="file99">github.com/lazygophers/utils/cryptox/hmac.go (100.0%)</option>
				
				<option value="file100">github.com/lazygophers/utils/cryptox/kdf.go (100.0%)</option>
				
				<option value="file101">github.com/lazygophers/utils/cryptox/rsa.go (100.0%)</option>
				
				<option value="file102">github.com/lazygophers/utils/cryptox/uuid.go (100.0%)</option>
				
				<option value="file103">github.com/lazygophers/utils/defaults/default.go (100.0%)</option>
				
				<option value="file104">github.com/lazygophers/utils/event/event.go (0.0%)</option>
				
				<option value="file105">github.com/lazygophers/utils/fake/user_agent.go (0.0%)</option>
				
				<option value="file106">github.com/lazygophers/utils/hystrix/hystrix.go (66.8%)</option>
				
				<option value="file107">github.com/lazygophers/utils/hystrix/tools.go (50.0%)</option>
				
				<option value="file108">github.com/lazygophers/utils/json/file.go (0.0%)</option>
				
				<option value="file109">github.com/lazygophers/utils/json/must.go (0.0%)</option>
				
				<option value="file110">github.com/lazygophers/utils/json/other.go (0.0%)</option>
				
				<option value="file111">github.com/lazygophers/utils/json/sonic.go (0.0%)</option>
				
				<option value="file112">github.com/lazygophers/utils/must.go (0.0%)</option>
				
				<option value="file113">github.com/lazygophers/utils/network/fiber.go (100.0%)</option>
				
				<option value="file114">github.com/lazygophers/utils/network/interface.go (67.6%)</option>
				
				<option value="file115">github.com/lazygophers/utils/network/ip.go (100.0%)</option>
				
				<option value="file116">github.com/lazygophers/utils/orm.go (0.0%)</option>
				
				<option value="file117">github.com/lazygophers/utils/osx/file.go (97.7%)</option>
				
				<option value="file118">github.com/lazygophers/utils/pyroscope/open.go (0.0%)</option>
				
				<option value="file119">github.com/lazygophers/utils/pyroscope/other.go (0.0%)</option>
				
				<option value="file120">github.com/lazygophers/utils/randx/any.go (7.2%)</option>
				
				<option value="file121">github.com/lazygophers/utils/randx/bool.go (15.8%)</option>
				
				<option value="file122">github.com/lazygophers/utils/randx/number.go (74.6%)</option>
				
				<option value="file123">github.com/lazygophers/utils/randx/time.go (13.8%)</option>
				
				<option value="file124">github.com/lazygophers/utils/routine/routine.go (0.0%)</option>
				
				<option value="file125">github.com/lazygophers/utils/runtime/exit.go (35.7%)</option>
				
				<option value="file126">github.com/lazygophers/utils/runtime/runtime.go (87.2%)</option>
				
				<option value="file127">github.com/lazygophers/utils/runtime/system_darwin.go (100.0%)</option>
				
				<option value="file128">github.com/lazygophers/utils/singledo/group.go (0.0%)</option>
				
				<option value="file129">github.com/lazygophers/utils/singledo/singledo.go (0.0%)</option>
				
				<option value="file130">github.com/lazygophers/utils/stringx/rand.go (100.0%)</option>
				
				<option value="file131">github.com/lazygophers/utils/stringx/string.go (93.7%)</option>
				
				<option value="file132">github.com/lazygophers/utils/stringx/strings.go (100.0%)</option>
				
				<option value="file133">github.com/lazygophers/utils/stringx/unicode.go (100.0%)</option>
				
				<option value="file134">github.com/lazygophers/utils/stringx/utf16.go (100.0%)</option>
				
				<option value="file135">github.com/lazygophers/utils/unit/network.go (0.0%)</option>
				
				<option value="file136">github.com/lazygophers/utils/unit/time.go (0.0%)</option>
				
				<option value="file137">github.com/lazygophers/utils/urlx/query.go (0.0%)</option>
				
				<option value="file138">github.com/lazygophers/utils/validate.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package anyx

import (
        "fmt"
        "maps"
        "reflect"

        "golang.org/x/exp/constraints"
)

type ValueType int

const (
        ValueUnknown ValueType = iota
        ValueNumber
        ValueString
        ValueBool
)

func CheckValueType(val interface{}) ValueType <span class="cov10" title="19">{
        switch val.(type) </span>{
        case bool:<span class="cov3" title="2">
                return ValueBool</span>
        case int, int8, int16, int32, int64,
                uint, uint8, uint16, uint32, uint64,
                float32, float64:<span class="cov8" title="12">
                return ValueNumber</span>
        case string, []byte:<span class="cov3" title="2">
                return ValueString</span>
        default:<span class="cov4" title="3">
                return ValueUnknown</span>
        }
}

func MapKeysString(m interface{}) []string <span class="cov5" title="5">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov5" title="4">if t.IsNil() </span><span class="cov1" title="1">{
                panic("nil map")</span>
        }

        <span class="cov4" title="3">keyType := t.Type().Key()
        if keyType.Kind() != reflect.String </span><span class="cov1" title="1">{
                panic("map key type required string")</span>
        }

        <span class="cov3" title="2">result := make([]string, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.String())
        }</span>

        <span class="cov3" title="2">return result</span>
}

func MapKeysUint32(m interface{}) []uint32 <span class="cov5" title="5">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov5" title="4">if t.IsNil() </span><span class="cov1" title="1">{
                panic("nil map")</span>
        }

        <span class="cov4" title="3">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint32 </span><span class="cov1" title="1">{
                panic("map key type required uint32")</span>
        }

        <span class="cov3" title="2">result := make([]uint32, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, uint32(v.Uint()))
        }</span>

        <span class="cov3" title="2">return result</span>
}

func MapKeysUint64(m interface{}) []uint64 <span class="cov5" title="5">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }

        <span class="cov5" title="4">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint64 </span><span class="cov1" title="1">{
                panic("map key type required uint64")</span>
        }

        <span class="cov4" title="3">result := make([]uint64, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.Uint())
        }</span>

        <span class="cov4" title="3">return result</span>
}

func MapKeysInt32(m interface{}) []int32 <span class="cov5" title="5">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov5" title="4">if t.IsNil() </span><span class="cov1" title="1">{
                return []int32{}
        }</span>

        <span class="cov4" title="3">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int32 </span><span class="cov1" title="1">{
                panic("map key type required int32")</span>
        }

        <span class="cov3" title="2">result := make([]int32, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, int32(v.Int()))
        }</span>

        <span class="cov3" title="2">return result</span>
}

func MapKeysInt64(m interface{}) []int64 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []int64{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int64 </span><span class="cov1" title="1">{
                panic("map key type required int64")</span>
        }

        <span class="cov1" title="1">result := make([]int64, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.Int())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysInt(m interface{}) []int <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []int{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int </span><span class="cov1" title="1">{
                panic("map key type required int")</span>
        }

        <span class="cov1" title="1">result := make([]int, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, int(v.Int()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysInt8(m interface{}) []int8 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []int8{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int8 </span><span class="cov1" title="1">{
                panic("map key type required int8")</span>
        }

        <span class="cov1" title="1">result := make([]int8, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, int8(v.Int()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysInt16(m interface{}) []int16 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []int16{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int16 </span><span class="cov1" title="1">{
                panic("map key type required int16")</span>
        }

        <span class="cov1" title="1">result := make([]int16, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, int16(v.Int()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysUint(m interface{}) []uint <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []uint{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint </span><span class="cov1" title="1">{
                panic("map key type required uint")</span>
        }

        <span class="cov1" title="1">result := make([]uint, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, uint(v.Uint()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysUint8(m interface{}) []uint8 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []uint8{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint8 </span><span class="cov1" title="1">{
                panic("map key type required uint8")</span>
        }

        <span class="cov1" title="1">result := make([]uint8, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, uint8(v.Uint()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysUint16(m interface{}) []uint16 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []uint16{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint16 </span><span class="cov1" title="1">{
                panic("map key type required uint16")</span>
        }

        <span class="cov1" title="1">result := make([]uint16, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, uint16(v.Uint()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysFloat32(m interface{}) []float32 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []float32{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Float32 </span><span class="cov1" title="1">{
                panic("map key type required float32")</span>
        }

        <span class="cov1" title="1">result := make([]float32, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, float32(v.Float()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysFloat64(m interface{}) []float64 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []float64{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Float64 </span><span class="cov1" title="1">{
                panic("map key type required float64")</span>
        }

        <span class="cov1" title="1">result := make([]float64, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.Float())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysInterface(m interface{}) []interface{} <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov1" title="1">result := make([]interface{}, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.Interface())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysAny(m interface{}) []interface{} <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov1" title="1">result := make([]interface{}, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.Interface())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysNumber(m interface{}) []interface{} <span class="cov5" title="5">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov5" title="4">if t.IsNil() </span><span class="cov1" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov4" title="3">keyType := t.Type().Key()
        switch keyType.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
                reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
                reflect.Float32, reflect.Float64:<span class="cov3" title="2"></span>
                // valid number types
        default:<span class="cov1" title="1">
                panic("map key type required number")</span>
        }

        <span class="cov3" title="2">result := make([]interface{}, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov5" title="5">{
                result = append(result, v.Interface())
        }</span>

        <span class="cov3" title="2">return result</span>
}

func MapValues[K constraints.Ordered, V any](m map[K]V) []V <span class="cov4" title="3">{
        res := make([]V, 0, len(m))
        for _, v := range m </span><span class="cov6" title="6">{
                res = append(res, v)
        }</span>
        <span class="cov4" title="3">return res</span>
}

func MapValuesAny(m interface{}) []interface{} <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov1" title="1">result := make([]interface{}, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov4" title="3">{
                result = append(result, iter.Value().Interface())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapValuesString(m interface{}) []string <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []string{}
        }</span>

        <span class="cov1" title="1">result := make([]string, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov3" title="2">{
                result = append(result, iter.Value().String())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapValuesInt(m interface{}) []int <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []int{}
        }</span>

        <span class="cov1" title="1">result := make([]int, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov3" title="2">{
                result = append(result, int(iter.Value().Int()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapValuesFloat64(m interface{}) []float64 <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []float64{}
        }</span>

        <span class="cov1" title="1">result := make([]float64, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov3" title="2">{
                result = append(result, iter.Value().Float())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MergeMap[K constraints.Ordered, V any](source, target map[K]V) map[K]V <span class="cov5" title="4">{
        res := maps.Clone(source)

        if len(target) &gt; 0 </span><span class="cov4" title="3">{
                for k, v := range target </span><span class="cov6" title="6">{
                        res[k] = v
                }</span>
        }

        <span class="cov5" title="4">return res</span>
}

func KeyBy(list interface{}, fieldName string) interface{} <span class="cov8" title="13">{
        if list == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov8" title="12">lv := reflect.ValueOf(list)

        switch lv.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov8" title="11"></span>
        default:<span class="cov1" title="1">
                panic("list required slice or array type")</span>
        }

        <span class="cov8" title="11">ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov6" title="6">{
                evs = evs.Elem()
        }</span>

        <span class="cov8" title="11">if evs.Kind() != reflect.Struct </span><span class="cov3" title="2">{
                panic("list element is not struct")</span>
        }

        <span class="cov7" title="9">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov7" title="8">m := reflect.MakeMapWithSize(reflect.MapOf(field.Type, ev), lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov9" title="18">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov9" title="14">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov9" title="18">if !elemStruct.IsValid() </span><span class="cov4" title="3">{
                        continue</span>
                }

                <span class="cov9" title="15">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov9" title="15">m.SetMapIndex(elemStruct.FieldByIndex(field.Index), elem)</span>
        }

        <span class="cov7" title="8">return m.Interface()</span>
}

func KeyByUint64[M any](list []*M, fieldName string) map[uint64]*M <span class="cov6" title="6">{
        if len(list) == 0 </span><span class="cov1" title="1">{
                return map[uint64]*M{}
        }</span>

        <span class="cov5" title="5">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov5" title="5">{
                evs = evs.Elem()
        }</span>

        <span class="cov5" title="5">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov5" title="4">m := make(map[uint64]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov6" title="6">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov6" title="6">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov6" title="6">if !elemStruct.IsValid() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov5" title="5">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov5" title="5">m[elemStruct.FieldByIndex(field.Index).Uint()] = elem.Interface().(*M)</span>
        }

        <span class="cov5" title="4">return m</span>
}

func KeyByInt64[M any](list []*M, fieldName string) map[int64]*M <span class="cov5" title="5">{
        if len(list) == 0 </span><span class="cov1" title="1">{
                return map[int64]*M{}
        }</span>

        <span class="cov5" title="4">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                evs = evs.Elem()
        }</span>

        <span class="cov5" title="4">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov3" title="2">m := make(map[int64]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov5" title="4">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov5" title="4">if !elemStruct.IsValid() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="3">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov4" title="3">m[elemStruct.FieldByIndex(field.Index).Int()] = elem.Interface().(*M)</span>
        }

        <span class="cov3" title="2">return m</span>
}

func KeyByString[M any](list []*M, fieldName string) map[string]*M <span class="cov5" title="5">{
        if len(list) == 0 </span><span class="cov1" title="1">{
                return map[string]*M{}
        }</span>

        <span class="cov5" title="4">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                evs = evs.Elem()
        }</span>

        <span class="cov5" title="4">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov3" title="2">m := make(map[string]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov5" title="4">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov5" title="4">if !elemStruct.IsValid() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="3">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov4" title="3">m[elemStruct.FieldByIndex(field.Index).String()] = elem.Interface().(*M)</span>
        }

        <span class="cov3" title="2">return m</span>
}

func KeyByInt32[M any](list []*M, fieldName string) map[int32]*M <span class="cov5" title="5">{
        if len(list) == 0 </span><span class="cov1" title="1">{
                return map[int32]*M{}
        }</span>

        <span class="cov5" title="4">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                evs = evs.Elem()
        }</span>

        <span class="cov5" title="4">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov3" title="2">m := make(map[int32]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov5" title="4">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov5" title="4">if !elemStruct.IsValid() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="3">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov4" title="3">m[int32(elemStruct.FieldByIndex(field.Index).Int())] = elem.Interface().(*M)</span>
        }

        <span class="cov3" title="2">return m</span>
}

func Slice2Map[M constraints.Ordered](list []M) map[M]bool <span class="cov5" title="4">{
        m := make(map[M]bool, len(list))

        for _, v := range list </span><span class="cov8" title="11">{
                m[v] = true
        }</span>

        <span class="cov5" title="4">return m</span>
}

</pre>
		
		<pre class="file" id="file1" style="display: none">package anyx

import (
        "errors"
        "fmt"
        "math"
        "strings"
        "sync"

        "github.com/lazygophers/utils/candy"
        "github.com/lazygophers/utils/json"
        "go.uber.org/atomic"
        "gopkg.in/yaml.v3"
)

type MapAny struct {
        data *sync.Map
        cut  *atomic.Bool
        seq  *atomic.String
}

var (
        ErrNotFound = errors.New("not found")
)

func NewMap(m map[string]interface{}) *MapAny <span class="cov5" title="83">{
        m2 := &amp;MapAny{
                data: &amp;sync.Map{},
                cut:  atomic.NewBool(false),
                seq:  atomic.NewString(""),
        }
        for k, v := range m </span><span class="cov5" title="178">{
                m2.data.Store(k, v)
        }</span>
        <span class="cov5" title="83">return m2</span>
}

func NewMapWithJson(s []byte) (*MapAny, error) <span class="cov1" title="3">{
        var m map[string]interface{}
        err := json.Unmarshal(s, &amp;m)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="2">return NewMap(m), nil</span>
}

func NewMapWithYaml(s []byte) (*MapAny, error) <span class="cov1" title="2">{
        var m map[string]interface{}
        err := yaml.Unmarshal(s, &amp;m)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return NewMap(m), nil</span>
}

func NewMapWithAny(s interface{}) (*MapAny, error) <span class="cov2" title="5">{
        buf, err := json.Marshal(s)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov2" title="4">var m map[string]interface{}
        err = yaml.Unmarshal(buf, &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="4">return NewMap(m), nil</span>
}

func (p *MapAny) EnableCut(seq string) *MapAny <span class="cov2" title="8">{
        p.cut.Store(true)
        p.seq.Store(seq)
        return p
}</span>

func (p *MapAny) DisableCut() *MapAny <span class="cov1" title="1">{
        p.cut.Store(false)
        return p
}</span>

func (p *MapAny) Set(key string, value interface{}) <span class="cov9" title="10007">{
        p.data.Store(key, value)
}</span>

func (p *MapAny) Get(key string) (interface{}, error) <span class="cov3" title="17">{
        val, ok := p.get(key)
        if !ok </span><span class="cov3" title="10">{
                return nil, ErrNotFound
        }</span>

        <span class="cov2" title="7">return val, nil</span>
}

func (p *MapAny) get(key string) (interface{}, bool) <span class="cov10" title="20202">{
        var val interface{}
        var ok bool

        if val, ok = p.data.Load(key); ok </span><span class="cov9" title="20152">{
                return val, true
        }</span>
        <span class="cov4" title="50">if !p.cut.Load() </span><span class="cov4" title="41">{
                return nil, false
        }</span>

        <span class="cov2" title="9">seq := p.seq.Load()
        keys := strings.Split(key, seq)

        data := p.data
        var m *MapAny
        for len(keys) &gt; 1 </span><span class="cov3" title="12">{
                k := keys[0]
                keys = keys[1:]

                val, ok = data.Load(k)
                if !ok </span><span class="cov1" title="1">{
                        return nil, false
                }</span>

                <span class="cov3" title="11">m = p.toMap(val)
                if m == nil </span><span class="cov0" title="0">{
                        return nil, false
                }</span>

                <span class="cov3" title="11">data = m.data</span>
        }

        <span class="cov2" title="8">if len(keys) &gt; 0 </span><span class="cov2" title="8">{
                if val, ok = data.Load(keys[0]); ok </span><span class="cov1" title="1">{
                        return val, true
                }</span>
                <span class="cov2" title="7">return nil, false</span>
        }

        <span class="cov0" title="0">return nil, false</span>
}

func (p *MapAny) Exists(key string) bool <span class="cov9" title="10027">{
        _, ok := p.get(key)
        if !ok </span><span class="cov3" title="23">{
                return false
        }</span>

        <span class="cov9" title="10004">return true</span>
}

func (p *MapAny) GetBool(key string) bool <span class="cov2" title="9">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov2" title="8">return candy.ToBool(val)</span>
}

func (p *MapAny) GetInt(key string) int <span class="cov9" title="10010">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov9" title="10009">return candy.ToInt(val)</span>
}

func (p *MapAny) GetInt32(key string) int32 <span class="cov1" title="3">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="2">return candy.ToInt32(val)</span>
}

func (p *MapAny) GetInt64(key string) int64 <span class="cov1" title="3">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="2">return candy.ToInt64(val)</span>
}

func (p *MapAny) GetUint16(key string) uint16 <span class="cov1" title="3">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="2">return candy.ToUint16(val)</span>
}

func (p *MapAny) GetUint32(key string) uint32 <span class="cov1" title="3">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="2">return candy.ToUint32(val)</span>
}

func (p *MapAny) GetUint64(key string) uint64 <span class="cov1" title="3">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="2">return candy.ToUint64(val)</span>
}

func (p *MapAny) GetFloat64(key string) float64 <span class="cov2" title="4">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="3">return candy.ToFloat64(val)</span>
}

func (p *MapAny) GetString(key string) string <span class="cov3" title="20">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov3" title="19">return candy.ToString(val)</span>
}

func (p *MapAny) GetBytes(key string) []byte <span class="cov3" title="18">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return []byte("")
        }</span>

        <span class="cov3" title="17">switch x := val.(type) </span>{
        case bool:<span class="cov1" title="2">
                if x </span><span class="cov1" title="1">{
                        return []byte("1")
                }</span>
                <span class="cov1" title="1">return []byte("0")</span>
        case int:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int8:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int16:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int32:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int64:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint8:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint16:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint32:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint64:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case float32:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%v", x))</span>
        case float64:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%v", x))</span>
        case string:<span class="cov1" title="1">
                return []byte(x)</span>
        case []byte:<span class="cov1" title="1">
                return x</span>
        default:<span class="cov1" title="1">
                return []byte("")</span>
        }
}

func (p *MapAny) GetMap(key string) *MapAny <span class="cov2" title="6">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return NewMap(nil)
        }</span>

        <span class="cov2" title="5">return p.toMap(val)</span>
}

func (p *MapAny) toMap(val interface{}) *MapAny <span class="cov4" title="39">{
        switch x := val.(type) </span>{
        case bool, int, int8, int16, int32, int64,
                uint, uint8, uint16, uint32, uint64,
                float32, float64:<span class="cov3" title="14">
                return NewMap(nil)</span>
        case string:<span class="cov2" title="8">
                var m map[string]interface{}
                err := json.Unmarshal([]byte(x), &amp;m)
                if err != nil </span><span class="cov2" title="6">{
                        return NewMap(nil)
                }</span>
                <span class="cov1" title="2">return NewMap(m)</span>
        case []byte:<span class="cov1" title="2">
                var m map[string]interface{}
                err := json.Unmarshal(x, &amp;m)
                if err != nil </span><span class="cov1" title="1">{
                        return NewMap(nil)
                }</span>
                <span class="cov1" title="1">return NewMap(m)</span>
        case map[string]interface{}:<span class="cov3" title="10">
                return NewMap(x)</span>
        case map[interface{}]interface{}:<span class="cov1" title="1">
                m := NewMap(nil)
                for k, v := range x </span><span class="cov1" title="2">{
                        m.Set(candy.ToString(k), v)
                }</span>
                <span class="cov1" title="1">return m</span>
        default:<span class="cov2" title="4">
                buf, err := json.Marshal(x)
                if err != nil </span><span class="cov1" title="2">{
                        return NewMap(nil)
                }</span>
                <span class="cov1" title="2">var m map[string]interface{}
                err = json.Unmarshal(buf, &amp;m)
                if err != nil </span><span class="cov1" title="1">{
                        return NewMap(nil)
                }</span>
                <span class="cov1" title="1">return NewMap(m)</span>
        }
}

func (p *MapAny) GetSlice(key string) []interface{} <span class="cov3" title="19">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="18">switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint64:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case [][]byte:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="2">
                return x</span>
        default:<span class="cov1" title="1">
                return []interface{}{}</span>
        }
}

func (p *MapAny) GetStringSlice(key string) []string <span class="cov3" title="18">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="17">switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint64:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="1">
                return x</span>
        case [][]byte:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, string(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov1" title="1">
                return []string{}</span>
        }
}

func (p *MapAny) GetUint64Slice(key string) []uint64 <span class="cov3" title="19">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="18">switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint64:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="2">
                var v []uint64
                for _, val := range x </span><span class="cov2" title="4">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="2">return v</span>
        case [][]byte:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov1" title="1">
                return []uint64{}</span>
        }
}

func (p *MapAny) GetInt64Slice(key string) []int64 <span class="cov1" title="2">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov1" title="1">return candy.ToInt64Slice(val)</span>
}

func (p *MapAny) GetUint32Slice(key string) []uint32 <span class="cov3" title="18">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="17">switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                return x</span>
        case []uint64:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case [][]byte:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov1" title="1">
                return []uint32{}</span>
        }
}

func (p *MapAny) ToSyncMap() *sync.Map <span class="cov1" title="2">{
        var m sync.Map
        p.data.Range(func(key, value interface{}) bool </span><span class="cov2" title="5">{
                m.Store(key, value)
                return true
        }</span>)
        <span class="cov1" title="2">return &amp;m</span>
}

func (p *MapAny) ToMap() map[string]interface{} <span class="cov1" title="2">{
        m := map[string]interface{}{}
        p.data.Range(func(key, value interface{}) bool </span><span class="cov3" title="11">{
                k := candy.ToString(key)

                switch x := value.(type) </span>{
                case float32:<span class="cov1" title="2">
                        if math.Floor(float64(x)) == float64(x) </span><span class="cov1" title="1">{
                                m[k] = int32(x)
                        }</span> else<span class="cov1" title="1"> {
                                m[k] = x
                        }</span>
                case float64:<span class="cov1" title="2">
                        if math.Floor(x) == x </span><span class="cov1" title="1">{
                                m[k] = int64(x)
                        }</span> else<span class="cov1" title="1"> {
                                m[k] = x
                        }</span>
                case *MapAny:<span class="cov1" title="1">
                        m[k] = x.ToMap()</span>
                case bool,
                        int, int8, int16, int32, int64,
                        uint, uint8, uint16, uint32, uint64,
                        string, []byte:<span class="cov2" title="5">
                        m[k] = x</span>
                default:<span class="cov1" title="1">
                        m[k] = x</span>
                }

                <span class="cov3" title="11">return true</span>
        })
        <span class="cov1" title="2">return m</span>
}

func (p *MapAny) Clone() *MapAny <span class="cov1" title="1">{
        return &amp;MapAny{
                data: p.ToSyncMap(),
                cut:  atomic.NewBool(p.cut.Load()),
                seq:  atomic.NewString(p.seq.Load()),
        }
}</span>

func (p *MapAny) Range(f func(key, value interface{}) bool) <span class="cov1" title="3">{
        p.data.Range(func(key, value interface{}) bool </span><span class="cov9" title="10006">{
                return f(key, value)
        }</span>)
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

var Organization = "lazygophers"

var Name string

var Version string

type ReleaseType uint8

const (
        Debug ReleaseType = iota
        Test
        Alpha
        Beta
        Release
)

func (p ReleaseType) String() string <span class="cov0" title="0">{
        switch p </span>{
        case Release:<span class="cov0" title="0">
                return "release"</span>
        case Beta:<span class="cov0" title="0">
                return "beta"</span>
        case Alpha:<span class="cov0" title="0">
                return "alpha"</span>
        case Test:<span class="cov0" title="0">
                return "test"</span>
        case Debug:<span class="cov0" title="0">
                fallthrough</span>
        default:<span class="cov0" title="0">
                return "debug"</span>
        }
}

func (p ReleaseType) ʔ() string <span class="cov0" title="0">{
        return p.String()
}</span>

var PackageType ReleaseType
</pre>
		
		<pre class="file" id="file3" style="display: none">//go:build darwin

package atexit

import (
        "os"
        "os/signal"
        "sync"
        "syscall"
)

var (
        callbacks   []func()
        callbacksMu sync.RWMutex
        signalOnce  sync.Once
)

// 初始化信号处理 - macOS特定优化
func initSignalHandler() <span class="cov9" title="253">{
        signalOnce.Do(func() </span><span class="cov3" title="4">{
                c := make(chan os.Signal, 1)
                // macOS 支持更多的 Unix 信号
                signal.Notify(c, 
                        syscall.SIGINT, 
                        syscall.SIGTERM, 
                        syscall.SIGHUP,  // 终端断开
                        syscall.SIGQUIT, // 退出信号
                )
                
                go func() </span><span class="cov3" title="4">{
                        &lt;-c
                        executeCallbacks()
                        os.Exit(0)
                }</span>()
        })
}

// 执行所有注册的回调函数
func executeCallbacks() <span class="cov2" title="3">{
        callbacksMu.RLock()
        cbList := make([]func(), len(callbacks))
        copy(cbList, callbacks)
        callbacksMu.RUnlock()
        
        // 按注册顺序执行回调
        for _, cb := range cbList </span><span class="cov4" title="8">{
                if cb != nil </span><span class="cov4" title="7">{
                        func() </span><span class="cov4" title="7">{
                                defer func() </span><span class="cov4" title="7">{
                                        // 捕获回调函数中的panic，避免影响其他回调的执行
                                        if r := recover(); r != nil </span>{<span class="cov1" title="1">
                                                // macOS 可以使用系统日志
                                        }</span>
                                }()
                                <span class="cov4" title="7">cb()</span>
                        }()
                }
        }
}

// Register 注册退出时的回调函数
func Register(callback func()) <span class="cov10" title="254">{
        if callback == nil </span><span class="cov1" title="1">{
                return
        }</span>
        
        // 首次注册时初始化信号处理
        <span class="cov9" title="253">initSignalHandler()
        
        callbacksMu.Lock()
        callbacks = append(callbacks, callback)
        callbacksMu.Unlock()</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package bufiox

import "bytes"

// ScanBy 创建并返回一个自定义的扫描函数，用于按指定字节序列分割数据
// 参数 seq: 需要搜索的字节分隔符（如 []byte("\n") 表示换行符分割）
// 返回值: 返回的扫描函数接收字节数据和EOF标志，返回三个参数：
//
//        advance: 指示应前进的字节数
//        token: 当前分割出的有效数据标记
//        err: 错误信息（若返回nil表示继续处理）
//
// 函数特性：
//  1. 当atEOF为true且无数据时立即返回nil
//  2. 支持非EOF状态下的分块处理
//  3. 返回的分割函数遵循bufio.Scanner接口规范
//
// ScanBy 返回一个扫描函数，该函数根据指定的字节序列分割输入
// 参数 seq 是分隔符字节序列
// 返回的函数符合 bufio.SplitFunc 接口规范
func ScanBy(seq []byte) func(data []byte, atEOF bool) (advance int, token []byte, err error) <span class="cov4" title="3">{
        return func(data []byte, atEOF bool) (advance int, token []byte, err error) </span><span class="cov7" title="9">{
                if atEOF &amp;&amp; len(data) == 0 </span><span class="cov1" title="1">{
                        return 0, nil, nil
                }</span>

                <span class="cov7" title="8">if i := bytes.Index(data, seq); i &gt;= 0 </span><span class="cov6" title="6">{
                        // We have a full newline-terminated line.
                        return i + len(seq), data[0:i], nil
                }</span>

                <span class="cov3" title="2">if atEOF </span><span class="cov1" title="1">{
                        return len(data), data, nil
                }</span>

                <span class="cov1" title="1">return 0, nil, err</span>
        }
}

// ScanLines 实现基于bufio.Scanner的行扫描器，处理跨平台换行符分割
// 参数 data: 当前处理的字节切片
// 参数 atEOF: 是否为数据流结束标志
// 返回值: 三元组(advance, token, err)
// 函数特性：
//  1. 自动处理CRLF（Windows）和LF（Unix）换行符
//  2. 在EOF时强制分割剩余数据
//  3. 通过dropCR函数去除Windows换行符中的CR
//  4. 遵循标准bufio.Scanner接口规范
//
// ScanLines 实现按行分割的扫描函数
// 处理换行符(\n)分割逻辑，特别处理Windows换行符(\r\n)场景
// 参数:
//   - data: 当前处理的字节数据
//   - atEOF: 是否已到达数据末尾
//
// 返回:
//   - advance: 消耗的字节数
//   - token: 当前分割得到的行数据（已处理CRLF）
//   - err: 错误信息
func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error) <span class="cov10" title="19">{
        if atEOF &amp;&amp; len(data) == 0 </span><span class="cov4" title="3">{
                return 0, nil, nil
        }</span>
        <span class="cov9" title="16">if i := bytes.IndexByte(data, '\n'); i &gt;= 0 </span><span class="cov7" title="9">{
                // We have a full newline-terminated line.
                return i + 1, dropCR(data[0:i]), nil
        }</span>
        // If we're at EOF, we have a final, non-terminated line. Return it.
        <span class="cov6" title="7">if atEOF </span><span class="cov4" title="3">{
                return len(data), dropCR(data), nil
        }</span>
        // Request more data.
        <span class="cov5" title="4">return 0, nil, nil</span>
}

// dropCR 是行处理辅助函数，用于规范换行符格式
// 功能：移除字节序列最后一个字符的CR（\r）
// 使用场景：当处理Windows风格换行符CRLF（\r\n）时
// 返回值: 返回处理后的字节切片（若存在CR则去除，否则原样返回）
// dropCR 用于移除字节切片末尾的回车符(\r)
// 主要处理Windows换行符场景，将CRLF转换为LF
// 参数 data: 需要处理的字节切片
// 返回: 移除末尾\r后的字节切片
func dropCR(data []byte) []byte <span class="cov10" title="19">{
        if len(data) &gt; 0 &amp;&amp; data[len(data)-1] == '\r' </span><span class="cov6" title="7">{
                return data[0 : len(data)-1]
        }</span>
        <span class="cov8" title="12">return data</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package candy 提供绝对值计算功能
//
// 该包包含 Abs 函数，支持整数和浮点数类型的绝对值计算
package candy

import (
        "golang.org/x/exp/constraints"
)

// Abs 计算数值的绝对值
//
// 泛型函数，支持所有整数和浮点数类型
// 对于负数返回其相反数，对于正数和零返回其本身
//
// 类型参数:
//   - T: 约束为 Integer 或 Float 的数值类型
//
// 参数:
//   - s: 输入的数值
//
// 返回值:
//   - T: 输入数值的绝对值
//
// 示例:
//
//        result := Abs(-42)     // 返回 42
//        result := Abs(3.14)   // 返回 3.14
//        result := Abs(0)      // 返回 0
func Abs[T constraints.Integer | constraints.Float](s T) T <span class="cov10" title="26">{
        if s &lt; 0 </span><span class="cov6" title="8">{
                return -s
        }</span>

        <span class="cov8" title="18">return s</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

// All 检查切片中的所有元素是否都满足指定的条件函数
//
// 参数:
//   - ss: 输入切片，可以是任意类型的切片
//   - f: 条件函数，对每个元素进行判断
//
// 返回值:
//   - bool: 如果所有元素都满足条件则返回 true，否则返回 false
//
// 特点:
//   - 空切片或 nil 切片返回 true
//   - 遇到第一个不满足条件的元素时立即返回，提高效率
//   - 支持任意类型的切片，通过泛型实现类型安全
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        result := All(numbers, func(n int) bool {
//            return n &gt; 0
//        }) // 返回 true
//
//        result := All(numbers, func(n int) bool {
//            return n &gt; 5
//        }) // 返回 false
func All[T any](ss []T, f func(T) bool) bool <span class="cov8" title="16">{
        // 空切片或 nil 切片被认为是满足条件的
        if len(ss) == 0 </span><span class="cov2" title="2">{
                return true
        }</span>

        // 遍历切片，对每个元素应用条件函数
        <span class="cov8" title="14">for _, s := range ss </span><span class="cov10" title="29">{
                if !f(s) </span><span class="cov6" title="7">{
                        // 发现不满足条件的元素，立即返回 false
                        return false
                }</span>
        }

        // 所有元素都满足条件，返回 true
        <span class="cov6" title="7">return true</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

// Any 检查切片中是否存在至少一个元素满足指定条件
//
// 参数:
//   - ss: 输入切片，可以是任意类型的切片
//   - f: 判断函数，对每个元素执行判断
//
// 返回值:
//   - bool: 如果存在任一元素满足条件则返回 true，否则返回 false
//
// 特点:
//   - 空切片或 nil 切片返回 false
//   - 遇到第一个满足条件的元素时立即返回，提高效率
//   - 支持任意类型的切片，通过泛型实现类型安全
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        result := Any(numbers, func(n int) bool {
//            return n &gt; 3
//        }) // 返回 true
//
//        result := Any(numbers, func(n int) bool {
//            return n &gt; 10
//        }) // 返回 false
func Any[T any](ss []T, f func(T) bool) bool <span class="cov8" title="11">{
        for _, s := range ss </span><span class="cov10" title="20">{
                if f(s) </span><span class="cov6" title="6">{
                        return true
                }</span>
        }

        <span class="cov5" title="5">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package candy 提供计算平均值的函数
package candy

import "golang.org/x/exp/constraints"

// Average 计算数值切片的平均值
// 支持整数和浮点数类型，使用 float64 计算以保持精度
// 如果切片为空，返回类型的零值
func Average[T constraints.Integer | constraints.Float](ss []T) (ret T) <span class="cov8" title="13">{
        if len(ss) == 0 </span><span class="cov4" title="4">{
                return
        }</span>

        // 使用 float64 计算以保持精度
        <span class="cov7" title="9">var sum float64
        for _, s := range ss </span><span class="cov10" title="25">{
                sum += float64(s)
        }</span>
        <span class="cov7" title="9">return T(sum / float64(len(ss)))</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package candy 提供通用的语法糖工具函数
package candy

// Bottom 返回切片的最后 n 个元素
// 如果 n 大于切片长度，则返回整个切片
// 使用泛型支持任意类型的切片
func Bottom[T any](ss []T, n int) (ret []T) <span class="cov10" title="8">{
        if n &lt;= 0 </span><span class="cov4" title="2">{
                return []T{}
        }</span>
        <span class="cov8" title="6">if n &gt; len(ss) </span><span class="cov4" title="2">{
                n = len(ss)
        }</span>

        <span class="cov8" title="6">ret = make([]T, n)
        copy(ret, ss[len(ss)-n:])
        return ret</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import (
        "math"

        "golang.org/x/exp/constraints"
)

// Cbrt 计算数值的立方根
//
// 参数:
//   - s: 输入数值，支持整数和浮点数
//
// 返回值:
//   - T: 输入数值的立方根
//
// 特点:
//   - 支持整数和浮点数类型
//   - 通过泛型实现类型安全
//   - 对于负数也返回正确结果
//
// 示例:
//
//        result := Cbrt(8.0)      // 返回 2.0
//        result := Cbrt(27)       // 返回 3
//        result := Cbrt(-8.0)     // 返回 -2.0
func Cbrt[T constraints.Integer | constraints.Float](s T) T <span class="cov10" title="14">{
        return T(math.Cbrt(float64(s)))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package candy

// Chunk 将切片分割成指定大小的子切片
//
// 参数:
//   - ss: 要分割的切片
//   - size: 每个子切片的大小
//
// 返回:
//   - [][]T: 分割后的子切片集合
//
// 注意:
//   - 如果输入切片为空或 size &lt;= 0，返回空切片
//   - 最后一个子切片可能小于指定大小
func Chunk[T any](ss []T, size int) (ret [][]T) <span class="cov8" title="9">{
        if len(ss) == 0 || size &lt;= 0 </span><span class="cov4" title="3">{
                return [][]T{}
        }</span>

        <span class="cov7" title="6">for i := 0; i &lt; len(ss); i += size </span><span class="cov10" title="13">{
                end := i + size
                if end &gt; len(ss) </span><span class="cov4" title="3">{
                        end = len(ss)
                }</span>

                <span class="cov10" title="13">ret = append(ret, ss[i:end])</span>
        }

        <span class="cov7" title="6">return</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package candy 提供了常用的工具函数和语法糖，简化日常 Go 开发中的常见操作
package candy

import (
        "golang.org/x/exp/constraints"
)

// Contains 检查切片中是否包含指定元素
//
// 泛型约束：T 必须实现 constraints.Ordered 接口（支持比较操作）
// 参数：
//   - ss: 要搜索的切片
//   - s: 要查找的元素
//
// 返回值：
//   - bool: 如果找到元素返回 true，否则返回 false
//
// 示例：
//
//        numbers := []int{1, 2, 3, 4, 5}
//        found := Contains(numbers, 3) // 返回 true
//        found = Contains(numbers, 6)  // 返回 false
func Contains[T constraints.Ordered](ss []T, s T) bool <span class="cov8" title="25">{
        return ContainsUsing(ss, func(v T) bool </span><span class="cov10" title="58">{
                return s == v
        }</span>)
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package candy 提供了常用的工具函数和语法糖，简化日常 Go 开发中的常见操作
package candy

// ContainsUsing 使用自定义函数检查切片中是否包含满足条件的元素
//
// 泛型约束：T 可以是任意类型
// 参数：
//   - ss: 要搜索的切片
//   - f: 判断函数，如果函数返回 true，则表示找到匹配的元素
//
// 返回值：
//   - bool: 如果找到满足条件的元素返回 true，否则返回 false
//
// 示例：
//
//        numbers := []int{1, 2, 3, 4, 5}
//        found := ContainsUsing(numbers, func(v int) bool {
//            return v &gt; 3
//        }) // 返回 true
func ContainsUsing[T any](ss []T, f func(v T) bool) bool <span class="cov8" title="25">{
        // 遍历切片中的每个元素
        for _, v := range ss </span><span class="cov10" title="58">{
                // 使用自定义函数判断当前元素是否满足条件
                if f(v) </span><span class="cov7" title="17">{
                        return true
                }</span>
        }

        // 遍历完所有元素都没有找到满足条件的，返回 false
        <span class="cov5" title="8">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package candy

import (
        "reflect"

        "github.com/lazygophers/log"
)

// deepCopyValue 是 DeepCopy 的内部实现核心。
// 它接收两个 reflect.Value (v1 为源, v2 为目标)，并递归地将内容从 v1 拷贝到 v2。
//
// 注意：此函数为 unexported，不应在包外直接调用。
func deepCopyValue(v1, v2 reflect.Value) <span class="cov10" title="69">{
        if !v1.IsValid() || !v2.IsValid() </span><span class="cov3" title="4">{
                return
        }</span>

        // 解引用指针，直到获取到实际的值
        <span class="cov9" title="65">for v1.Kind() == reflect.Ptr </span><span class="cov3" title="4">{
                // 如果源指针是 nil，则无需继续
                if v1.IsNil() </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov3" title="3">v1 = v1.Elem()</span>
        }
        <span class="cov9" title="64">for v2.Kind() == reflect.Ptr </span><span class="cov3" title="4">{
                // 如果目标指针是 nil，则为其分配新内存
                if v2.IsNil() </span><span class="cov3" title="3">{
                        v2.Set(reflect.New(v2.Type().Elem()))
                }</span>
                <span class="cov3" title="4">v2 = v2.Elem()</span>
        }

        // 确保解引用后值仍然有效
        <span class="cov9" title="64">if v1.Kind() == reflect.Invalid || v2.Kind() == reflect.Invalid </span><span class="cov0" title="0">{
                return
        }</span>

        // 类型必须匹配才能拷贝
        <span class="cov9" title="64">if v1.Type() != v2.Type() </span><span class="cov1" title="1">{
                log.Panicf("源类型 %s 与目标类型 %s 不匹配", v1.Type(), v2.Type())
        }</span>

        <span class="cov9" title="63">switch v1.Kind() </span>{
        // 拷贝 Map
        case reflect.Map:<span class="cov3" title="4">
                if v1.IsNil() </span><span class="cov1" title="1">{
                        v2.Set(reflect.Zero(v2.Type()))
                        return
                }</span>
                // 为目标 Map 创建实例
                <span class="cov3" title="3">v2.Set(reflect.MakeMap(v1.Type()))
                // 遍历 Map 并递归拷贝每一个键值对
                for _, k := range v1.MapKeys() </span><span class="cov4" title="5">{
                        val1 := v1.MapIndex(k)
                        val2 := reflect.New(val1.Type()).Elem()
                        deepCopyValue(val1, val2)
                        v2.SetMapIndex(k, val2)
                }</span>

        // 拷贝 Slice
        case reflect.Slice:<span class="cov4" title="6">
                if v1.IsNil() </span><span class="cov1" title="1">{
                        v2.Set(reflect.Zero(v2.Type()))
                        return
                }</span>
                // 为目标 Slice 创建实例
                <span class="cov4" title="5">v2.Set(reflect.MakeSlice(v1.Type(), v1.Len(), v1.Cap()))
                // 遍历 Slice 并递归拷贝每一个元素
                for i := 0; i &lt; v1.Len(); i++ </span><span class="cov6" title="12">{
                        deepCopyValue(v1.Index(i), v2.Index(i))
                }</span>

        // 拷贝 Array
        case reflect.Array:<span class="cov1" title="1">
                // 遍历 Array 并递归拷贝每一个元素
                for i := 0; i &lt; v1.Len(); i++ </span><span class="cov3" title="3">{
                        deepCopyValue(v1.Index(i), v2.Index(i))
                }</span>

        // 拷贝 Struct
        case reflect.Struct:<span class="cov3" title="3">
                // 遍历 Struct 并递归拷贝每一个字段
                for i := 0; i &lt; v1.NumField(); i++ </span><span class="cov3" title="4">{
                        deepCopyValue(v1.Field(i), v2.Field(i))
                }</span>

        // 拷贝 Interface
        case reflect.Interface:<span class="cov4" title="5">
                if v1.IsNil() </span><span class="cov2" title="2">{
                        return
                }</span>
                // 获取接口的实际值
                <span class="cov3" title="3">srcElem := v1.Elem()
                // 创建一个新的目标值，类型与源相同
                dstElem := reflect.New(srcElem.Type()).Elem()
                // 递归拷贝
                deepCopyValue(srcElem, dstElem)
                // 将拷贝后的值设置给目标接口
                v2.Set(dstElem)</span>

        // 拷贝基本类型
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="29">
                if v2.CanSet() </span><span class="cov7" title="24">{
                        v2.SetInt(v1.Int())
                }</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov4" title="5">
                if v2.CanSet() </span><span class="cov0" title="0">{
                        v2.SetUint(v1.Uint())
                }</span>
        case reflect.Float32, reflect.Float64:<span class="cov2" title="2">
                if v2.CanSet() </span><span class="cov0" title="0">{
                        v2.SetFloat(v1.Float())
                }</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov2" title="2">
                if v2.CanSet() </span><span class="cov0" title="0">{
                        v2.SetComplex(v1.Complex())
                }</span>
        case reflect.String:<span class="cov3" title="3">
                if v2.CanSet() </span><span class="cov2" title="2">{
                        v2.SetString(v1.String())
                }</span>
        case reflect.Bool:<span class="cov2" title="2">
                if v2.CanSet() </span><span class="cov1" title="1">{
                        v2.SetBool(v1.Bool())
                }</span>

        case reflect.Invalid:<span class="cov0" title="0"></span>
                // 无效类型，不处理

        default:<span class="cov1" title="1">
                // 对于未处理的类型，直接 panic
                log.Panicf("未处理的类型: %s", v1.Kind())</span>
        }
}

// DeepCopy 通过深度递归的方式，将源对象 `src` 的内容完全复制到目标对象 `dst`。
//
// 此函数会创建一个源对象的完整、独立的副本。修改副本不会对原始对象产生任何影响。
// 它能够处理 Maps、Slices、Pointers、Structs 等各种复杂类型。
//
// **重要提示**:
// 参数 `dst` **必须**是一个指向目标对象的指针，且该指针必须已经被初始化（例如，通过 `new` 或 `&amp;`）。
// 如果 `dst` 是一个 nil 指针或者不是指针类型，函数将在运行时引发 `panic`，因为无法向无效的内存地址写入数据。
//
// 示例：
//
//        var src = map[string]int{"a": 1}
//        var dst map[string]int
//        DeepCopy(src, &amp;dst) // 正确用法
//
// @param src 源对象，待拷贝的数据。
// @param dst 目标对象的指针，用于接收拷贝后的数据。
func DeepCopy[M any](src, dst M) <span class="cov7" title="20">{
        v1 := reflect.ValueOf(src)
        v2 := reflect.ValueOf(dst)
        deepCopyValue(v1, v2)
}</pre>
		
		<pre class="file" id="file15" style="display: none">package candy

import "reflect"

// deepValueEqual 是 DeepEqual 的内部实现核心。
// 它接收两个 reflect.Value，并递归地对它们进行深度比较。
//
// 注意：此函数为 unexported，不应在包外直接调用。
func deepValueEqual(v1, v2 reflect.Value) bool <span class="cov10" title="11181">{
        // 检查值是否有效
        if !v1.IsValid() || !v2.IsValid() </span><span class="cov2" title="6">{
                return v1.IsValid() == v2.IsValid()
        }</span>

        // 比较类型是否一致
        <span class="cov9" title="11175">if v1.Type() != v2.Type() </span><span class="cov2" title="3">{
                return false
        }</span>

        // 根据值的类型进行分类比较
        <span class="cov9" title="11172">switch v1.Kind() </span>{
        // 比较 Map
        case reflect.Map:<span class="cov4" title="32">
                // 检查是否为 nil
                if v1.IsNil() || v2.IsNil() </span><span class="cov1" title="2">{
                        return v1.IsNil() == v2.IsNil()
                }</span>
                // 比较长度
                <span class="cov4" title="30">if v1.Len() != v2.Len() </span><span class="cov2" title="5">{
                        return false
                }</span>
                // 如果指针相同，则内容必然相同
                <span class="cov4" title="25">if v1.UnsafePointer() == v2.UnsafePointer() </span><span class="cov1" title="1">{
                        return true
                }</span>
                // 递归比较每一个键值对
                <span class="cov4" title="24">for _, k := range v1.MapKeys() </span><span class="cov7" title="1030">{
                        val1 := v1.MapIndex(k)
                        val2 := v2.MapIndex(k)
                        if !val1.IsValid() || !val2.IsValid() || !deepValueEqual(val1, val2) </span><span class="cov3" title="10">{
                                return false
                        }</span>
                }
                <span class="cov3" title="14">return true</span>

        // 比较 Slice
        case reflect.Slice:<span class="cov3" title="21">
                // 检查 nil 状态是否一致
                if v1.IsNil() != v2.IsNil() </span><span class="cov1" title="1">{
                        return false
                }</span>
                // 比较长度
                <span class="cov3" title="20">if v1.Len() != v2.Len() </span><span class="cov1" title="1">{
                        return false
                }</span>
                // 如果指针相同，则内容必然相同
                <span class="cov3" title="19">if v1.UnsafePointer() == v2.UnsafePointer() </span><span class="cov2" title="3">{
                        return true
                }</span>
                // 递归比较每一个元素
                <span class="cov3" title="16">for i := 0; i &lt; v1.Len(); i++ </span><span class="cov9" title="10029">{
                        if !deepValueEqual(v1.Index(i), v2.Index(i)) </span><span class="cov2" title="6">{
                                return false
                        }</span>
                }
                <span class="cov3" title="10">return true</span>

        // 比较指针
        case reflect.Ptr:<span class="cov2" title="7">
                // 检查是否为 nil
                if v1.IsNil() || v2.IsNil() </span><span class="cov1" title="2">{
                        return v1.IsNil() == v2.IsNil()
                }</span>
                // 递归比较指针指向的元素
                <span class="cov2" title="5">return deepValueEqual(v1.Elem(), v2.Elem())</span>

        // 比较数组
        case reflect.Array:<span class="cov3" title="8">
                // 递归比较每一个元素
                // 注意：不能对数组类型的 reflect.Value 使用 UnsafePointer
                for i := 0; i &lt; v1.Len(); i++ </span><span class="cov3" title="18">{
                        if !deepValueEqual(v1.Index(i), v2.Index(i)) </span><span class="cov2" title="3">{
                                return false
                        }</span>
                }
                <span class="cov2" title="5">return true</span>

        // 比较结构体
        case reflect.Struct:<span class="cov3" title="9">
                // 递归比较每一个字段
                for i := 0; i &lt; v1.NumField(); i++ </span><span class="cov3" title="10">{
                        if !deepValueEqual(v1.Field(i), v2.Field(i)) </span><span class="cov2" title="4">{
                                return false
                        }</span>
                }
                <span class="cov2" title="5">return true</span>

        // 比较接口
        case reflect.Interface:<span class="cov3" title="14">
                // 检查是否为 nil
                if v1.IsNil() || v2.IsNil() </span><span class="cov0" title="0">{
                        return v1.IsNil() == v2.IsNil()
                }</span>
                // 递归比较接口包含的元素
                <span class="cov3" title="14">return deepValueEqual(v1.Elem(), v2.Elem())</span>

        // 对于其他基本类型，直接比较接口值
        default:<span class="cov9" title="11081">
                // 对于不可比较的类型（如函数、映射、切片），需要捕获panic
                var result bool
                var panicked bool
                
                func() </span><span class="cov9" title="11081">{
                        defer func() </span><span class="cov9" title="11081">{
                                if recover() != nil </span><span class="cov2" title="7">{
                                        panicked = true
                                }</span>
                        }()
                        
                        // 尝试直接比较，如果类型不可比较会触发panic被上面捕获
                        <span class="cov9" title="11081">result = v1.Interface() == v2.Interface()</span>
                }()
                
                // 如果发生了panic，说明类型不可比较，返回false
                <span class="cov9" title="11081">if panicked </span><span class="cov2" title="7">{
                        return false
                }</span>
                
                <span class="cov9" title="11074">return result</span>
        }
}

// DeepEqual 使用深度递归比较的方式，判断两个任意类型的值 x 和 y 是否完全相等。
//
// 与标准的 `==` 运算符不同，`DeepEqual` 能够深入探索数据结构的内部，
// 对 Maps、Slices、Pointers、Structs 等复合类型的元素或字段进行逐一递归比较。
//
// 对于基本类型，它会直接比较其值。对于指针，它会比较所指向的实际内容。
// 两个 nil 值被视作相等。
//
// 示例：
//   - `DeepEqual(map[string]int{"a": 1}, map[string]int{"a": 1})` 返回 `true`
//   - `DeepEqual([]int{1, 2}, []int{1, 2})` 返回 `true`
//   - `DeepEqual(1, 1)` 返回 `true`
//   - `DeepEqual(1, 2)` 返回 `false`
//
// @param x 第一个待比较的值。
// @param y 第二个待比较的值。
// @return 如果两个值在结构和内容上完全相等，则返回 true，否则返回 false。
func DeepEqual[M any](x, y M) bool <span class="cov5" title="78">{
        v1 := reflect.ValueOf(x)
        v2 := reflect.ValueOf(y)
        return deepValueEqual(v1, v2)
}</pre>
		
		<pre class="file" id="file16" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Package candy 提供常用的工具函数和语法糖
// 本文件包含数组/切片差异比较相关的函数

// Diff 计算两个有序切片之间的差异
//
// 参数:
//   - ss: 第一个切片
//   - against: 第二个切片
//
// 返回值:
//   - added: 在 against 中存在但不在 ss 中的元素
//   - removed: 在 ss 中存在但不在 against 中的元素
//
// 示例:
//
//        ss := []int{1, 2, 3}
//        against := []int{2, 3, 4}
//        added, removed := Diff(ss, against)
//        // added = [4]
//        // removed = [1]
func Diff[T constraints.Ordered](ss []T, against []T) (added, removed []T) <span class="cov10" title="8">{
        removed = Remove(ss, against)
        added = Remove(against, ss)

        return
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package candy

import (
        "reflect"
)

// DiffSlice 比较两个切片的差异
// 返回第一个切片中存在但第二个切片中不存在的元素，以及第二个切片中存在但第一个切片中不存在的元素
func DiffSlice(a interface{}, b interface{}) (interface{}, interface{}) <span class="cov4" title="17">{
        at := reflect.TypeOf(a)
        if at.Kind() != reflect.Slice </span><span class="cov1" title="1">{
                panic("a is not slice")</span>
        }

        <span class="cov4" title="16">bt := reflect.TypeOf(b)
        if bt.Kind() != reflect.Slice </span><span class="cov1" title="1">{
                panic("b is not slice")</span>
        }

        <span class="cov4" title="15">atm := at.Elem()
        btm := bt.Elem()

        if atm.Kind() != btm.Kind() </span><span class="cov1" title="1">{
                panic("a and b are not same type")</span>
        }

        <span class="cov4" title="14">m := map[interface{}]reflect.Value{}

        bv := reflect.ValueOf(b)
        for i := 0; i &lt; bv.Len(); i++ </span><span class="cov9" title="1027">{
                m[bv.Index(i).Interface()] = bv.Index(i)
        }</span>

        <span class="cov4" title="14">c := reflect.MakeSlice(at, 0, 0)
        d := reflect.MakeSlice(bt, 0, 0)
        av := reflect.ValueOf(a)
        for i := 0; i &lt; av.Len(); i++ </span><span class="cov10" title="1028">{
                if !m[av.Index(i).Interface()].IsValid() </span><span class="cov9" title="517">{
                        c = reflect.Append(c, av.Index(i))
                }</span> else<span class="cov9" title="511"> {
                        delete(m, av.Index(i).Interface())
                }</span>
        }

        <span class="cov4" title="14">for _, value := range m </span><span class="cov9" title="514">{
                d = reflect.Append(d, value)
        }</span>

        <span class="cov4" title="14">return c.Interface(), d.Interface()</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

// Drop 丢弃切片前 n 个元素
//
// 参数:
//   - ss: 输入切片，支持任意类型
//   - n: 要丢弃的元素个数
//
// 返回值:
//   - []T: 丢弃前 n 个元素后的新切片
//
// 特点:
//   - 支持任意类型的切片
//   - 如果 n 为负数，当作 0 处理
//   - 如果 n 大于切片长度，返回空切片
//   - 不修改原切片，返回新切片
//
// 示例:
//
//        result := Drop([]int{1, 2, 3, 4, 5}, 2)      // 返回 [3, 4, 5]
//        result := Drop([]string{"a", "b", "c"}, 0)  // 返回 ["a", "b", "c"]
//        result := Drop([]int{1, 2, 3}, 5)      // 返回 []
//        result := Drop([]int{1, 2, 3}, -1)     // 返回 [1, 2, 3]
func Drop[T any](ss []T, n int) []T <span class="cov10" title="12">{
        if n &lt; 0 </span><span class="cov1" title="1">{
                n = 0
        }</span>

        <span class="cov10" title="12">if n &gt; len(ss) </span><span class="cov4" title="3">{
                n = len(ss)
        }</span>

        <span class="cov10" title="12">return ss[n:]</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package candy 包含实用的语法糖工具函数
package candy

import (
        "reflect"
)

// Each 遍历切片、数组或映射的每个元素，并对每个元素执行指定的函数
//
// 参数:
//   - collection: 要遍历的集合，支持切片、数组、映射
//   - fn: 对每个元素执行的函数，接收元素的索引和值
//
// 示例:
//
//        // 遍历切片
//        Each([]int{1, 2, 3}, func(index int, value int) {
//            fmt.Printf("索引 %d: 值 %d\n", index, value)
//        })
//
//        // 遍历映射
//        Each(map[string]int{"a": 1, "b": 2}, func(index int, value int) {
//            fmt.Printf("索引 %d: 值 %d\n", index, value)
//        })
//
// 注意:
//   - 如果 collection 不是切片、数组或映射，函数会 panic
//   - 对于映射，index 参数是连续的整数，从 0 开始
//   - 函数使用反射机制，性能上不如直接的 for 循环
func Each(collection interface{}, fn func(index int, value interface{})) <span class="cov8" title="18">{
        val := reflect.ValueOf(collection)

        switch val.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov7" title="13">
                for i := 0; i &lt; val.Len(); i++ </span><span class="cov10" title="34">{
                        fn(i, val.Index(i).Interface())
                }</span>
        case reflect.Map:<span class="cov2" title="2">
                keys := val.MapKeys()
                for i, key := range keys </span><span class="cov3" title="3">{
                        fn(i, val.MapIndex(key).Interface())
                }</span>
        default:<span class="cov3" title="3">
                panic("Each: collection must be a slice, array, or map")</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package candy

// EachReverse 反向遍历切片并对每个元素执行指定函数
// 从切片的最后一个元素开始，向前遍历到第一个元素
// 对于每个元素，都会调用传入的函数 f 进行处理
//
// 参数:
//   - ss: 要遍历的切片
//   - f: 对每个元素执行的函数，接收一个类型为 T 的参数
//
// 泛型参数:
//   - T: 切片中元素的类型，可以是任意类型
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        EachReverse(numbers, func(n int) {
//            fmt.Println(n) // 输出: 5, 4, 3, 2, 1
//        })
func EachReverse[T any](ss []T, f func(T)) <span class="cov3" title="17">{
        for i := len(ss) - 1; i &gt;= 0; i-- </span><span class="cov10" title="10048">{
                f(ss[i])
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package candy 提供了实用的工具函数和语法糖
package candy

// EachStopWithError 遍历切片并对每个元素执行指定函数，如果函数返回错误则立即停止遍历并返回该错误
//
// 参数：
//   - ss: 要遍历的切片
//   - f: 对每个元素执行的函数，如果返回错误则停止遍历
//
// 返回值：
//   - error: 如果遍历过程中出现错误则返回该错误，否则返回 nil
//
// 示例：
//
//        numbers := []int{1, 2, 3, 4, 5}
//        err := EachStopWithError(numbers, func(n int) error {
//            if n == 3 {
//                return fmt.Errorf("数字 3 不被允许")
//            }
//            fmt.Println(n)
//            return nil
//        })
func EachStopWithError[T any](ss []T, f func(T) (err error)) (err error) <span class="cov7" title="12">{
        for _, s := range ss </span><span class="cov10" title="25">{
                err = f(s)
                if err != nil </span><span class="cov6" title="7">{
                        return err
                }</span>
        }
        <span class="cov5" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package candy 提供了 Go 语言中常用的语法糖函数和工具方法
package candy

// Filter 函数用于过滤切片中的元素，返回满足条件的所有元素
//
// 参数：
//   - ss: 要过滤的切片，可以是任意类型的切片
//   - f: 过滤函数，接收一个元素并返回布尔值，true 表示保留该元素
//
// 返回值：
//   - []T: 包含所有满足条件的元素的新切片
//
// 示例：
//
//        numbers := []int{1, 2, 3, 4, 5}
//        evenNumbers := Filter(numbers, func(n int) bool {
//            return n%2 == 0
//        })
//        // evenNumbers = [2, 4]
//
// 注意事项：
//   - 使用 make 初始化返回切片，确保返回空切片而非 nil
//   - 该函数不会修改原始切片
//   - 时间复杂度为 O(n)，其中 n 为切片长度
func Filter[T any](ss []T, f func(T) bool) []T <span class="cov3" title="30">{
        if len(ss) == 0 </span><span class="cov2" title="4">{
                return []T{}
        }</span>
        
        // 使用原始长度的1/4作为初始容量预估，减少重新分配
        <span class="cov3" title="26">ret := make([]T, 0, len(ss)/4+1)
        for _, s := range ss </span><span class="cov10" title="60086">{
                if f(s) </span><span class="cov9" title="30044">{
                        ret = append(ret, s)
                }</span>
        }

        <span class="cov3" title="26">return ret</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

// FilterNot 对切片进行反向过滤，保留不满足指定条件的元素
//
// 参数:
//   - ss: 输入切片，支持任意类型
//   - f: 谓词函数，接收一个元素并返回布尔值
//
// 返回值:
//   - []T: 包含所有不满足谓词函数条件的新切片
//
// 特点:
//   - 支持任意类型的切片
//   - 是 Filter 函数的补集，用于语义上更清晰的反向过滤操作
//   - 不修改原切片，返回新切片
//   - 空切片输入返回空切片
//
// 示例:
//
//        // 过滤偶数，保留奇数
//        numbers := []int{1, 2, 3, 4, 5, 6}
//        result := FilterNot(numbers, func(n int) bool {
//            return n % 2 == 0
//        })
//        // result = [1, 3, 5]
//
//        // 过滤空字符串，保留非空字符串
//        strings := []string{"hello", "", "world", ""}
//        result := FilterNot(strings, func(s string) bool {
//            return s == ""
//        })
//        // result = ["hello", "world"]
//
//        // 过滤负数，保留非负数
//        nums := []int{-1, 0, 1, -2, 2}
//        result := FilterNot(nums, func(n int) bool {
//            return n &lt; 0
//        })
//        // result = [0, 1, 2]
func FilterNot[T any](ss []T, f func(T) bool) []T <span class="cov6" title="6">{
        // 使用 make 初始化，确保返回空切片而非 nil
        us := make([]T, 0)
        for _, s := range ss </span><span class="cov10" title="23">{
                if !f(s) </span><span class="cov8" title="12">{
                        us = append(us, s)
                }</span>
        }
        <span class="cov6" title="6">return us</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package candy 包含常用的语法糖函数，提供简洁的编程接口
package candy

// First 返回切片中的第一个元素
// 如果切片为空，返回类型的零值
//
// 泛型参数 T 可以是任意类型
//
// 示例：
//
//        nums := []int{1, 2, 3}
//        first := First(nums) // 返回 1
//
//        empty := []string{}
//        first := First(empty) // 返回 "" (string 的零值)
func First[T any](ss []T) (ret T) <span class="cov10" title="7">{
        if len(ss) == 0 </span><span class="cov6" title="3">{
                return
        }</span>

        <span class="cov7" title="4">return ss[0]</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package candy 包含语法糖工具函数，提供便捷的编程辅助功能
package candy

// FirstOr 返回切片的第一个元素，如果切片为空则返回指定的默认值
//
// 该函数使用泛型支持任意类型的切片，提供了安全的空切片处理机制。
// 在访问切片第一个元素之前，会先检查切片长度，避免 panic。
//
// 参数:
//   - ss: 任意类型的切片
//   - or: 当切片为空时返回的默认值
//
// 返回:
//   - 切片的第一个元素，如果切片为空则返回默认值
//
// 示例:
//
//        numbers := []int{1, 2, 3}
//        first := FirstOr(numbers, 0)     // 返回 1
//
//        empty := []int{}
//        defaultVal := FirstOr(empty, 0) // 返回 0
func FirstOr[T any](ss []T, or T) (ret T) <span class="cov10" title="8">{
        if len(ss) == 0 </span><span class="cov7" title="4">{
                return or
        }</span>

        <span class="cov7" title="4">return ss[0]</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Index 返回元素 sub 在切片 ss 中的索引位置
// 如果未找到，返回 -1
// 这是一个泛型函数，支持所有可排序的类型
func Index[T constraints.Ordered](ss []T, sub T) int <span class="cov7" title="11">{
        if len(ss) == 0 </span><span class="cov1" title="1">{
                return -1
        }</span>

        <span class="cov7" title="10">for i, s := range ss </span><span class="cov10" title="25">{
                if s == sub </span><span class="cov6" title="7">{
                        return i
                }</span>
        }

        <span class="cov4" title="3">return -1</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package candy

import (
        "strings"

        "golang.org/x/exp/constraints"
)

// Join 将有序类型的切片按指定分隔符连接成字符串
// 该函数提供了通用的切片连接功能，支持所有实现了 constraints.Ordered 接口的类型
// 包括整数、浮点数和字符串等基本类型
//
// 参数:
//   - ss: 输入切片，类型为 []T，其中 T 必须实现 constraints.Ordered 接口
//   - glue: 可选参数，指定连接分隔符，默认为 ","
//
// 返回:
//   - string: 连接后的字符串
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        result := Join(numbers, "-")
//        // result 为 "1-2-3-4-5"
//
//        words := []string{"Hello", "World", "Go"}
//        result := Join(words, " ")
//        // result 为 "Hello World Go"
func Join[T constraints.Ordered](ss []T, glue ...string) string <span class="cov8" title="12">{
        // 设置默认分隔符
        seq := ","
        if len(glue) &gt; 0 </span><span class="cov7" title="9">{
                seq = glue[0]
        }</span>

        // 使用 Map 函数将切片元素转换为字符串，然后用 strings.Join 连接
        <span class="cov8" title="12">return strings.Join(Map(ss, func(s T) string </span><span class="cov10" title="20">{
                return String(s)
        }</span>), seq)
}</pre>
		
		<pre class="file" id="file28" style="display: none">// Package candy 包含实用的语法糖函数，提供简洁高效的编程工具
package candy

// Last 返回切片中的最后一个元素
// 如果切片为空，返回类型的零值
// 该函数使用泛型实现，支持任意类型的切片
//
// 参数:
//   - ss: 任意类型的切片
//
// 返回:
//   - T: 切片中的最后一个元素，如果切片为空则返回类型零值
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        last := Last(numbers) // 返回 5
//
//        empty := []string{}
//        result := Last(empty) // 返回 ""
func Last[T any](ss []T) (ret T) <span class="cov10" title="7">{
        if len(ss) == 0 </span><span class="cov6" title="3">{
                return
        }</span>

        <span class="cov7" title="4">return ss[len(ss)-1]</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package candy 包含实用的语法糖函数，提供简洁高效的编程工具
package candy

// LastOr 返回切片中的最后一个元素
// 如果切片为空，返回指定的默认值
// 该函数使用泛型实现，支持任意类型的切片
//
// 参数:
//   - ss: 任意类型的切片
//   - or: 当切片为空时返回的默认值
//
// 返回:
//   - T: 切片中的最后一个元素，如果切片为空则返回指定的默认值
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        last := LastOr(numbers, 0) // 返回 5
//
//        empty := []string{}
//        result := LastOr(empty, "default") // 返回 "default"
func LastOr[T any](ss []T, or T) (ret T) <span class="cov10" title="8">{
        if len(ss) == 0 </span><span class="cov7" title="4">{
                return or
        }</span>

        <span class="cov7" title="4">return ss[len(ss)-1]</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package candy

// Map 对切片中的每个元素应用指定的函数，返回新的切片
// 该函数使用泛型支持任意类型的输入和输出
//
// 参数:
//   - ss: 输入切片，类型为 []T
//   - f: 映射函数，接收类型 T 的参数，返回类型 U 的结果
//
// 返回:
//   - []U: 应用映射函数后的新切片
//
// 示例:
//
//        numbers := []int{1, 2, 3, 4, 5}
//        doubled := Map(numbers, func(n int) int {
//            return n * 2
//        })
//        // doubled 为 []int{2, 4, 6, 8, 10}
func Map[T, U any](ss []T, f func(T) U) []U <span class="cov8" title="12">{
        if len(ss) == 0 </span><span class="cov5" title="4">{
                return []U{}
        }</span>
        
        // 直接分配最终长度的切片，避免 append 操作
        <span class="cov7" title="8">ret := make([]U, len(ss))
        for i, s := range ss </span><span class="cov10" title="20">{
                ret[i] = f(s)
        }</span>

        <span class="cov7" title="8">return ret</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import "golang.org/x/exp/constraints"

// Max 返回切片中的最大值
//
// 参数:
//   - ss: 输入切片，支持所有可排序类型
//
// 返回值:
//   - T: 切片中的最大值，如果切片为空则返回类型零值
//
// 特点:
//   - 支持整数、浮点数、字符串等所有可排序类型
//   - 空切片输入返回类型零值
//   - 时间复杂度 O(n)，单次遍历
//   - 不修改原切片
//
// 示例:
//
//        // 查找整数切片的最大值
//        numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}
//        result := Max(numbers)
//        // result = 9
//
//        // 查找字符串切片的最大值（按字典序）
//        strings := []string{"apple", "banana", "cherry", "date"}
//        result := Max(strings)
//        // result = "date"
//
//        // 查找浮点数切片的最大值
//        floats := []float64{3.14, 1.618, 2.718, 1.414}
//        result := Max(floats)
//        // result = 3.14
//
//        // 空切片处理
//        empty := []int{}
//        result := Max(empty)
//        // result = 0 (int类型的零值)
func Max[T constraints.Ordered](ss []T) (max T) <span class="cov8" title="28">{
        if len(ss) == 0 </span><span class="cov4" title="6">{
                return
        }</span>
        <span class="cov7" title="22">max = ss[0]
        for _, s := range ss </span><span class="cov10" title="58">{
                if s &gt; max </span><span class="cov6" title="14">{
                        max = s
                }</span>
        }
        <span class="cov7" title="22">return</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import "golang.org/x/exp/constraints"

// Min 返回切片中的最小值
//
// 参数:
//   - ss: 输入切片，支持所有可排序类型
//
// 返回值:
//   - T: 切片中的最小值，如果切片为空则返回类型零值
//
// 特点:
//   - 支持整数、浮点数、字符串等所有可排序类型
//   - 空切片输入返回类型零值
//   - 时间复杂度 O(n)，单次遍历
//   - 不修改原切片
//
// 示例:
//
//        // 查找整数切片的最小值
//        numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}
//        result := Min(numbers)
//        // result = 1
//
//        // 查找字符串切片的最小值（按字典序）
//        strings := []string{"apple", "banana", "cherry", "date"}
//        result := Min(strings)
//        // result = "apple"
//
//        // 查找浮点数切片的最小值
//        floats := []float64{3.14, 1.618, 2.718, 1.414}
//        result := Min(floats)
//        // result = 1.414
//
//        // 空切片处理
//        empty := []int{}
//        result := Min(empty)
//        // result = 0 (int类型的零值)
func Min[T constraints.Ordered](ss []T) (min T) <span class="cov8" title="57">{
        if len(ss) == 0 </span><span class="cov4" title="6">{
                return
        }</span>
        <span class="cov7" title="51">min = ss[0]
        for _, s := range ss </span><span class="cov10" title="174">{
                if s &lt; min </span><span class="cov6" title="18">{
                        min = s
                }</span>
        }
        <span class="cov7" title="51">return</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package candy

import (
        "fmt"
        "reflect"
)

func pluck(list interface{}, fieldName string, deferVal interface{}) interface{} <span class="cov10" title="39">{
        v := reflect.ValueOf(list)
        switch v.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov9" title="33">
                if v.Len() == 0 </span><span class="cov6" title="10">{
                        return deferVal
                }</span>

                <span class="cov8" title="23">ev := v.Type().Elem()
                evs := ev
                for evs.Kind() == reflect.Ptr </span><span class="cov7" title="13">{
                        evs = evs.Elem()
                }</span>

                <span class="cov8" title="23">switch evs.Kind() </span>{
                case reflect.Struct:<span class="cov7" title="17">
                        field, ok := evs.FieldByName(fieldName)
                        if !ok </span><span class="cov4" title="4">{
                                panic(fmt.Sprintf("field %s not found", fieldName))</span>
                        }

                        <span class="cov7" title="13">result := reflect.MakeSlice(reflect.SliceOf(field.Type), v.Len(), v.Len())

                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov9" title="26">{
                                ev := v.Index(i)
                                for ev.Kind() == reflect.Ptr </span><span class="cov7" title="16">{
                                        ev = ev.Elem()
                                }</span>
                                <span class="cov9" title="26">if ev.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                                        panic("element is not a struct")</span>
                                }
                                <span class="cov8" title="25">if !ev.IsValid() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="25">result.Index(i).Set(ev.FieldByIndex(field.Index))</span>
                        }

                        <span class="cov7" title="12">return result.Interface()</span>
                case reflect.Slice, reflect.Array:<span class="cov2" title="2">
                        var ev reflect.Value
                        var c int
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov3" title="3">{
                                ev = v.Index(i)
                                for i := 0; i &lt; ev.Len(); i++ </span><span class="cov4" title="4">{
                                        c += ev.Index(i).Len()
                                }</span>
                        }

                        <span class="cov2" title="2">result := reflect.MakeSlice(ev.Type(), c, c)
                        var idx int
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov3" title="3">{
                                ev := v.Index(i)
                                for i := 0; i &lt; ev.Len(); i++ </span><span class="cov4" title="4">{
                                        result.Index(idx).Set(ev.Index(i))
                                        idx++
                                }</span>
                        }

                        <span class="cov2" title="2">return result.Interface()</span>
                default:<span class="cov4" title="4">
                        panic("list element type is not supported")</span>
                }

        default:<span class="cov5" title="6">
                panic("list must be an array or slice")</span>
        }
}

// PluckInt 从结构体切片中提取指定字段的 int 值
func PluckInt(list interface{}, fieldName string) []int <span class="cov6" title="11">{
        return pluck(list, fieldName, []int{}).([]int)
}</pre>
		
		<pre class="file" id="file34" style="display: none">package candy

// PluckInt32 从结构体切片中提取指定字段的 int32 值
func PluckInt32(list interface{}, fieldName string) []int32 <span class="cov10" title="6">{
        return pluck(list, fieldName, []int32{}).([]int32)
}</pre>
		
		<pre class="file" id="file35" style="display: none">package candy

// PluckInt64 从结构体切片中提取指定字段的 int64 值
func PluckInt64(list interface{}, fieldName string) []int64 <span class="cov10" title="4">{
        return pluck(list, fieldName, []int64{}).([]int64)
}</pre>
		
		<pre class="file" id="file36" style="display: none">package candy

// PluckString 从结构体切片中提取指定字段的 string 值
func PluckString(list interface{}, fieldName string) []string <span class="cov10" title="3">{
        return pluck(list, fieldName, []string{}).([]string)
}</pre>
		
		<pre class="file" id="file37" style="display: none">package candy

// PluckStringSlice 从结构体切片中提取指定字段的 []string 值
func PluckStringSlice(list interface{}, fieldName string) [][]string <span class="cov10" title="3">{
        return pluck(list, fieldName, [][]string{}).([][]string)
}</pre>
		
		<pre class="file" id="file38" style="display: none">package candy

// PluckUint32 从结构体切片中提取指定字段的 uint32 值
func PluckUint32(list interface{}, fileName string) []uint32 <span class="cov10" title="4">{
        return pluck(list, fileName, []uint32{}).([]uint32)
}</pre>
		
		<pre class="file" id="file39" style="display: none">package candy

// PluckUint64 从结构体切片中提取指定字段的 uint64 值
func PluckUint64(list interface{}, fieldName string) []uint64 <span class="cov10" title="4">{
        return pluck(list, fieldName, []uint64{}).([]uint64)
}</pre>
		
		<pre class="file" id="file40" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import (
        "math"

        "golang.org/x/exp/constraints"
)

// Pow 返回 x 的 y 次幂
//
// 参数:
//   - x: 底数，支持整数和浮点数类型
//   - y: 指数，支持整数和浮点数类型
//
// 返回值:
//   - T: x 的 y 次幂结果，保持原类型
//
// 特点:
//   - 支持整数和浮点数类型的幂运算
//   - 底层使用 math.Pow 进行高精度计算
//   - 自动处理类型转换，保持类型一致性
//   - 支持负指数和分数指数
//
// 示例:
//
//        // 整数幂运算
//        result := Pow(2, 3)
//        // result = 8
//
//        // 浮点数幂运算
//        result := Pow(2.5, 2.0)
//        // result = 6.25
//
//        // 负指数运算
//        result := Pow(2.0, -2.0)
//        // result = 0.25
//
//        // 分数指数运算
//        result := Pow(4.0, 0.5)
//        // result = 2.0 (平方根)
//
//        // 大数幂运算
//        result := Pow(10, 6)
//        // result = 1000000
func Pow[T constraints.Integer | constraints.Float](x, y T) T <span class="cov10" title="16">{
        return T(math.Pow(float64(x), float64(y)))
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import (
        "math/rand"
)

// Random 从切片中随机返回一个元素
//
// 类型参数：
//   - T: 任意类型
//
// 参数：
//   - ss: 输入切片
//
// 返回值：
//   - ret: 随机选择的元素，如果切片为空则返回类型的零值
//
// 特点：
//   - 支持任意类型的切片
//   - 空切片安全，返回类型零值
//   - 使用 math/rand 包生成随机数
//
// 示例：
//
//        numbers := []int{1, 2, 3, 4, 5}
//        randomNum := Random(numbers)
//        // randomNum 可能是 1, 2, 3, 4, 5 中的任意一个值
//
//        strings := []string{"apple", "banana", "cherry"}
//        randomStr := Random(strings)
//        // randomStr 可能是 "apple", "banana", "cherry" 中的任意一个
func Random[T any](ss []T) (ret T) <span class="cov10" title="2061">{
        if len(ss) == 0 </span><span class="cov2" title="5">{
                return
        }</span>

        <span class="cov9" title="2056">return ss[rand.Intn(len(ss))]</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

// Reduce 对切片进行归约操作，使用指定的二元函数将切片元素合并为单个值
//
// 类型参数：
//   - T: 任意类型
//
// 参数：
//   - ss: 输入切片，可以是任意类型
//   - f: 归约函数，接受两个同类型参数，返回同类型结果
//
// 返回值：
//   - 归约后的单个值，对于空切片返回类型的零值
//
// 特点：
//   - 支持任意类型的切片归约操作
//   - 空切片安全，返回类型零值
//   - 使用泛型确保类型安全
//
// 示例：
//
//        // 计算切片元素的和
//        sum := Reduce([]int{1, 2, 3, 4, 5}, func(a, b int) int { return a + b })
//        // sum 的值为 15
//
//        // 计算切片元素的乘积
//        product := Reduce([]int{1, 2, 3, 4}, func(a, b int) int { return a * b })
//        // product 的值为 24
//
//        // 找出切片中的最大值
//        max := Reduce([]int{3, 1, 4, 1, 5}, func(a, b int) int {
//            if b &gt; a { return b }
//            return a
//        })
//        // max 的值为 5
func Reduce[T any](ss []T, f func(T, T) T) T <span class="cov3" title="15">{
        if len(ss) == 0 </span><span class="cov1" title="2">{
                return *new(T)
        }</span>

        <span class="cov3" title="13">result := ss[0]
        for _, s := range ss[1:] </span><span class="cov10" title="10040">{
                result = f(result, s)
        }</span>
        <span class="cov3" title="12">return result</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Remove 移除 ss 存在也 against 存在的部分
// 返回在 against 中但不在 ss 中的元素
func Remove[T constraints.Ordered](ss []T, against []T) (result []T) <span class="cov8" title="24">{
        // 使用 make 初始化，确保返回空切片而非 nil
        result = make([]T, 0)
        set := make(map[T]struct{}, len(ss))

        for _, s := range ss </span><span class="cov9" title="55">{
                set[s] = struct{}{}
        }</span>

        <span class="cov8" title="24">for _, s := range against </span><span class="cov10" title="57">{
                if _, ok := set[s]; !ok </span><span class="cov8" title="29">{
                        result = append(result, s)
                }</span>
        }
        <span class="cov8" title="24">return</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package candy

// RemoveIndex 移除指定索引的元素
// 该函数从切片中移除指定索引位置的元素，并返回新的切片
// 如果索引无效（超出范围或为负数），则返回空切片
func RemoveIndex[T any](ss []T, index int) []T <span class="cov10" title="12">{
        // 边界检查：如果切片为空或索引无效，返回空切片
        if len(ss) == 0 || index &lt; 0 || index &gt;= len(ss) </span><span class="cov6" title="5">{
                return make([]T, 0)
        }</span>

        // 处理移除第一个元素的特殊情况
        <span class="cov8" title="7">if index == 0 </span><span class="cov4" title="3">{
                return ss[1:]
        }</span>

        // 处理移除最后一个元素的特殊情况
        <span class="cov6" title="4">if index == len(ss)-1 </span><span class="cov3" title="2">{
                return ss[:len(ss)-1]
        }</span>

        // 一般情况：使用 append 将索引前后的元素拼接起来
        <span class="cov3" title="2">return append(ss[:index], ss[index+1:]...)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package candy

import (
        "reflect"
)

// RemoveSlice 从源切片中移除指定的元素
// src 是源切片，rm 是要移除的元素切片
// 返回移除指定元素后的新切片
func RemoveSlice(src interface{}, rm interface{}) interface{} <span class="cov5" title="13">{
        at := reflect.TypeOf(src)
        if at.Kind() != reflect.Slice </span><span class="cov1" title="1">{
                panic("a is not slice")</span>
        }

        <span class="cov5" title="12">bt := reflect.TypeOf(rm)
        if bt.Kind() != reflect.Slice </span><span class="cov1" title="1">{
                panic("b is not slice")</span>
        }

        <span class="cov5" title="11">atm := at.Elem()
        btm := bt.Elem()

        if atm.Kind() != btm.Kind() </span><span class="cov1" title="1">{
                panic("a and b are not same type")</span>
        }

        <span class="cov5" title="10">m := map[interface{}]bool{}

        bv := reflect.ValueOf(rm)
        for i := 0; i &lt; bv.Len(); i++ </span><span class="cov6" title="22">{
                m[bv.Index(i).Interface()] = true
        }</span>

        <span class="cov5" title="10">c := reflect.MakeSlice(at, 0, 0)
        av := reflect.ValueOf(src)
        for i := 0; i &lt; av.Len(); i++ </span><span class="cov10" title="133">{
                if !m[av.Index(i).Interface()] </span><span class="cov9" title="116">{
                        c = reflect.Append(c, av.Index(i))
                        delete(m, av.Index(i).Interface())
                }</span>
        }

        <span class="cov5" title="10">return c.Interface()</span>
}</pre>
		
		<pre class="file" id="file46" style="display: none">// Package reverse 提供了反转切片的工具函数
package candy

// Reverse 返回一个反转后的切片，原切片保持不变
// 该函数使用泛型支持任意类型的切片，返回一个新的反转后的切片
// 使用 make 预分配容量以确保性能最优
func Reverse[T any](ss []T) (ret []T) <span class="cov7" title="8">{
        // 使用 make 初始化，确保返回空切片而非 nil
        ret = make([]T, 0, len(ss))
        for i := len(ss) - 1; i &gt;= 0; i-- </span><span class="cov10" title="22">{
                ret = append(ret, ss[i])
        }</span>

        <span class="cov7" title="8">return</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Same 返回在 against 和 ss 中都存在的元素
// 用于查找两个有序集合的交集
func Same[T constraints.Ordered](against []T, ss []T) (result []T) <span class="cov7" title="11">{
        // 使用 make 初始化，确保返回空切片而非 nil
        result = make([]T, 0)
        set := make(map[T]struct{}, len(ss))

        for _, s := range ss </span><span class="cov10" title="25">{
                set[s] = struct{}{}
        }</span>

        <span class="cov7" title="11">for _, s := range against </span><span class="cov10" title="25">{
                if _, ok := set[s]; ok </span><span class="cov8" title="13">{
                        result = append(result, s)
                }</span>
        }
        <span class="cov7" title="11">return</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import "github.com/lazygophers/utils/randx"

// Shuffle 随机打乱切片中的元素顺序
//
// 类型参数：
//   - T: 任意类型
//
// 参数：
//   - ss: 待打乱的切片，可以是任意类型
//
// 返回值：
//   - []T: 打乱后的切片（原地修改，返回原切片的引用）
//
// 特点：
//   - 使用 Fisher-Yates 洗牌算法，确保均匀随机分布
//   - 原地修改，不创建新切片，内存效率高
//   - 支持任意类型的切片
//   - 对于空切片或单元素切片，直接返回原切片
//   - 高性能优化：使用 randx 包的高性能随机数生成器
//
// 示例：
//
//        // 打乱整数切片
//        data := []int{1, 2, 3, 4, 5}
//        result := Shuffle(data)
//        // result 是打乱后的切片，与 data 是同一个切片
//
//        // 打乱字符串切片
//        names := []string{"Alice", "Bob", "Charlie", "David"}
//        shuffled := Shuffle(names)
//        // shuffled 包含随机顺序的名字
func Shuffle[T any](ss []T) []T <span class="cov5" title="32">{
        if len(ss) &lt;= 1 </span><span class="cov3" title="9">{
                return ss
        }</span>
        
        <span class="cov5" title="23">for i := len(ss) - 1; i &gt; 0; i-- </span><span class="cov10" title="1133">{
                j := randx.FastIntn(i + 1)
                ss[i], ss[j] = ss[j], ss[i]
        }</span>

        <span class="cov5" title="23">return ss</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package candy

// SliceEqual 判断两个切片是否相等，不考虑元素顺序
// 使用 map 来统计元素出现次数，确保每个元素在两个切片中出现次数相同
// 处理了 nil 切片的特殊情况：nil 和空切片视为相等
func SliceEqual[T any](a, b []T) bool <span class="cov5" title="59">{
        // 处理 nil 切片的情况：nil 和空切片视为相等
        if a == nil &amp;&amp; b == nil </span><span class="cov1" title="2">{
                return true
        }</span>
        <span class="cov5" title="57">if a == nil || b == nil </span><span class="cov2" title="5">{
                return false
        }</span>

        <span class="cov5" title="52">if len(a) != len(b) </span><span class="cov3" title="9">{
                return false
        }</span>

        // 使用 map 来跟踪每个元素的出现次数
        <span class="cov5" title="43">am := make(map[any]int, len(a))
        for _, v := range a </span><span class="cov10" title="2133">{
                am[v]++
        }</span>

        <span class="cov5" title="43">for _, v := range b </span><span class="cov9" title="2125">{
                if count, ok := am[v]; !ok || count == 0 </span><span class="cov4" title="15">{
                        return false
                }</span>
                <span class="cov9" title="2110">am[v]--</span>
        }

        // 检查所有元素的计数是否都为0
        <span class="cov4" title="28">for _, count := range am </span><span class="cov9" title="1064">{
                if count != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov4" title="28">return true</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package candy

import (
        "sort"

        "golang.org/x/exp/constraints"
)

// Sort 对有序类型的切片进行排序
// 接受一个实现了 constraints.Ordered 接口的切片，返回一个新的已排序切片
// 原始切片不会被修改，返回的是排序后的副本
func Sort[T constraints.Ordered](ss []T) []T <span class="cov4" title="21">{
        // 如果切片长度小于2，直接返回副本
        if len(ss) &lt; 2 </span><span class="cov2" title="3">{
                return ss
        }</span>

        // 创建新的切片用于排序
        <span class="cov4" title="18">sorted := make([]T, len(ss))
        copy(sorted, ss)

        // 使用 sort.Slice 进行排序
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov10" title="1139">{
                return sorted[i] &lt; sorted[j]
        }</span>)

        <span class="cov4" title="18">return sorted</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Package candy 提供了常用的工具函数和语法糖，简化日常 Go 开发中的常见操作
package candy

import (
        "sort"
)

// SortUsing 使用自定义比较函数对切片进行排序
//
// 泛型约束：T 可以是任意类型
// 参数：
//   - slice: 要排序的切片
//   - less: 比较函数，如果函数返回 true，则表示 a 应该排在 b 前面
//
// 返回值：
//   - []T: 排序后的切片副本（原始切片不会被修改）
//
// 示例：
//
//        // 降序排序
//        numbers := []int{1, 2, 3, 4, 5}
//        sorted := SortUsing(numbers, func(a, b int) bool {
//            return a &gt; b
//        }) // 返回 []int{5, 4, 3, 2, 1}
//
//        // 按字符串长度排序
//        words := []string{"apple", "banana", "cherry", "date"}
//        sorted := SortUsing(words, func(a, b string) bool {
//            return len(a) &lt; len(b)
//        }) // 返回 []string{"date", "apple", "banana", "cherry"}
func SortUsing[T any](slice []T, less func(T, T) bool) []T <span class="cov6" title="22">{
        // 如果切片长度小于2，直接返回副本
        if len(slice) &lt; 2 </span><span class="cov2" title="3">{
                return slice
        }</span>

        // 创建新的切片用于排序
        <span class="cov6" title="19">sorted := make([]T, len(slice))
        copy(sorted, slice)

        // 使用 sort.Slice 进行排序
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov10" title="169">{
                return less(sorted[i], sorted[j])
        }</span>)

        <span class="cov6" title="19">return sorted</span>
}</pre>
		
		<pre class="file" id="file52" style="display: none">package candy

import "golang.org/x/exp/constraints"

// Spare 返回在 against 中但不在 ss 中的元素
// 该函数实现了集合差集操作，返回在 against 切片中存在但在 ss 切片中不存在的所有元素
// 注意：该函数与 Remove 函数功能相同，都是返回差集结果
//
// 参数：
//   - ss: 作为参考集合的切片
//   - against: 作为被比较集合的切片
//
// 返回：
//   - []T: 在 against 中但不在 ss 中的元素组成的切片
//
// 示例：
//
//        ss := []int{1, 2, 3}
//        against := []int{2, 3, 4, 5}
//        result := Spare(ss, against) // 返回 [4, 5]
func Spare[T constraints.Ordered](ss []T, against []T) (result []T) <span class="cov7" title="11">{
        // 使用 make 初始化，确保返回空切片而非 nil
        result = make([]T, 0)
        set := make(map[T]struct{}, len(ss))

        // 将 ss 中的所有元素添加到 map 中用于快速查找
        for _, s := range ss </span><span class="cov9" title="25">{
                set[s] = struct{}{}
        }</span>

        // 遍历 against 切片，找出不在 ss 中的元素
        <span class="cov7" title="11">for _, s := range against </span><span class="cov10" title="27">{
                if _, ok := set[s]; !ok </span><span class="cov8" title="16">{
                        result = append(result, s)
                }</span>
        }
        <span class="cov7" title="11">return</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import (
        "math"

        "golang.org/x/exp/constraints"
)

// Sqrt 计算数值的平方根
//
// 类型参数：
//   - T: 数值类型，支持所有整数和浮点数类型
//
// 参数：
//   - s: 要计算平方根的数值
//
// 返回值：
//   - T: 输入数值的平方根
//
// 特点：
//   - 支持整数和浮点数类型，通过泛型约束确保类型安全
//   - 内部使用 math.Sqrt 进行计算，然后将结果转换回原始类型
//   - 对于负数输入，math.Sqrt 会返回 NaN
//
// 示例：
//
//        // 计算浮点数的平方根
//        result := Sqrt(16.0)
//        // result 的值为 4.0
//
//        // 计算整数的平方根
//        result := Sqrt(int(16))
//        // result 的值为 4
//
//        // 计算浮点数的平方根
//        result := Sqrt(25.5)
//        // result 约等于 5.04975246918104
func Sqrt[T constraints.Integer | constraints.Float](s T) T <span class="cov10" title="14">{
        return T(math.Sqrt(float64(s)))
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package candy

import (
        "fmt"

        "golang.org/x/exp/constraints"
)

// String 将任意有序类型转换为字符串
// 该函数提供了通用的类型转字符串功能，支持所有实现了 constraints.Ordered 接口的类型
// 包括整数、浮点数和字符串等基本类型
func String[T constraints.Ordered](s T) string <span class="cov10" title="25">{
        return fmt.Sprintf("%v", s)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">// Package candy 包含语法糖工具函数
package candy

import "golang.org/x/exp/constraints"

// Sum 计算数值切片中所有元素的总和
// 支持整数和浮点数类型，使用泛型实现类型安全
//
// 参数：
//   - ss: 数值切片，支持整数和浮点数类型
//
// 返回值：
//   - T: 切片中所有元素的总和
//
// 示例：
//
//        sum := Sum([]int{1, 2, 3})  // 返回 6
//        sum := Sum([]float64{1.5, 2.5})  // 返回 4.0
func Sum[T constraints.Integer | constraints.Float](ss []T) (ret T) <span class="cov7" title="12">{
        for _, s := range ss </span><span class="cov10" title="34">{
                ret += s
        }</span>

        <span class="cov7" title="12">return</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package candy

import (
        "reflect"
        "strings"
)

// ToArrayString 将任意类型转换为字符串数组
// 对于切片类型，将每个元素转换为字符串
// 对于字符串类型，如果包含逗号则按逗号分割，否则返回单个元素的切片
// 对于其他类型，转换为字符串后返回单个元素的切片
func ToArrayString(v interface{}) []string <span class="cov10" title="29">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Slice </span><span class="cov8" title="15">{
                // 处理非切片类型
                switch x := v.(type) </span>{
                case string:<span class="cov6" title="9">
                        if strings.Contains(x, ",") </span><span class="cov4" title="4">{
                                // 如果包含逗号，按逗号分割
                                return strings.Split(x, ",")
                        }</span>
                        // 否则返回单个元素的切片
                        <span class="cov5" title="5">return []string{x}</span>
                case nil:<span class="cov1" title="1">
                        return nil</span>
                default:<span class="cov5" title="5">
                        // 其他非切片类型，转换为字符串后返回单个元素的切片
                        return []string{ToString(x)}</span>
                }
        }

        // 处理 nil 切片
        <span class="cov8" title="14">if vv.IsNil() </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="13">ss := make([]string, 0, vv.Len())
        for i := 0; i &lt; vv.Len(); i++ </span><span class="cov9" title="25">{
                ss = append(ss, ToString(vv.Index(i).Interface()))
        }</span>

        <span class="cov7" title="13">return ss</span>
}</pre>
		
		<pre class="file" id="file57" style="display: none">package candy

import (
        "bytes"
        "math"
        "strings"
)

// ToBool 尝试将任意类型 (interface{}) 的输入值转换为布尔值 (bool)。
//
// 转换规则如下:
//
//   - **bool**:
//     直接返回原始值。
//
//   - **整型** (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64):
//     如果值为 0，则返回 false，否则返回 true。
//
//   - **浮点型** (float32, float64):
//     如果值为 0.0 或 NaN (Not-a-Number)，则返回 false，否则返回 true。
//
//   - **字符串 (string) 和字节切片 ([]byte)**:
//     首先会转换为小写并移除首尾空白字符。
//
//   - "true", "1", "t", "y", "yes", "on" 被视为 true。
//
//   - "false", "0", "f", "n", "no", "off" 被视为 false。
//
//   - 对于其他非空字符串，返回 true。
//
//   - 对于空字符串或仅包含空白字符的字符串，返回 false。
//
//   - **nil**:
//     返回 false。
//
//   - **其他所有类型**:
//     均返回 false (例如: struct, map, slice 等)。
//
// 示例:
//
//        candy.ToBool(true)    // true
//        candy.ToBool(0)       // false
//        candy.ToBool("yes")   // true
//        candy.ToBool("off")   // false
//        candy.ToBool("hello") // true
//        candy.ToBool(nil)     // false
func ToBool(val interface{}) bool <span class="cov10" title="102">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                return x</span>
        case int:<span class="cov3" title="3">
                return x != 0</span>
        case int8:<span class="cov1" title="1">
                return x != 0</span>
        case int16:<span class="cov1" title="1">
                return x != 0</span>
        case int32:<span class="cov1" title="1">
                return x != 0</span>
        case int64:<span class="cov1" title="1">
                return x != 0</span>
        case uint:<span class="cov2" title="2">
                return x != 0</span>
        case uint8:<span class="cov1" title="1">
                return x != 0</span>
        case uint16:<span class="cov1" title="1">
                return x != 0</span>
        case uint32:<span class="cov1" title="1">
                return x != 0</span>
        case uint64:<span class="cov1" title="1">
                return x != 0</span>
        case float32:<span class="cov4" title="7">
                return !math.IsNaN(float64(x)) &amp;&amp; x != 0.0</span>
        case float64:<span class="cov4" title="7">
                return !math.IsNaN(x) &amp;&amp; x != 0.0</span>
        case string:<span class="cov8" title="39">
                switch strings.ToLower(x) </span>{
                case "true", "1", "t", "y", "yes", "on":<span class="cov6" title="17">
                        return true</span>
                case "false", "0", "f", "n", "no", "off":<span class="cov6" title="17">
                        return false</span>
                default:<span class="cov4" title="5">
                        return strings.TrimSpace(x) != ""</span>
                }
        case []byte:<span class="cov7" title="30">
                switch string(bytes.ToLower(x)) </span>{
                case "true", "1", "t", "y", "yes", "on":<span class="cov5" title="12">
                        return true</span>
                case "false", "0", "f", "n", "no", "off":<span class="cov5" title="12">
                        return false</span>
                default:<span class="cov4" title="6">
                        return len(bytes.TrimSpace(x)) != 0</span>
                }
        default:<span class="cov3" title="4">
                return false</span>
        }
}</pre>
		
		<pre class="file" id="file58" style="display: none">package candy

import (
        "fmt"
        "math"
        "strconv"
        "time"
        "unsafe"

        "github.com/lazygophers/utils/json"
)

// ToBytes 将任意类型转换为字节切片
// 支持的类型包括：
// - 布尔值：true -&gt; []byte("1"), false -&gt; []byte("0")
// - 整数类型：int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64
// - 浮点数：float32, float64（自动处理精度）
// - 时间类型：time.Duration
// - 字符串：转换为字节切片
// - 字节切片：直接返回
// - nil：返回nil
// - error：返回错误信息的字节切片
// - 其他类型：使用 JSON 序列化
func ToBytes(val interface{}) []byte <span class="cov10" title="67">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return []byte("1")
                }</span>
                <span class="cov1" title="1">return []byte("0")</span>
        case int:<span class="cov3" title="3">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int8:<span class="cov3" title="3">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int16:<span class="cov3" title="3">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int32:<span class="cov3" title="3">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int64:<span class="cov3" title="3">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint:<span class="cov2" title="2">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint8:<span class="cov2" title="2">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint16:<span class="cov2" title="2">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint32:<span class="cov2" title="2">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint64:<span class="cov2" title="2">
                return []byte(fmt.Sprintf("%d", x))</span>
        case float32:<span class="cov5" title="10">
                if math.Floor(float64(x)) == float64(x) </span><span class="cov4" title="5">{
                        return []byte(strconv.FormatFloat(float64(x), 'f', 0, 32))
                }</span>

                <span class="cov4" title="5">return []byte(strconv.FormatFloat(float64(x), 'f', 15, 32))</span>
        case float64:<span class="cov5" title="10">
                if math.Floor(x) == x </span><span class="cov4" title="5">{
                        return []byte(fmt.Sprintf("%.0f", x))
                }</span>

                <span class="cov4" title="5">return []byte(strconv.FormatFloat(x, 'f', 6, 64))</span>
        case time.Duration:<span class="cov3" title="4">
                return []byte(x.String())</span>
        case string:<span class="cov3" title="3">
                return []byte(x)</span>
        case []byte:<span class="cov2" title="2">
                return x</span>
        case nil:<span class="cov2" title="2">
                return nil</span>
        case error:<span class="cov2" title="2">
                return []byte(x.Error())</span>

        default:<span class="cov5" title="7">
                buf, err := json.Marshal(x)
                if err != nil </span><span class="cov1" title="1">{
                        return nil
                }</span>

                <span class="cov4" title="6">return buf</span>
        }
}

func toString(b []byte) string <span class="cov5" title="9">{
        return *(*string)(unsafe.Pointer(&amp;b))
}</span>

func toBytes(s string) []byte <span class="cov4" title="5">{
        return *(*[]byte)(unsafe.Pointer(&amp;s))
}</pre>
		
		<pre class="file" id="file59" style="display: none">package candy

import (
        "strconv"
        "strings"
)

// ToFloat32 将任何类型的值尽力转换为 float32。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1.0, false 转换为 0.0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为浮点数，若解析失败则返回 0.0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0.0。
func ToFloat32(val interface{}) float32 <span class="cov10" title="47">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov3" title="3">
                return float32(x)</span>
        case int8:<span class="cov2" title="2">
                return float32(x)</span>
        case int16:<span class="cov2" title="2">
                return float32(x)</span>
        case int32:<span class="cov2" title="2">
                return float32(x)</span>
        case int64:<span class="cov2" title="2">
                return float32(x)</span>
        case uint:<span class="cov2" title="2">
                return float32(x)</span>
        case uint8:<span class="cov2" title="2">
                return float32(x)</span>
        case uint16:<span class="cov1" title="1">
                return float32(x)</span>
        case uint32:<span class="cov1" title="1">
                return float32(x)</span>
        case uint64:<span class="cov1" title="1">
                return float32(x)</span>
        case float32:<span class="cov3" title="3">
                return x</span>
        case float64:<span class="cov3" title="3">
                return float32(x)</span>
        case string:<span class="cov6" title="9">
                v := strings.TrimSpace(x)
                val, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov4" title="5">return float32(val)</span>
        case []byte:<span class="cov5" title="7">
                v := strings.TrimSpace(string(x))
                val, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov3" title="3">{
                        return 0
                }</span>
                <span class="cov4" title="4">return float32(val)</span>
        default:<span class="cov4" title="5">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file60" style="display: none">package candy

import (
        "strconv"
        "strings"
)

// ToFloat64 将任何类型的值尽力转换为 float64。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1.0, false 转换为 0.0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为浮点数。若解析失败，会进一步尝试解析为整数。如果两种解析都失败，则返回 0.0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0.0。
func ToFloat64(val interface{}) float64 <span class="cov10" title="97">{
        switch x := val.(type) </span>{
        case bool:<span class="cov4" title="6">
                if x </span><span class="cov3" title="4">{
                        return 1
                }</span>
                <span class="cov2" title="2">return 0</span>
        case int:<span class="cov4" title="7">
                return float64(x)</span>
        case int8:<span class="cov4" title="5">
                return float64(x)</span>
        case int16:<span class="cov4" title="5">
                return float64(x)</span>
        case int32:<span class="cov4" title="5">
                return float64(x)</span>
        case int64:<span class="cov4" title="5">
                return float64(x)</span>
        case uint:<span class="cov4" title="5">
                return float64(x)</span>
        case uint8:<span class="cov4" title="5">
                return float64(x)</span>
        case uint16:<span class="cov3" title="4">
                return float64(x)</span>
        case uint32:<span class="cov3" title="4">
                return float64(x)</span>
        case uint64:<span class="cov3" title="4">
                return float64(x)</span>
        case float32:<span class="cov4" title="6">
                return float64(x)</span>
        case float64:<span class="cov3" title="3">
                return x</span>
        case string:<span class="cov6" title="18">
                v := strings.TrimSpace(x)
                val, err := strconv.ParseFloat(v, 64)
                if err == nil </span><span class="cov5" title="10">{
                        return val
                }</span>

                <span class="cov5" title="8">intVal, intErr := strconv.ParseInt(v, 0, 64)
                if intErr == nil </span><span class="cov3" title="3">{
                        return float64(intVal)
                }</span>

                <span class="cov4" title="5">return 0</span>
        case []byte:<span class="cov5" title="10">
                v := strings.TrimSpace(string(x))
                val, err := strconv.ParseFloat(v, 64)
                if err == nil </span><span class="cov4" title="6">{
                        return val
                }</span>

                <span class="cov3" title="4">intVal, intErr := strconv.ParseInt(v, 0, 64)
                if intErr == nil </span><span class="cov1" title="1">{
                        return float64(intVal)
                }</span>

                <span class="cov3" title="3">return 0</span>
        default:<span class="cov4" title="5">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file61" style="display: none">package candy

// ToFloat64Slice 将一个切片接口尽力转换为 []float64。
//
// 支持的输入切片类型包括：
//   - []bool, []int, []int8, ..., []uint64, []float32, []float64, []string, [][]byte, []interface{}
//
// 切片中的每一个元素都会通过 ToFloat64 函数进行转换。
// 如果输入为 nil，将直接返回 nil。
// 如果输入为不支持的类型，将返回一个空的 []float64{}。
func ToFloat64Slice(val interface{}) []float64 <span class="cov10" title="18">{
        if val == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov9" title="17">switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint64:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                v := make([]float64, len(x))
                for i, val := range x </span><span class="cov4" title="3">{
                        v[i] = ToFloat64(val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case [][]byte:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov3" title="2">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov1" title="1">
                return []float64{}</span>
        }
}</pre>
		
		<pre class="file" id="file62" style="display: none">package candy

import "strconv"

// ToInt 将任何类型的值尽力转换为 int。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1, false 转换为 0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为无符号整数，若解析失败则返回 0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0。
func ToInt(val interface{}) int <span class="cov10" title="48">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov3" title="3">
                return x</span>
        case int8:<span class="cov2" title="2">
                return int(x)</span>
        case int16:<span class="cov2" title="2">
                return int(x)</span>
        case int32:<span class="cov2" title="2">
                return int(x)</span>
        case int64:<span class="cov2" title="2">
                return int(x)</span>
        case uint:<span class="cov2" title="2">
                return int(x)</span>
        case uint8:<span class="cov2" title="2">
                return int(x)</span>
        case uint16:<span class="cov1" title="1">
                return int(x)</span>
        case uint32:<span class="cov1" title="1">
                return int(x)</span>
        case uint64:<span class="cov1" title="1">
                return int(x)</span>
        case float32:<span class="cov4" title="4">
                return int(x)</span>
        case float64:<span class="cov4" title="4">
                return int(x)</span>
        case string:<span class="cov5" title="8">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov4" title="5">{
                        return 0
                }</span>
                <span class="cov3" title="3">return int(val)</span>
        case []byte:<span class="cov5" title="7">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov3" title="3">return int(val)</span>
        default:<span class="cov4" title="5">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file63" style="display: none">package candy

import "strconv"

// ToInt16 将任何类型的值尽力转换为 int16。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1, false 转换为 0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为无符号整数，若解析失败则返回 0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0。
func ToInt16(val interface{}) int16 <span class="cov10" title="25">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov1" title="1">
                return int16(x)</span>
        case int8:<span class="cov1" title="1">
                return int16(x)</span>
        case int16:<span class="cov1" title="1">
                return x</span>
        case int32:<span class="cov1" title="1">
                return int16(x)</span>
        case int64:<span class="cov1" title="1">
                return int16(x)</span>
        case uint:<span class="cov1" title="1">
                return int16(x)</span>
        case uint8:<span class="cov1" title="1">
                return int16(x)</span>
        case uint16:<span class="cov1" title="1">
                return int16(x)</span>
        case uint32:<span class="cov1" title="1">
                return int16(x)</span>
        case uint64:<span class="cov1" title="1">
                return int16(x)</span>
        case float32:<span class="cov1" title="1">
                return int16(x)</span>
        case float64:<span class="cov1" title="1">
                return int16(x)</span>
        case string:<span class="cov5" title="5">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov1" title="1">return int16(val)</span>
        case []byte:<span class="cov4" title="4">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov4" title="3">{
                        return 0
                }</span>
                <span class="cov1" title="1">return int16(val)</span>
        default:<span class="cov2" title="2">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file64" style="display: none">package candy

import "strconv"

// ToInt32 将任何类型的值尽力转换为 int32。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1, false 转换为 0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为无符号整数，若解析失败则返回 0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0。
func ToInt32(val interface{}) int32 <span class="cov10" title="28">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov1" title="1">
                return int32(x)</span>
        case int8:<span class="cov1" title="1">
                return int32(x)</span>
        case int16:<span class="cov1" title="1">
                return int32(x)</span>
        case int32:<span class="cov4" title="4">
                return x</span>
        case int64:<span class="cov1" title="1">
                return int32(x)</span>
        case uint:<span class="cov1" title="1">
                return int32(x)</span>
        case uint8:<span class="cov1" title="1">
                return int32(x)</span>
        case uint16:<span class="cov1" title="1">
                return int32(x)</span>
        case uint32:<span class="cov1" title="1">
                return int32(x)</span>
        case uint64:<span class="cov1" title="1">
                return int32(x)</span>
        case float32:<span class="cov1" title="1">
                return int32(x)</span>
        case float64:<span class="cov2" title="2">
                return int32(x)</span>
        case string:<span class="cov5" title="6">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov2" title="2">return int32(val)</span>
        case []byte:<span class="cov2" title="2">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov1" title="1">{
                        return 0
                }</span>
                <span class="cov1" title="1">return int32(val)</span>
        default:<span class="cov2" title="2">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file65" style="display: none">package candy

import (
        "strconv"
        "time"
)

// ToInt64 将任何类型的值尽力转换为 int64。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1, false 转换为 0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - time.Duration: 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为有符号整数，若解析失败则返回 0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0。
func ToInt64(val interface{}) int64 <span class="cov10" title="45">{
        switch x := val.(type) </span>{
        case bool:<span class="cov5" title="6">
                if x </span><span class="cov4" title="4">{
                        return 1
                }</span>
                <span class="cov2" title="2">return 0</span>
        case int:<span class="cov2" title="2">
                return int64(x)</span>
        case int8:<span class="cov1" title="1">
                return int64(x)</span>
        case int16:<span class="cov1" title="1">
                return int64(x)</span>
        case int32:<span class="cov1" title="1">
                return int64(x)</span>
        case int64:<span class="cov4" title="5">
                return x</span>
        case uint:<span class="cov1" title="1">
                return int64(x)</span>
        case uint8:<span class="cov1" title="1">
                return int64(x)</span>
        case uint16:<span class="cov1" title="1">
                return int64(x)</span>
        case uint32:<span class="cov1" title="1">
                return int64(x)</span>
        case uint64:<span class="cov1" title="1">
                return int64(x)</span>
        case time.Duration:<span class="cov2" title="2">
                return int64(x)</span>
        case float32:<span class="cov1" title="1">
                return int64(x)</span>
        case float64:<span class="cov2" title="2">
                return int64(x)</span>
        case string:<span class="cov6" title="10">
                val, err := strconv.ParseInt(x, 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov5" title="6">return val</span>
        case []byte:<span class="cov5" title="7">
                val, err := strconv.ParseInt(string(x), 10, 64)
                if err != nil </span><span class="cov3" title="3">{
                        return 0
                }</span>
                <span class="cov4" title="4">return val</span>
        default:<span class="cov2" title="2">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file66" style="display: none">package candy

// ToInt64Slice 将一个切片接口尽力转换为 []int64。
//
// 支持的输入切片类型包括：
//   - []bool, []int, []int8, ..., []uint64, []float32, []float64, []string, [][]byte, []interface{}
//
// 切片中的每一个元素都会通过 ToInt64 函数进行转换。
// 如果输入为 nil，将直接返回 nil。
// 如果输入为不支持的类型，将返回一个空的 []int64{}。
func ToInt64Slice(val interface{}) []int64 <span class="cov10" title="17">{
        switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint64:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case [][]byte:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov3" title="2">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov1" title="1">
                return []int64{}</span>
        }
}</pre>
		
		<pre class="file" id="file67" style="display: none">package candy

import "strconv"

// ToInt8 将任何类型的值尽力转换为 int8。
//
// 支持的输入类型包括：
//   - bool: true 转换为 1, false 转换为 0。
//   - 所有整数类型 (int, int8, ..., uint, uint8, ...): 直接进行类型转换。
//   - 所有浮点数类型 (float32, float64): 直接进行类型转换。
//   - string, []byte: 尝试解析为无符号整数，若解析失败则返回 0。
//
// 对于无法转换的类型(如 struct, map 等)或 nil，将返回 0。
func ToInt8(val interface{}) int8 <span class="cov10" title="25">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov1" title="1">
                return int8(x)</span>
        case int8:<span class="cov1" title="1">
                return x</span>
        case int16:<span class="cov1" title="1">
                return int8(x)</span>
        case int32:<span class="cov1" title="1">
                return int8(x)</span>
        case int64:<span class="cov1" title="1">
                return int8(x)</span>
        case uint:<span class="cov1" title="1">
                return int8(x)</span>
        case uint8:<span class="cov1" title="1">
                return int8(x)</span>
        case uint16:<span class="cov1" title="1">
                return int8(x)</span>
        case uint32:<span class="cov1" title="1">
                return int8(x)</span>
        case uint64:<span class="cov1" title="1">
                return int8(x)</span>
        case float32:<span class="cov1" title="1">
                return int8(x)</span>
        case float64:<span class="cov1" title="1">
                return int8(x)</span>
        case string:<span class="cov5" title="5">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov1" title="1">return int8(val)</span>
        case []byte:<span class="cov4" title="4">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov4" title="3">{
                        return 0
                }</span>
                <span class="cov1" title="1">return int8(val)</span>
        default:<span class="cov2" title="2">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file68" style="display: none">package candy

import "github.com/lazygophers/utils/json"

// ToMap 将任何类型的值转换为 map[string]interface{}。
//
// 支持的输入类型包括：
//   - []byte: 尝试JSON反序列化为map，失败则通过ToMapStringAny转换
//   - string: 尝试JSON反序列化为map，失败则通过ToMapStringAny转换
//   - 其他类型: 通过ToMapStringAny函数转换
//
// 如果输入为 nil 或转换失败，将返回相应的默认值。
func ToMap(v interface{}) map[string]interface{} <span class="cov10" title="8">{
        switch x := v.(type) </span>{
        case []byte:<span class="cov4" title="2">
                var m map[string]interface{}
                err := json.Unmarshal(x, &amp;m)
                if err == nil </span><span class="cov1" title="1">{
                        return m
                }</span>

        case string:<span class="cov5" title="3">
                var m map[string]interface{}
                err := json.UnmarshalString(x, &amp;m)
                if err == nil </span><span class="cov4" title="2">{
                        return m
                }</span>

        }

        <span class="cov7" title="5">return ToMapStringAny(v)</span>
}</pre>
		
		<pre class="file" id="file69" style="display: none">package candy

import "reflect"

// ToMapInt32String 将任何类型的 map 转换为 map[int32]string。
//
// 如果输入不是 map 类型，将返回一个空的 map[int32]string{}。
// map 的 key 会通过 ToInt32 函数转换为 int32，value 会通过 ToString 函数转换为字符串。
func ToMapInt32String(v interface{}) map[int32]string <span class="cov10" title="4">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov5" title="2">{
                return map[int32]string{}
        }</span>

        <span class="cov5" title="2">m := make(map[int32]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov8" title="3">{
                m[ToInt32(mg.Key().Interface())] = ToString(mg.Value().Interface())
        }</span>

        <span class="cov5" title="2">return m</span>
}</pre>
		
		<pre class="file" id="file70" style="display: none">package candy

import "reflect"

// ToMapInt64String 将任何类型的 map 转换为 map[int64]string。
//
// 如果输入不是 map 类型，将返回一个空的 map[int64]string{}。
// map 的 key 会通过 ToInt64 函数转换为 int64，value 会通过 ToString 函数转换为字符串。
func ToMapInt64String(v interface{}) map[int64]string <span class="cov10" title="3">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov1" title="1">{
                return map[int64]string{}
        }</span>

        <span class="cov6" title="2">m := make(map[int64]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov6" title="2">{
                m[ToInt64(mg.Key().Interface())] = ToString(mg.Value().Interface())
        }</span>

        <span class="cov6" title="2">return m</span>
}</pre>
		
		<pre class="file" id="file71" style="display: none">package candy

import "reflect"

// ToMapStringAny 将任何类型的 map 转换为 map[string]interface{}。
//
// 如果输入为 nil，将返回 nil。
// 如果输入不是 map 类型，将返回一个空的 map[string]interface{}{}。
// map 的 key 会通过 ToString 函数转换为字符串，value 保持原始类型。
func ToMapStringAny(v interface{}) map[string]interface{} <span class="cov10" title="13">{
        if v == nil </span><span class="cov3" title="2">{
                return nil
        }</span>

        <span class="cov9" title="11">vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov7" title="6">{
                return map[string]interface{}{}
        }</span>

        <span class="cov6" title="5">m := make(map[string]interface{})

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov9" title="10">{
                m[ToString(mg.Key().Interface())] = mg.Value().Interface()
        }</span>

        <span class="cov6" title="5">return m</span>
}</pre>
		
		<pre class="file" id="file72" style="display: none">package candy

import "reflect"

// ToMapStringArrayString 将任何类型的 map 转换为 map[string][]string。
//
// 如果输入为 nil，将返回 nil。
// 如果输入不是 map 类型，将会 panic。
// map 的 key 会通过 ToString 函数转换为字符串，value 会通过 ToArrayString 函数转换为 []string。
func ToMapStringArrayString(v interface{}) map[string][]string <span class="cov10" title="5">{
        if v == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov8" title="4">vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }

        <span class="cov7" title="3">m := make(map[string][]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov8" title="4">{
                m[ToString(mg.Key().Interface())] = ToArrayString(mg.Value().Interface())
        }</span>

        <span class="cov7" title="3">return m</span>
}</pre>
		
		<pre class="file" id="file73" style="display: none">package candy

import "reflect"

// ToMapStringInt64 将任何类型的 map 转换为 map[string]int64。
//
// 如果输入不是 map 类型，将返回一个空的 map[string]int64{}。
// map 的 key 会通过 ToString 函数转换为字符串，value 会通过 ToInt64 函数转换为 int64。
func ToMapStringInt64(v interface{}) map[string]int64 <span class="cov10" title="3">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov1" title="1">{
                return map[string]int64{}
        }</span>

        <span class="cov6" title="2">m := make(map[string]int64)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov6" title="2">{
                m[ToString(mg.Key().Interface())] = ToInt64(mg.Value().Interface())
        }</span>

        <span class="cov6" title="2">return m</span>
}</pre>
		
		<pre class="file" id="file74" style="display: none">package candy

import "reflect"

// ToMapStringString 将任何类型的 map 转换为 map[string]string。
//
// 如果输入不是 map 类型，将返回一个空的 map[string]string{}。
// map 的 key 和 value 都会通过 ToString 函数转换为字符串。
func ToMapStringString(v interface{}) map[string]string <span class="cov10" title="3">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov1" title="1">{
                return map[string]string{}
        }</span>

        <span class="cov6" title="2">m := make(map[string]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov6" title="2">{
                m[ToString(mg.Key().Interface())] = ToString(mg.Value().Interface())
        }</span>

        <span class="cov6" title="2">return m</span>
}</pre>
		
		<pre class="file" id="file75" style="display: none">package candy

// ToPtr 将值转换为指针
// 接受任意类型的值并返回其指针
func ToPtr[T any](v T) *T <span class="cov10" title="6">{
        return &amp;v
}</pre>
		
		<pre class="file" id="file76" style="display: none">package candy

import (
        "math"
        "strconv"
        "time"

        "github.com/lazygophers/utils/json"
)

// ToString 将任意类型转换为字符串
// 支持的类型包括：
// - 布尔值：true -&gt; "1", false -&gt; "0"
// - 整数类型：int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64
// - 浮点数：float32, float64（自动处理精度）
// - 时间类型：time.Duration
// - 字符串：直接返回
// - 字节切片：转换为字符串
// - nil：返回空字符串
// - error：返回错误信息
// - 其他类型：使用 JSON 序列化
func ToString(val interface{}) string <span class="cov10" title="123">{
        switch x := val.(type) </span>{
        case bool:<span class="cov5" title="9">
                if x </span><span class="cov4" title="7">{
                        return "1"
                }</span>
                <span class="cov2" title="2">return "0"</span>
        case int:<span class="cov6" title="18">
                return strconv.FormatInt(int64(x), 10)</span>
        case int8:<span class="cov1" title="1">
                return strconv.FormatInt(int64(x), 10)</span>
        case int16:<span class="cov1" title="1">
                return strconv.FormatInt(int64(x), 10)</span>
        case int32:<span class="cov1" title="1">
                return strconv.FormatInt(int64(x), 10)</span>
        case int64:<span class="cov1" title="1">
                return strconv.FormatInt(x, 10)</span>
        case uint:<span class="cov1" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint8:<span class="cov1" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint16:<span class="cov1" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint32:<span class="cov1" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint64:<span class="cov1" title="1">
                return strconv.FormatUint(x, 10)</span>
        case float32:<span class="cov2" title="2">
                if math.Floor(float64(x)) == float64(x) </span><span class="cov1" title="1">{
                        return strconv.FormatFloat(float64(x), 'f', 0, 32)
                }</span>

                <span class="cov1" title="1">return strconv.FormatFloat(float64(x), 'f', 15, 32)</span>
        case float64:<span class="cov7" title="27">
                if math.Floor(x) == x </span><span class="cov6" title="20">{
                        return strconv.FormatFloat(x, 'f', 0, 64)
                }</span>

                <span class="cov4" title="7">return strconv.FormatFloat(x, 'f', 6, 64)</span>
        case time.Duration:<span class="cov1" title="1">
                return x.String()</span>
        case string:<span class="cov7" title="41">
                return x</span>
        case []byte:<span class="cov1" title="1">
                return string(x)</span>
        case nil:<span class="cov3" title="4">
                return ""</span>
        case error:<span class="cov1" title="1">
                return x.Error()</span>

        default:<span class="cov5" title="10">
                buf, err := json.Marshal(x)
                if err != nil </span><span class="cov1" title="1">{
                        return ""
                }</span>

                <span class="cov5" title="9">return string(buf)</span>
        }
}</pre>
		
		<pre class="file" id="file77" style="display: none">package candy

import (
        "bytes"
        "math"
        "strconv"
        "strings"

        "github.com/lazygophers/utils/json"
)

// ToStringSlice 将任意类型转换为字符串切片
// 支持的类型包括各种基础类型的切片、字符串、字节切片等
// seqs 参数用于指定分隔符，默认为逗号
func ToStringSlice(val interface{}, seqs ...string) []string <span class="cov10" title="95">{
        var seq string
        if len(seqs) &gt; 0 </span><span class="cov9" title="68">{
                seq = seqs[0]
        }</span> else<span class="cov7" title="27"> {
                seq = ","
        }</span>

        <span class="cov10" title="95">switch x := val.(type) </span>{
        case []bool:<span class="cov3" title="4">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="6">{
                        if v </span><span class="cov3" title="4">{
                                ss = append(ss, "1")
                        }</span> else<span class="cov2" title="2"> {
                                ss = append(ss, "0")
                        }</span>
                }
                <span class="cov3" title="4">return ss</span>

        case []int:<span class="cov4" title="6">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov6" title="13">{
                        ss = append(ss, strconv.Itoa(v))
                }</span>
                <span class="cov4" title="6">return ss</span>

        case []int8:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="6">{
                        ss = append(ss, strconv.FormatInt(int64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []int16:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="6">{
                        ss = append(ss, strconv.FormatInt(int64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []int32:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="6">{
                        ss = append(ss, strconv.FormatInt(int64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []int64:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="6">{
                        ss = append(ss, strconv.FormatInt(v, 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []uint:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="5">{
                        ss = append(ss, strconv.FormatUint(uint64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>


        case []uint16:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="5">{
                        ss = append(ss, strconv.FormatUint(uint64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []uint32:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="5">{
                        ss = append(ss, strconv.FormatUint(uint64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []uint64:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="5">{
                        ss = append(ss, strconv.FormatUint(v, 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []float32:<span class="cov3" title="3">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov5" title="9">{
                        if math.Floor(float64(v)) == float64(v) </span><span class="cov4" title="7">{
                                ss = append(ss, strconv.FormatInt(int64(v), 10))
                        }</span> else<span class="cov2" title="2"> {
                                ss = append(ss, strconv.FormatFloat(float64(v), 'f', -1, 32))
                        }</span>
                }
                <span class="cov3" title="3">return ss</span>

        case []float64:<span class="cov3" title="3">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov5" title="9">{
                        if math.Floor(v) == (v) </span><span class="cov4" title="7">{
                                ss = append(ss, strconv.FormatInt(int64(v), 10))
                        }</span> else<span class="cov2" title="2"> {
                                ss = append(ss, strconv.FormatFloat(v, 'f', -1, 32))
                        }</span>
                }
                <span class="cov3" title="3">return ss</span>

        case []string:<span class="cov3" title="4">
                return x</span>

        case []byte:<span class="cov6" title="16">
                if bytes.HasPrefix(x, []byte("[")) &amp;&amp; bytes.HasSuffix(x, []byte("]")) </span><span class="cov5" title="8">{
                        var values []any
                        err := json.Unmarshal(x, &amp;values)
                        if err == nil </span><span class="cov4" title="7">{
                                return ToStringSlice(values)
                        }</span>
                }

                <span class="cov5" title="9">if seq == "" </span><span class="cov0" title="0">{
                        return []string{toString(x)}
                }</span>

                <span class="cov5" title="9">return strings.Split(toString(x), seq)</span>

        case string:<span class="cov7" title="23">
                if strings.HasPrefix(x, "[") &amp;&amp; strings.HasSuffix(x, "]") </span><span class="cov4" title="6">{
                        var values []any
                        err := json.UnmarshalString(x, &amp;values)
                        if err == nil </span><span class="cov4" title="5">{
                                return ToStringSlice(values)
                        }</span>
                }

                <span class="cov6" title="18">if seq == "" </span><span class="cov2" title="2">{
                        return []string{x}
                }</span>

                <span class="cov6" title="16">return strings.Split(x, seq)</span>

        case []interface{}:<span class="cov6" title="16">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="43">{
                        ss = append(ss, ToString(v))
                }</span>
                <span class="cov6" title="16">return ss</span>

        default:<span class="cov3" title="4">
                return nil</span>
        }
}</pre>
		
		<pre class="file" id="file78" style="display: none">package candy

import "strconv"

// ToUint 将任意类型的值转换为 uint 类型
// 支持的类型包括：bool、所有整数类型、浮点数、字符串、字节切片
// 对于不支持的类型或转换失败的情况，返回 0
func ToUint(val interface{}) uint <span class="cov10" title="32">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                // 布尔值转换：true -&gt; 1，false -&gt; 0
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov4" title="4">
                // 有符号整数直接转换为 uint
                return uint(x)</span>
        case int8:<span class="cov1" title="1">
                return uint(x)</span>
        case int16:<span class="cov1" title="1">
                return uint(x)</span>
        case int32:<span class="cov1" title="1">
                return uint(x)</span>
        case int64:<span class="cov1" title="1">
                return uint(x)</span>
        case uint:<span class="cov2" title="2">
                // 无符号整数直接返回
                return x</span>
        case uint8:<span class="cov1" title="1">
                return uint(x)</span>
        case uint16:<span class="cov1" title="1">
                return uint(x)</span>
        case uint32:<span class="cov1" title="1">
                return uint(x)</span>
        case uint64:<span class="cov1" title="1">
                return uint(x)</span>
        case float32:<span class="cov1" title="1">
                // 浮点数转换为 uint，会截断小数部分
                return uint(x)</span>
        case float64:<span class="cov2" title="2">
                return uint(x)</span>
        case string:<span class="cov5" title="5">
                // 字符串解析为 uint，使用十进制格式
                // 解析失败时返回 0
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov3" title="3">{
                        return 0
                }</span>
                <span class="cov2" title="2">return uint(val)</span>
        case []byte:<span class="cov4" title="4">
                // 字节切片转换为字符串后再解析为 uint
                // 解析失败时返回 0
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov3" title="3">{
                        return 0
                }</span>
                <span class="cov1" title="1">return uint(val)</span>
        default:<span class="cov4" title="4">
                // 不支持的类型返回 0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Package candy 提供语法糖和便捷的类型转换工具函数
package candy

import "strconv"

// ToUint16 将各种类型的值转换为 uint16 类型
//
// 支持的输入类型：
//   - bool: true 转换为 1，false 转换为 0
//   - 整数类型 (int, int8, int16, int32, int64): 直接转换
//   - 无符号整数 (uint, uint8, uint16, uint32, uint64): 直接转换
//   - 浮点数 (float32, float64): 截断小数部分后转换
//   - string: 使用 strconv.ParseUint 解析十进制字符串，失败返回 0
//   - []byte: 转换为字符串后解析，失败返回 0
//   - 其他类型: 返回 0
//
// 参数:
//
//        val: 要转换的值，支持多种类型
//
// 返回:
//
//        uint16: 转换后的 uint16 值，转换失败时返回 0
//
// 示例:
//
//        ToUint16(42)        // 返回 42
//        ToUint16("100")     // 返回 100
//        ToUint16(true)      // 返回 1
//        ToUint16(3.14)      // 返回 3
//        ToUint16("invalid") // 返回 0
func ToUint16(val interface{}) uint16 <span class="cov10" title="28">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                // 布尔值转换：true -&gt; 1, false -&gt; 0
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov2" title="2">
                // 有符号整数直接转换
                return uint16(x)</span>
        case int8:<span class="cov1" title="1">
                // 8位有符号整数直接转换
                return uint16(x)</span>
        case int16:<span class="cov1" title="1">
                // 16位有符号整数直接转换
                return uint16(x)</span>
        case int32:<span class="cov1" title="1">
                // 32位有符号整数直接转换
                return uint16(x)</span>
        case int64:<span class="cov1" title="1">
                // 64位有符号整数直接转换
                return uint16(x)</span>
        case uint:<span class="cov1" title="1">
                // 无符号整数直接转换
                return uint16(x)</span>
        case uint8:<span class="cov1" title="1">
                // 8位无符号整数直接转换
                return uint16(x)</span>
        case uint16:<span class="cov1" title="1">
                // 如果已经是 uint16 类型，直接返回
                return x</span>
        case uint32:<span class="cov1" title="1">
                // 32位无符号整数直接转换
                return uint16(x)</span>
        case uint64:<span class="cov1" title="1">
                // 64位无符号整数直接转换
                return uint16(x)</span>
        case float32:<span class="cov1" title="1">
                // 32位浮点数转换，截断小数部分
                return uint16(x)</span>
        case float64:<span class="cov2" title="2">
                // 64位浮点数转换，截断小数部分
                return uint16(x)</span>
        case string:<span class="cov6" title="7">
                // 字符串解析为无符号整数
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        // 解析失败返回 0
                        return 0
                }</span>
                <span class="cov3" title="3">return uint16(val)</span>
        case []byte:<span class="cov2" title="2">
                // 字节切片转换为字符串后解析
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov1" title="1">{
                        // 解析失败返回 0
                        return 0
                }</span>
                <span class="cov1" title="1">return uint16(val)</span>
        default:<span class="cov3" title="3">
                // 不支持的类型返回 0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package candy

import "strconv"

// ToUint32 将任意类型转换为 uint32 类型
// 支持的类型包括：bool、所有整数类型、浮点数、字符串、字节数组
// 转换失败时返回 0
func ToUint32(val interface{}) uint32 <span class="cov10" title="113">{
        switch x := val.(type) </span>{
        case bool:<span class="cov3" title="4">
                // 布尔值转换：true -&gt; 1，false -&gt; 0
                if x </span><span class="cov2" title="2">{
                        return 1
                }</span>
                <span class="cov2" title="2">return 0</span>
        case int:<span class="cov4" title="6">
                // 有符号整数转换为 uint32
                return uint32(x)</span>
        case int8:<span class="cov3" title="4">
                // 8位有符号整数转换为 uint32
                return uint32(x)</span>
        case int16:<span class="cov3" title="4">
                // 16位有符号整数转换为 uint32
                return uint32(x)</span>
        case int32:<span class="cov3" title="4">
                // 32位有符号整数转换为 uint32
                return uint32(x)</span>
        case int64:<span class="cov5" title="10">
                // 64位有符号整数转换为 uint32
                return uint32(x)</span>
        case uint:<span class="cov3" title="4">
                // 无符号整数转换为 uint32
                return uint32(x)</span>
        case uint8:<span class="cov3" title="4">
                // 8位无符号整数转换为 uint32
                return uint32(x)</span>
        case uint16:<span class="cov3" title="4">
                // 16位无符号整数转换为 uint32
                return uint32(x)</span>
        case uint32:<span class="cov4" title="5">
                // 如果已经是 uint32 类型，直接返回
                return x</span>
        case uint64:<span class="cov4" title="5">
                // 64位无符号整数转换为 uint32，可能发生截断
                return uint32(x)</span>
        case float32:<span class="cov3" title="3">
                // 32位浮点数转换为 uint32
                return uint32(x)</span>
        case float64:<span class="cov5" title="12">
                // 64位浮点数转换为 uint32
                return uint32(x)</span>
        case string:<span class="cov6" title="21">
                // 字符串解析为 uint32
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov5" title="11">{
                        return 0
                }</span>
                <span class="cov5" title="10">return uint32(val)</span>
        case []byte:<span class="cov5" title="10">
                // 字节数组转换为字符串后解析为 uint32
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov4" title="6">{
                        return 0
                }</span>
                <span class="cov3" title="4">return uint32(val)</span>
        default:<span class="cov5" title="13">
                // 不支持的类型返回 0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file81" style="display: none">// Package candy 提供语法糖和便捷的类型转换工具函数
package candy

import "strconv"

// ToUint64 将各种类型的值转换为 uint64 类型
//
// 支持的输入类型：
//   - bool: true 转换为 1，false 转换为 0
//   - 整数类型 (int, int8, int16, int32, int64): 直接转换
//   - 无符号整数 (uint, uint8, uint16, uint32, uint64): 直接转换
//   - 浮点数 (float32, float64): 截断小数部分后转换
//   - string: 使用 strconv.ParseUint 解析十进制字符串，失败返回 0
//   - []byte: 转换为字符串后解析，失败返回 0
//   - 其他类型: 返回 0
//
// 参数:
//
//        val: 要转换的值，支持多种类型
//
// 返回:
//
//        uint64: 转换后的 uint64 值，转换失败时返回 0
//
// 示例:
//
//        ToUint64(42)         // 返回 42
//        ToUint64("100")      // 返回 100
//        ToUint64(true)       // 返回 1
//        ToUint64(3.14)       // 返回 3
//        ToUint64("invalid")  // 返回 0
func ToUint64(val interface{}) uint64 <span class="cov10" title="125">{
        switch x := val.(type) </span>{
        case bool:<span class="cov3" title="4">
                // 布尔值转换：true -&gt; 1, false -&gt; 0
                if x </span><span class="cov2" title="2">{
                        return 1
                }</span>
                <span class="cov2" title="2">return 0</span>
        case int:<span class="cov4" title="7">
                // 有符号整数直接转换
                return uint64(x)</span>
        case int8:<span class="cov4" title="5">
                // 8位有符号整数直接转换
                return uint64(x)</span>
        case int16:<span class="cov4" title="5">
                // 16位有符号整数直接转换
                return uint64(x)</span>
        case int32:<span class="cov4" title="5">
                // 32位有符号整数直接转换
                return uint64(x)</span>
        case int64:<span class="cov5" title="9">
                // 64位有符号整数直接转换
                return uint64(x)</span>
        case uint:<span class="cov4" title="5">
                // 无符号整数直接转换
                return uint64(x)</span>
        case uint8:<span class="cov4" title="6">
                // 8位无符号整数直接转换
                return uint64(x)</span>
        case uint16:<span class="cov4" title="6">
                // 16位无符号整数直接转换
                return uint64(x)</span>
        case uint32:<span class="cov4" title="6">
                // 32位无符号整数直接转换
                return uint64(x)</span>
        case uint64:<span class="cov4" title="6">
                // 如果已经是 uint64 类型，直接返回
                return x</span>
        case float32:<span class="cov3" title="4">
                // 32位浮点数转换，截断小数部分
                return uint64(x)</span>
        case float64:<span class="cov5" title="13">
                // 64位浮点数转换，截断小数部分
                return uint64(x)</span>
        case string:<span class="cov6" title="21">
                // 字符串解析为无符号整数
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov5" title="12">{
                        // 解析失败返回 0
                        return 0
                }</span>
                <span class="cov5" title="9">return val</span>
        case []byte:<span class="cov5" title="11">
                // 字节切片转换为字符串后解析
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov4" title="6">{
                        // 解析失败返回 0
                        return 0
                }</span>
                <span class="cov4" title="5">return val</span>
        default:<span class="cov5" title="12">
                // 不支持的类型返回 0
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file82" style="display: none">package candy

import "strconv"

// ToUint8 将任意类型的值转换为 uint8 类型
// 支持的类型包括：bool、所有整数类型、浮点数、字符串、字节切片
// 对于不支持的类型或转换失败的情况，返回 0
func ToUint8(val interface{}) uint8 <span class="cov10" title="34">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                // 布尔值转换：true -&gt; 1，false -&gt; 0
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov3" title="3">
                // 有符号整数直接转换为 uint8
                return uint8(x)</span>
        case int8:<span class="cov2" title="2">
                return uint8(x)</span>
        case int16:<span class="cov1" title="1">
                return uint8(x)</span>
        case int32:<span class="cov1" title="1">
                return uint8(x)</span>
        case int64:<span class="cov1" title="1">
                return uint8(x)</span>
        case uint:<span class="cov1" title="1">
                // 无符号整数转换为 uint8，可能会截断高位
                return uint8(x)</span>
        case uint8:<span class="cov2" title="2">
                // uint8 类型直接返回
                return x</span>
        case uint16:<span class="cov1" title="1">
                // uint16 转换为 uint8，可能会截断高位
                return uint8(x)</span>
        case uint32:<span class="cov1" title="1">
                // uint32 转换为 uint8，可能会截断高位
                return uint8(x)</span>
        case uint64:<span class="cov1" title="1">
                // uint64 转换为 uint8，可能会截断高位
                return uint8(x)</span>
        case float32:<span class="cov1" title="1">
                // 浮点数转换为 uint8，会截断小数部分
                return uint8(x)</span>
        case float64:<span class="cov3" title="3">
                // 浮点数转换为 uint8，会截断小数部分
                return uint8(x)</span>
        case string:<span class="cov5" title="7">
                // 字符串解析为 uint8，使用十进制格式
                // 解析失败时返回 0
                val, err := strconv.ParseUint(x, 10, 8)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov3" title="3">return uint8(val)</span>
        case []byte:<span class="cov4" title="4">
                // 字节切片转换为字符串后再解析为 uint8
                // 解析失败时返回 0
                val, err := strconv.ParseUint(string(x), 10, 8)
                if err != nil </span><span class="cov3" title="3">{
                        return 0
                }</span>
                <span class="cov1" title="1">return uint8(val)</span>
        default:<span class="cov3" title="3">
                // 不支持的类型返回 0
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file83" style="display: none">package candy

// Top 返回切片中的前 n 个元素
// 如果 n 大于切片长度，则返回整个切片的副本
// 使用 copy 确保返回的是新切片，避免修改原切片
func Top[T any](ss []T, n int) (ret []T) <span class="cov10" title="9">{
        if n &lt;= 0 </span><span class="cov3" title="2">{
                return []T{}
        }</span>
        <span class="cov8" title="7">if n &gt; len(ss) </span><span class="cov3" title="2">{
                n = len(ss)
        }</span>

        <span class="cov8" title="7">ret = make([]T, n)
        copy(ret, ss[:n])
        return ret</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

import (
        "golang.org/x/exp/constraints"
)

// Unique 返回切片中的唯一元素，保持原始顺序
//
// 类型参数：
//   - T: 可排序的类型，支持所有可比较的内置类型
//
// 参数：
//   - ss: 输入切片，包含可排序类型的元素
//
// 返回值：
//   - []T: 去重后的切片，保持原始顺序
//
// 特点：
//   - 保持原始元素的顺序
//   - 使用 map 高效去重，时间复杂度 O(n)
//   - 空切片安全，返回空切片而非 nil
//   - 只支持可排序类型，确保类型安全
//
// 示例：
//
//        // 对整数切片去重
//        numbers := []int{1, 2, 2, 3, 4, 4, 5}
//        unique := Unique(numbers)
//        // unique 的值为 []int{1, 2, 3, 4, 5}
//
//        // 对字符串切片去重
//        names := []string{"Alice", "Bob", "Alice", "Charlie", "Bob"}
//        uniqueNames := Unique(names)
//        // uniqueNames 的值为 []string{"Alice", "Bob", "Charlie"}
//
//        // 对浮点数切片去重
//        floats := []float64{1.1, 2.2, 1.1, 3.3, 2.2}
//        uniqueFloats := Unique(floats)
//        // uniqueFloats 的值为 []float64{1.1, 2.2, 3.3}
func Unique[T constraints.Ordered](ss []T) (ret []T) <span class="cov7" title="20">{
        // 使用 make 初始化，确保返回空切片而非 nil
        ret = make([]T, 0)
        m := make(map[T]struct{}, len(ss))
        for _, s := range ss </span><span class="cov10" title="89">{
                if _, ok := m[s]; !ok </span><span class="cov9" title="56">{
                        m[s] = struct{}{}
                        ret = append(ret, s)
                }</span>
        }

        <span class="cov7" title="20">return</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">// Package candy 提供 Go 语法糖工具函数，简化常见的编程操作
package candy

// UniqueUsing 返回切片中的唯一元素，保持原始顺序，使用提供的函数来生成用于比较的键
//
// 类型参数：
//   - T: 任意类型，支持所有可比较的类型
//
// 参数：
//   - ss: 输入切片，包含任意类型的元素
//   - f: 键生成函数，用于从元素中提取比较键
//
// 返回值：
//   - []T: 去重后的切片，保持原始顺序
//
// 特点：
//   - 保持原始元素的顺序
//   - 使用自定义键生成函数，支持复杂类型去重
//   - 空切片安全，返回空切片而非 nil
//   - 适用于结构体、自定义类型等复杂类型
//   - 时间复杂度 O(n)，空间复杂度 O(n)
//
// 示例：
//
//        // 对结构体切片去重（按 ID）
//        type User struct {
//            ID   int
//            Name string
//        }
//        users := []User{{1, "Alice"}, {2, "Bob"}, {1, "Alice2"}}
//        uniqueUsers := UniqueUsing(users, func(u User) any { return u.ID })
//        // uniqueUsers 的值为 []User{{1, "Alice"}, {2, "Bob"}}
//
//        // 对字符串切片按长度去重
//        words := []string{"apple", "banana", "orange", "kiwi"}
//        uniqueLengths := UniqueUsing(words, func(s string) any { return len(s) })
//        // uniqueLengths 的值为 []string{"apple", "banana", "orange"}
//
//        // 对切片按首字母去重
//        names := []string{"Alice", "Bob", "Anna", "Charlie", "Bob"}
//        uniqueFirstLetters := UniqueUsing(names, func(s string) any { return s[0] })
//        // uniqueFirstLetters 的值为 []string{"Alice", "Bob", "Charlie"}
func UniqueUsing[T any](ss []T, f func(T) any) (ret []T) <span class="cov4" title="22">{
        // 空切片检查，返回空切片而非 nil
        if len(ss) == 0 </span><span class="cov2" title="3">{
                return []T{}
        }</span>

        // 创建映射用于记录已出现的键值
        <span class="cov4" title="19">m := make(map[any]struct{})

        // 遍历输入切片
        for _, s := range ss </span><span class="cov10" title="1068">{
                // 使用映射函数提取键值
                key := f(s)

                // 如果键值未出现过，则添加到结果切片
                if _, ok := m[key]; !ok </span><span class="cov7" title="147">{
                        m[key] = struct{}{}
                        ret = append(ret, s)
                }</span>
        }

        <span class="cov4" title="19">return ret</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package config

import (
        "bufio"
        "encoding/xml"
        "fmt"
        "github.com/hashicorp/hcl/v2/hclsimple"
        "github.com/lazygophers/log"
        "github.com/lazygophers/utils"
        "github.com/lazygophers/utils/json"
        "github.com/lazygophers/utils/osx"
        "github.com/lazygophers/utils/runtime"
        "github.com/pelletier/go-toml/v2"
        "github.com/yosuke-furukawa/json5/encoding/json5"
        "gopkg.in/ini.v1"
        "gopkg.in/yaml.v3"
        "io"
        "os"
        "path/filepath"
        "reflect"
        "strconv"
        "strings"
)

type Unmarshaler func(reader io.Reader, v interface{}) error
type Marshaler func(writer io.Writer, v interface{}) error

type supportedExt struct {
        Marshaler   Marshaler
        Unmarshaler Unmarshaler
}

var supportedExtMap = map[string]supportedExt{
        ".json": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov4" title="11">{
                        return json.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov2" title="2">{
                        return json.NewEncoder(writer).Encode(v)
                }</span>,
        },
        ".toml": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov1" title="1">{
                        return toml.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov2" title="2">{
                        return toml.NewEncoder(writer).Encode(v)
                }</span>,
        },
        ".yaml": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov1" title="1">{
                        return yaml.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov2" title="2">{
                        return yaml.NewEncoder(writer).Encode(v)
                }</span>,
        },
        ".yml": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov1" title="1">{
                        return yaml.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov1" title="1">{
                        return yaml.NewEncoder(writer).Encode(v)
                }</span>,
        },
        ".ini": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov2" title="2">{
                        cfg, err := ini.Load(reader)
                        if err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                        <span class="cov1" title="1">return cfg.MapTo(v)</span>
                },
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov2" title="2">{
                        cfg := ini.Empty()
                        err := cfg.ReflectFrom(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov2" title="2">_, err = cfg.WriteTo(writer)
                        return err</span>
                },
        },
        ".xml": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov2" title="2">{
                        return xml.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov1" title="1">{
                        encoder := xml.NewEncoder(writer)
                        encoder.Indent("", "  ")
                        return encoder.Encode(v)
                }</span>,
        },
        ".properties": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov3" title="6">{
                        return parseProperties(reader, v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov1" title="1">{
                        return writeProperties(writer, v)
                }</span>,
        },
        ".env": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov3" title="5">{
                        return parseEnvFile(reader, v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov1" title="1">{
                        return writeEnvFile(writer, v)
                }</span>,
        },
        ".hcl": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov1" title="1">{
                        content, err := io.ReadAll(reader)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov1" title="1">return hclsimple.Decode("config.hcl", content, nil, v)</span>
                },
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov1" title="1">{
                        return writeHCLFile(writer, v)
                }</span>,
        },
        ".json5": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov0" title="0">{
                        return json5.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov0" title="0">{
                        return json5.NewEncoder(writer).Encode(v)
                }</span>,
        },
}

func RegisterParser(ext string, m Marshaler, u Unmarshaler) <span class="cov2" title="2">{
        supportedExtMap[ext] = supportedExt{
                Marshaler:   m,
                Unmarshaler: u,
        }
}</span>

func tryFindConfigPath(baseDir string) string <span class="cov5" title="15">{
        for ext := range supportedExtMap </span><span class="cov8" title="121">{
                path := filepath.Join(baseDir, "conf"+ext)
                if osx.IsFile(path) </span><span class="cov2" title="3">{
                        return path
                }</span>

                <span class="cov8" title="118">path = filepath.Join(baseDir, "config"+ext)
                if osx.IsFile(path) </span><span class="cov1" title="1">{
                        return path
                }</span>
        }

        <span class="cov4" title="11">return ""</span>
}

var configPath string

func LoadConfig(c any, paths ...string) (err error) <span class="cov4" title="8">{
        err = LoadConfigSkipValidate(c, paths...)
        if err != nil </span><span class="cov1" title="1">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov4" title="7">err = utils.Validate(c)
        if err != nil </span><span class="cov3" title="6">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov1" title="1">log.Info("load config success")

        return nil</span>
}

func LoadConfigSkipValidate(c any, paths ...string) error <span class="cov6" title="39">{
        // 依次确认配置文件的位置
        if len(paths) &gt; 0 </span><span class="cov6" title="35">{
                for _, path := range paths </span><span class="cov6" title="36">{
                        if osx.IsFile(path) </span><span class="cov6" title="31">{
                                configPath = path
                                break</span>
                        }
                }
        }

        // NOTE: 从环境变量中获取
        <span class="cov6" title="39">if configPath == ""</span><span class="cov4" title="7">{
                log.Warnf("Try to load config from environment variable(LAZYGOPHERS_CONFIG)")
                configPath = os.Getenv("LAZYGOPHERS_CONFIG")
                if configPath != "" &amp;&amp; !osx.IsFile(configPath) </span><span class="cov1" title="1">{
                        log.Debugf("config file not found:%v", configPath)
                        configPath = ""
                }</span>
        }

        // NOTE: 从当前目录中获取
        <span class="cov6" title="39">if configPath == "" </span><span class="cov3" title="6">{
                log.Warnf("Try to load config from %s", runtime.Pwd())
                configPath = tryFindConfigPath(runtime.Pwd())
        }</span>

        //// NOTE: 从用户目录中获取
        //if configPath == "" {
        //        log.Warnf("Try to load config from %s", runtime.UserHomeDir())
        //        configPath = tryFindConfigPath(filepath.Join(runtime.UserHomeDir(), app.Name))
        //}
        //
        //// NOTE: 从系统目录中获取
        //if configPath == "" {
        //        log.Warnf("Try to load config from %s", runtime.UserConfigDir())
        //        configPath = tryFindConfigPath(filepath.Join(runtime.UserConfigDir(), app.Name))
        //}

        // NOTE: 从程序目录中获取
        <span class="cov6" title="39">if configPath == "" </span><span class="cov3" title="5">{
                log.Warnf("Try to load config from %s", runtime.ExecDir())
                configPath = tryFindConfigPath(runtime.ExecDir())
        }</span>

        <span class="cov6" title="39">file, err := os.Open(configPath)
        if err != nil </span><span class="cov4" title="7">{
                if os.IsNotExist(err) </span><span class="cov3" title="6">{
                        log.Warnf("Config file not found, use default config")
                        log.Debugf("config file not found:%v", configPath)
                }</span> else<span class="cov1" title="1"> {
                        log.Warnf("Config file open failed, use default config")
                        log.Errorf("err:%v", err)
                }</span>
        } else<span class="cov6" title="32"> {
                defer file.Close()
                log.Infof("Config file found, use config from %s", configPath)

                ext := filepath.Ext(configPath)
                if supported, ok := supportedExtMap[ext]; ok </span><span class="cov6" title="30">{
                        err = supported.Unmarshaler(file, c)
                        if err != nil </span><span class="cov3" title="4">{
                                log.Errorf("err:%v", err)
                        }</span>
                } else<span class="cov2" title="2"> {
                        log.Errorf("unsupported config file format:%v", ext)
                        return fmt.Errorf("unsupported config file format:%v", ext)
                }</span>
        }

        <span class="cov6" title="37">log.Info("load config success")

        return nil</span>
}

func SetConfig(c any) error <span class="cov5" title="16">{
        ext := filepath.Ext(configPath)
        if supported, ok := supportedExtMap[ext]; ok </span><span class="cov5" title="14">{
                file, err := os.OpenFile(configPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
                if err != nil </span><span class="cov1" title="1">{
                        log.Errorf("err:%v", err)
                        return err
                }</span>
                <span class="cov5" title="13">defer file.Close()

                err = supported.Marshaler(file, c)
                if err != nil </span><span class="cov1" title="1">{
                        log.Errorf("err:%v", err)
                        return nil
                }</span>

        } else<span class="cov2" title="2"> {
                log.Errorf("unsupported config file format:%v", ext)
                return fmt.Errorf("unsupported config file format:%v", ext)
        }</span>

        <span class="cov4" title="11">return nil</span>
}

// parseProperties 解析 .properties 文件格式
func parseProperties(reader io.Reader, v interface{}) error <span class="cov4" title="10">{
        props := make(map[string]string)
        scanner := bufio.NewScanner(reader)
        
        for scanner.Scan() </span><span class="cov6" title="38">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "!") </span><span class="cov3" title="5">{
                        continue</span>
                }
                
                // 找到第一个 = 或 : 作为分隔符
                <span class="cov6" title="33">sepIndex := -1
                for i, char := range line </span><span class="cov10" title="291">{
                        if char == '=' || char == ':' </span><span class="cov6" title="32">{
                                sepIndex = i
                                break</span>
                        }
                }
                
                <span class="cov6" title="33">if sepIndex == -1 </span><span class="cov1" title="1">{
                        continue</span>
                }
                
                <span class="cov6" title="32">key := strings.TrimSpace(line[:sepIndex])
                value := strings.TrimSpace(line[sepIndex+1:])
                
                // 处理转义字符
                value = strings.ReplaceAll(value, "\\\\", "\\")
                value = strings.ReplaceAll(value, "\\n", "\n")
                value = strings.ReplaceAll(value, "\\t", "\t")
                value = strings.ReplaceAll(value, "\\r", "\r")
                
                props[key] = value</span>
        }
        
        <span class="cov4" title="10">if err := scanner.Err(); err != nil </span><span class="cov2" title="2">{
                return err
        }</span>
        
        <span class="cov4" title="8">return mapToStruct(props, v)</span>
}

// writeProperties 写入 .properties 文件格式
func writeProperties(writer io.Writer, v interface{}) error <span class="cov3" title="5">{
        props, err := structToMap(v)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        
        <span class="cov3" title="4">for key, value := range props </span><span class="cov4" title="9">{
                // 转义特殊字符
                valueStr := fmt.Sprintf("%v", value)
                valueStr = strings.ReplaceAll(valueStr, "\n", "\\n")
                valueStr = strings.ReplaceAll(valueStr, "\t", "\\t")
                valueStr = strings.ReplaceAll(valueStr, "\r", "\\r")
                
                _, err := fmt.Fprintf(writer, "%s=%s\n", key, valueStr)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        
        <span class="cov2" title="3">return nil</span>
}

// parseEnvFile 解析 .env 文件格式
func parseEnvFile(reader io.Reader, v interface{}) error <span class="cov4" title="9">{
        props := make(map[string]string)
        scanner := bufio.NewScanner(reader)
        
        for scanner.Scan() </span><span class="cov6" title="31">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov2" title="2">{
                        continue</span>
                }
                
                // 找到第一个 = 作为分隔符
                <span class="cov6" title="29">sepIndex := strings.Index(line, "=")
                if sepIndex == -1 </span><span class="cov1" title="1">{
                        continue</span>
                }
                
                <span class="cov6" title="28">key := strings.TrimSpace(line[:sepIndex])
                value := strings.TrimSpace(line[sepIndex+1:])
                
                // 处理引号包围的值
                if len(value) &gt;= 2 </span><span class="cov6" title="28">{
                        if (value[0] == '"' &amp;&amp; value[len(value)-1] == '"') ||
                                (value[0] == '\'' &amp;&amp; value[len(value)-1] == '\'') </span><span class="cov4" title="11">{
                                value = value[1 : len(value)-1]
                        }</span>
                }
                
                <span class="cov6" title="28">props[key] = value</span>
        }
        
        <span class="cov4" title="9">if err := scanner.Err(); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        
        <span class="cov4" title="8">return mapToStruct(props, v)</span>
}

// writeEnvFile 写入 .env 文件格式
func writeEnvFile(writer io.Writer, v interface{}) error <span class="cov3" title="5">{
        props, err := structToMap(v)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        
        <span class="cov3" title="4">for key, value := range props </span><span class="cov4" title="9">{
                valueStr := fmt.Sprintf("%v", value)
                
                // 如果值包含空格、特殊字符，则用双引号包围
                if strings.ContainsAny(valueStr, " \t\n\r\"'\\") </span><span class="cov3" title="4">{
                        valueStr = strconv.Quote(valueStr)
                }</span>
                
                <span class="cov4" title="9">_, err := fmt.Fprintf(writer, "%s=%s\n", key, valueStr)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        
        <span class="cov2" title="3">return nil</span>
}

// mapToStruct 将 map 转换为结构体
func mapToStruct(props map[string]string, v interface{}) error <span class="cov6" title="25">{
        rv := reflect.ValueOf(v)
        if rv.Kind() != reflect.Ptr || rv.Elem().Kind() != reflect.Struct </span><span class="cov2" title="2">{
                return fmt.Errorf("v must be a pointer to struct")
        }</span>
        
        <span class="cov5" title="23">rv = rv.Elem()
        rt := rv.Type()
        
        for i := 0; i &lt; rt.NumField(); i++ </span><span class="cov7" title="61">{
                field := rt.Field(i)
                fieldValue := rv.Field(i)
                
                if !fieldValue.CanSet() </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // 获取字段标签名
                <span class="cov7" title="61">tagName := getFieldTagName(field)
                if tagName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // 检查是否为嵌套结构体
                <span class="cov7" title="61">if fieldValue.Kind() == reflect.Struct </span><span class="cov5" title="15">{
                        err := parseNestedStruct(props, fieldValue, tagName)
                        if err != nil </span><span class="cov2" title="2">{
                                return err
                        }</span>
                        <span class="cov5" title="13">continue</span>
                }
                
                // 从 map 中获取值
                <span class="cov7" title="46">if propValue, exists := props[tagName]; exists </span><span class="cov7" title="46">{
                        err := setFieldValue(fieldValue, propValue)
                        if err != nil </span><span class="cov2" title="3">{
                                return fmt.Errorf("failed to set field %s: %w", field.Name, err)
                        }</span>
                }
        }
        
        <span class="cov5" title="18">return nil</span>
}

// structToMap 将结构体转换为 map
func structToMap(v interface{}) (map[string]interface{}, error) <span class="cov5" title="15">{
        result := make(map[string]interface{})
        
        rv := reflect.ValueOf(v)
        if rv.Kind() == reflect.Ptr </span><span class="cov1" title="1">{
                rv = rv.Elem()
        }</span>
        
        <span class="cov5" title="15">if rv.Kind() != reflect.Struct </span><span class="cov3" title="4">{
                return nil, fmt.Errorf("v must be a struct or pointer to struct")
        }</span>
        
        <span class="cov4" title="11">rt := rv.Type()
        
        for i := 0; i &lt; rt.NumField(); i++ </span><span class="cov5" title="18">{
                field := rt.Field(i)
                fieldValue := rv.Field(i)
                
                tagName := getFieldTagName(field)
                if tagName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov5" title="18">if fieldValue.Kind() == reflect.Struct </span><span class="cov2" title="3">{
                        // 处理嵌套结构体
                        structMapToFlat(result, fieldValue, tagName)
                        continue</span>
                }
                
                <span class="cov5" title="15">result[tagName] = fieldValue.Interface()</span>
        }
        
        <span class="cov4" title="11">return result, nil</span>
}

// getFieldTagName 获取字段的标签名
func getFieldTagName(field reflect.StructField) string <span class="cov8" title="140">{
        // 优先级: properties &gt; env &gt; json &gt; yaml &gt; toml &gt; ini
        tags := []string{"properties", "env", "json", "yaml", "toml", "ini"}
        
        for _, tag := range tags </span><span class="cov9" title="187">{
                if tagValue := field.Tag.Get(tag); tagValue != "" &amp;&amp; tagValue != "-" </span><span class="cov8" title="136">{
                        // 处理 json:",omitempty" 这样的格式
                        if commaIndex := strings.Index(tagValue, ","); commaIndex != -1 </span><span class="cov1" title="1">{
                                return tagValue[:commaIndex]
                        }</span>
                        <span class="cov8" title="135">return tagValue</span>
                }
        }
        
        <span class="cov3" title="4">return strings.ToLower(field.Name)</span>
}

// setFieldValue 设置字段值
func setFieldValue(fieldValue reflect.Value, propValue string) error <span class="cov8" title="87">{
        switch fieldValue.Kind() </span>{
        case reflect.String:<span class="cov6" title="35">
                fieldValue.SetString(propValue)</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov6" title="25">
                val, err := strconv.ParseInt(propValue, 10, 64)
                if err != nil </span><span class="cov3" title="5">{
                        return err
                }</span>
                <span class="cov5" title="20">fieldValue.SetInt(val)</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov3" title="6">
                val, err := strconv.ParseUint(propValue, 10, 64)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov3" title="5">fieldValue.SetUint(val)</span>
        case reflect.Float32, reflect.Float64:<span class="cov2" title="3">
                val, err := strconv.ParseFloat(propValue, 64)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov2" title="2">fieldValue.SetFloat(val)</span>
        case reflect.Bool:<span class="cov5" title="14">
                val, err := strconv.ParseBool(propValue)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov5" title="13">fieldValue.SetBool(val)</span>
        default:<span class="cov3" title="4">
                return fmt.Errorf("unsupported field type: %s", fieldValue.Kind())</span>
        }
        
        <span class="cov7" title="75">return nil</span>
}

// parseNestedStruct 解析嵌套结构体
func parseNestedStruct(props map[string]string, structValue reflect.Value, prefix string) error <span class="cov5" title="18">{
        structType := structValue.Type()
        
        for i := 0; i &lt; structType.NumField(); i++ </span><span class="cov6" title="38">{
                field := structType.Field(i)
                fieldValue := structValue.Field(i)
                
                if !fieldValue.CanSet() </span><span class="cov2" title="2">{
                        continue</span>
                }
                
                <span class="cov6" title="36">tagName := getFieldTagName(field)
                if tagName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov6" title="36">fullKey := prefix + "." + tagName
                
                if fieldValue.Kind() == reflect.Struct </span><span class="cov1" title="1">{
                        err := parseNestedStruct(props, fieldValue, fullKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov6" title="35"> if propValue, exists := props[fullKey]; exists </span><span class="cov5" title="21">{
                        err := setFieldValue(fieldValue, propValue)
                        if err != nil </span><span class="cov2" title="3">{
                                return fmt.Errorf("failed to set nested field %s: %w", field.Name, err)
                        }</span>
                }
        }
        
        <span class="cov5" title="15">return nil</span>
}

// structMapToFlat 将嵌套结构体展平到 map 中
func structMapToFlat(result map[string]interface{}, structValue reflect.Value, prefix string) <span class="cov4" title="8">{
        structType := structValue.Type()
        
        for i := 0; i &lt; structType.NumField(); i++ </span><span class="cov5" title="16">{
                field := structType.Field(i)
                fieldValue := structValue.Field(i)
                
                tagName := getFieldTagName(field)
                if tagName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov5" title="16">fullKey := prefix + "." + tagName
                
                if fieldValue.Kind() == reflect.Struct </span><span class="cov2" title="2">{
                        structMapToFlat(result, fieldValue, fullKey)
                }</span> else<span class="cov5" title="14"> {
                        result[fullKey] = fieldValue.Interface()
                }</span>
        }
}

// writeHCLFile 写入 HCL 文件格式
func writeHCLFile(writer io.Writer, v interface{}) error <span class="cov3" title="4">{
        hclContent, err := structToHCL(v, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov3" title="4">_, err = writer.Write([]byte(hclContent))
        return err</span>
}

// structToHCL 将结构体转换为 HCL 格式字符串
func structToHCL(v interface{}, indent string) (string, error) <span class="cov4" title="7">{
        rv := reflect.ValueOf(v)
        if rv.Kind() == reflect.Ptr </span><span class="cov1" title="1">{
                rv = rv.Elem()
        }</span>
        
        <span class="cov4" title="7">if rv.Kind() != reflect.Struct </span><span class="cov2" title="3">{
                return fmt.Sprintf("%v", v), nil
        }</span>
        
        <span class="cov3" title="4">rt := rv.Type()
        var result strings.Builder
        
        for i := 0; i &lt; rt.NumField(); i++ </span><span class="cov4" title="9">{
                field := rt.Field(i)
                fieldValue := rv.Field(i)
                
                tagName := getHCLFieldTagName(field)
                if tagName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov4" title="9">if fieldValue.Kind() == reflect.Struct </span><span class="cov1" title="1">{
                        nestedContent, err := structToHCL(fieldValue.Interface(), indent+"  ")
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov1" title="1">result.WriteString(fmt.Sprintf("%s%s {\n%s%s}\n", indent, tagName, nestedContent, indent))</span>
                } else<span class="cov4" title="8"> {
                        value := formatHCLValue(fieldValue.Interface())
                        result.WriteString(fmt.Sprintf("%s%s = %s\n", indent, tagName, value))
                }</span>
        }
        
        <span class="cov3" title="4">return result.String(), nil</span>
}

// getHCLFieldTagName 获取 HCL 字段的标签名
func getHCLFieldTagName(field reflect.StructField) string <span class="cov5" title="15">{
        // 优先级: hcl &gt; json &gt; yaml &gt; toml &gt; ini
        tags := []string{"hcl", "json", "yaml", "toml", "ini"}
        
        for _, tag := range tags </span><span class="cov6" title="33">{
                if tagValue := field.Tag.Get(tag); tagValue != "" &amp;&amp; tagValue != "-" </span><span class="cov5" title="13">{
                        if commaIndex := strings.Index(tagValue, ","); commaIndex != -1 </span><span class="cov1" title="1">{
                                return tagValue[:commaIndex]
                        }</span>
                        <span class="cov4" title="12">return tagValue</span>
                }
        }
        
        <span class="cov2" title="2">return strings.ToLower(field.Name)</span>
}

// formatHCLValue 格式化 HCL 值
func formatHCLValue(value interface{}) string <span class="cov6" title="24">{
        switch v := value.(type) </span>{
        case string:<span class="cov3" title="6">
                return fmt.Sprintf(`"%s"`, v)</span>
        case bool:<span class="cov2" title="3">
                return fmt.Sprintf("%t", v)</span>
        case int, int8, int16, int32, int64:<span class="cov3" title="6">
                return fmt.Sprintf("%d", v)</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov3" title="5">
                return fmt.Sprintf("%d", v)</span>
        case float32, float64:<span class="cov2" title="2">
                return fmt.Sprintf("%g", v)</span>
        default:<span class="cov2" title="2">
                return fmt.Sprintf(`"%v"`, v)</span>
        }
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package cryptox

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "errors"
        "io"
)

// Global variables for dependency injection during testing
var (
        newCipherFunc = aes.NewCipher
        newGCMFunc    = cipher.NewGCM
        randReader    = rand.Reader
)

// Encrypt 使用 AES-256 在 GCM 模式下加密明文。
func Encrypt(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1116">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1108">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1107">gcm, err := newGCMFunc(block)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1106">nonce := make([]byte, gcm.NonceSize())
        _, err = io.ReadFull(randReader, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1105">ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
        return ciphertext, nil</span>
}

// Decrypt 使用 AES-256 在 GCM 模式下解密密文。
func Decrypt(key, ciphertext []byte) ([]byte, error) <span class="cov3" title="10">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov3" title="8">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="7">gcm, err := newGCMFunc(block)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="6">if len(ciphertext) &lt; gcm.NonceSize() </span><span class="cov1" title="2">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov2" title="4">nonce, ciphertext := ciphertext[:gcm.NonceSize()], ciphertext[gcm.NonceSize():]
        plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="3">return plaintext, nil</span>
}

// EncryptECB 使用 AES-256 在 ECB 模式下加密明文。
// 警告：ECB模式在密码学上是不安全的，相同的明文块会产生相同的密文块。
// 建议使用GCM、CBC或CFB模式以获得更好的安全性。
func EncryptECB(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1014">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1006">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1005">plaintext = padPKCS7(plaintext, block.BlockSize())
        ciphertext := make([]byte, len(plaintext))
        for i := 0; i &lt; len(plaintext); i += block.BlockSize() </span><span class="cov9" title="2031">{
                block.Encrypt(ciphertext[i:i+block.BlockSize()], plaintext[i:i+block.BlockSize()])
        }</span>
        <span class="cov9" title="1005">return ciphertext, nil</span>
}

// DecryptECB 使用 AES-256 在 ECB 模式下解密密文。
// 警告：ECB模式在密码学上是不安全的，相同的明文块会产生相同的密文块。
// 建议使用GCM、CBC或CFB模式以获得更好的安全性。
func DecryptECB(key, ciphertext []byte) ([]byte, error) <span class="cov3" title="7">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov2" title="5">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="4">plaintext := make([]byte, len(ciphertext))
        for i := 0; i &lt; len(ciphertext); i += block.BlockSize() </span><span class="cov9" title="1028">{
                block.Decrypt(plaintext[i:i+block.BlockSize()], ciphertext[i:i+block.BlockSize()])
        }</span>
        <span class="cov2" title="4">return unpadPKCS7(plaintext)</span>
}

// padPKCS7 使用 PKCS#7 填充方式对数据进行填充。
func padPKCS7(data []byte, blockSize int) []byte <span class="cov10" title="2144">{
        padding := blockSize - len(data)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(data, padtext...)
}</span>

// unpadPKCS7 使用 PKCS#7 填充方式对数据进行去除填充。
func unpadPKCS7(data []byte) ([]byte, error) <span class="cov5" title="42">{
        length := len(data)
        if length == 0 </span><span class="cov1" title="1">{
                return nil, errors.New("data is empty")
        }</span>
        <span class="cov5" title="41">unpadding := int(data[length-1])
        if unpadding &gt; length || unpadding == 0 </span><span class="cov3" title="9">{
                return nil, errors.New("invalid padding")
        }</span>
        <span class="cov5" title="32">paddingData := data[length-unpadding:]
        for _, b := range paddingData </span><span class="cov7" title="210">{
                if int(b) != unpadding </span><span class="cov1" title="2">{
                        return nil, errors.New("invalid padding data")
                }</span>
        }
        <span class="cov4" title="30">return data[:(length - unpadding)], nil</span>
}

// EncryptCBC 使用 AES-256 在 CBC 模式下加密明文。
func EncryptCBC(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1113">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1105">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1104">plaintext = padPKCS7(plaintext, block.BlockSize())
        ciphertext := make([]byte, aes.BlockSize+len(plaintext))
        iv := ciphertext[:aes.BlockSize]
        _, err = io.ReadFull(randReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1103">mode := cipher.NewCBCEncrypter(block, iv)
        mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// DecryptCBC 使用 AES-256 在 CBC 模式下解密密文。
func DecryptCBC(key, ciphertext []byte) ([]byte, error) <span class="cov3" title="8">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov3" title="6">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="5">if len(ciphertext) &lt; aes.BlockSize </span><span class="cov2" title="3">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov1" title="2">iv := ciphertext[:aes.BlockSize]
        ciphertext = ciphertext[aes.BlockSize:]

        mode := cipher.NewCBCDecrypter(block, iv)
        mode.CryptBlocks(ciphertext, ciphertext)

        plaintext, err := unpadPKCS7(ciphertext)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return plaintext, nil</span>
}

// EncryptCFB 使用 AES-256 在 CFB 模式下加密明文。
func EncryptCFB(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1113">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1105">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1104">ciphertext := make([]byte, aes.BlockSize+len(plaintext))
        iv := ciphertext[:aes.BlockSize]
        _, err = io.ReadFull(randReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1103">stream := cipher.NewCFBEncrypter(block, iv)
        stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// DecryptCFB 使用 AES-256 在 CFB 模式下解密密文。
func DecryptCFB(key, ciphertext []byte) ([]byte, error) <span class="cov3" title="7">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov2" title="5">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="4">if len(ciphertext) &lt; aes.BlockSize </span><span class="cov2" title="3">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov1" title="1">iv := ciphertext[:aes.BlockSize]
        ciphertext = ciphertext[aes.BlockSize:]

        stream := cipher.NewCFBDecrypter(block, iv)
        stream.XORKeyStream(ciphertext, ciphertext)
        return ciphertext, nil</span>
}

// EncryptCTR 使用 AES-256 在 CTR 模式下加密明文。
func EncryptCTR(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1113">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1105">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1104">ciphertext := make([]byte, aes.BlockSize+len(plaintext))
        iv := ciphertext[:aes.BlockSize]
        _, err = io.ReadFull(randReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1103">stream := cipher.NewCTR(block, iv)
        stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// DecryptCTR 使用 AES-256 在 CTR 模式下解密密文。
func DecryptCTR(key, ciphertext []byte) ([]byte, error) <span class="cov3" title="7">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov2" title="5">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="4">if len(ciphertext) &lt; aes.BlockSize </span><span class="cov2" title="3">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov1" title="1">iv := ciphertext[:aes.BlockSize]
        ciphertext = ciphertext[aes.BlockSize:]

        stream := cipher.NewCTR(block, iv)
        stream.XORKeyStream(ciphertext, ciphertext)
        return ciphertext, nil</span>
}

// EncryptOFB 使用 AES-256 在 OFB 模式下加密明文。
func EncryptOFB(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1120">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1112">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1111">ciphertext := make([]byte, aes.BlockSize+len(plaintext))
        iv := ciphertext[:aes.BlockSize]
        _, err = io.ReadFull(randReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1110">stream := cipher.NewOFB(block, iv)
        stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// DecryptOFB 使用 AES-256 在 OFB 模式下解密密文。
func DecryptOFB(key, ciphertext []byte) ([]byte, error) <span class="cov4" title="14">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov3" title="12">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="11">if len(ciphertext) &lt; aes.BlockSize </span><span class="cov1" title="2">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov3" title="9">iv := ciphertext[:aes.BlockSize]
        ciphertext = ciphertext[aes.BlockSize:]

        stream := cipher.NewOFB(block, iv)
        stream.XORKeyStream(ciphertext, ciphertext)
        return ciphertext, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package cryptox

import (
        "crypto/cipher"
        "crypto/rand"
        "errors"
        "io"

        "golang.org/x/crypto/blowfish"
)

// Global variables for dependency injection during testing
var (
        blowfishNewCipher  func([]byte) (*blowfish.Cipher, error) = blowfish.NewCipher
        blowfishRandReader = rand.Reader
)

// BlowfishEncryptECB 使用 Blowfish 在 ECB 模式下加密明文
// 警告：ECB 模式在密码学上是不安全的，相同的明文块会产生相同的密文块。
func BlowfishEncryptECB(key, plaintext []byte) ([]byte, error) <span class="cov5" title="11">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov5" title="9">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="8">plaintext = padPKCS7(plaintext, blowfish.BlockSize)
        ciphertext := make([]byte, len(plaintext))
        for i := 0; i &lt; len(plaintext); i += blowfish.BlockSize </span><span class="cov10" title="130">{
                block.Encrypt(ciphertext[i:i+blowfish.BlockSize], plaintext[i:i+blowfish.BlockSize])
        }</span>
        <span class="cov4" title="8">return ciphertext, nil</span>
}

// BlowfishDecryptECB 使用 Blowfish 在 ECB 模式下解密密文
// 警告：ECB 模式在密码学上是不安全的，相同的明文块会产生相同的密文块。
func BlowfishDecryptECB(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="12">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov5" title="10">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="9">if len(ciphertext)%blowfish.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov4" title="8">plaintext := make([]byte, len(ciphertext))
        for i := 0; i &lt; len(ciphertext); i += blowfish.BlockSize </span><span class="cov10" title="130">{
                block.Decrypt(plaintext[i:i+blowfish.BlockSize], ciphertext[i:i+blowfish.BlockSize])
        }</span>
        <span class="cov4" title="8">return unpadPKCS7(plaintext)</span>
}

// BlowfishEncryptCBC 使用 Blowfish 在 CBC 模式下加密明文
func BlowfishEncryptCBC(key, plaintext []byte) ([]byte, error) <span class="cov5" title="12">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov5" title="10">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="9">plaintext = padPKCS7(plaintext, blowfish.BlockSize)
        ciphertext := make([]byte, blowfish.BlockSize+len(plaintext))
        iv := ciphertext[:blowfish.BlockSize]
        _, err = io.ReadFull(blowfishRandReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="8">mode := cipher.NewCBCEncrypter(block, iv)
        mode.CryptBlocks(ciphertext[blowfish.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// BlowfishDecryptCBC 使用 Blowfish 在 CBC 模式下解密密文
func BlowfishDecryptCBC(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="13">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov5" title="11">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="10">if len(ciphertext) &lt; blowfish.BlockSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov5" title="9">iv := ciphertext[:blowfish.BlockSize]
        ciphertext = ciphertext[blowfish.BlockSize:]

        if len(ciphertext)%blowfish.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov4" title="8">mode := cipher.NewCBCDecrypter(block, iv)
        mode.CryptBlocks(ciphertext, ciphertext)

        return unpadPKCS7(ciphertext)</span>
}

// BlowfishEncryptCFB 使用 Blowfish 在 CFB 模式下加密明文
func BlowfishEncryptCFB(key, plaintext []byte) ([]byte, error) <span class="cov5" title="10">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov4" title="8">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="7">ciphertext := make([]byte, blowfish.BlockSize+len(plaintext))
        iv := ciphertext[:blowfish.BlockSize]
        _, err = io.ReadFull(blowfishRandReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="6">stream := cipher.NewCFBEncrypter(block, iv)
        stream.XORKeyStream(ciphertext[blowfish.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// BlowfishDecryptCFB 使用 Blowfish 在 CFB 模式下解密密文
func BlowfishDecryptCFB(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="10">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov4" title="8">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="7">if len(ciphertext) &lt; blowfish.BlockSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov4" title="6">iv := ciphertext[:blowfish.BlockSize]
        ciphertext = ciphertext[blowfish.BlockSize:]

        stream := cipher.NewCFBDecrypter(block, iv)
        stream.XORKeyStream(ciphertext, ciphertext)
        return ciphertext, nil</span>
}

// BlowfishEncryptOFB 使用 Blowfish 在 OFB 模式下加密明文
func BlowfishEncryptOFB(key, plaintext []byte) ([]byte, error) <span class="cov5" title="10">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov4" title="8">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="7">ciphertext := make([]byte, blowfish.BlockSize+len(plaintext))
        iv := ciphertext[:blowfish.BlockSize]
        _, err = io.ReadFull(blowfishRandReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="6">stream := cipher.NewOFB(block, iv)
        stream.XORKeyStream(ciphertext[blowfish.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// BlowfishDecryptOFB 使用 Blowfish 在 OFB 模式下解密密文
func BlowfishDecryptOFB(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="10">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov4" title="8">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="7">if len(ciphertext) &lt; blowfish.BlockSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov4" title="6">iv := ciphertext[:blowfish.BlockSize]
        ciphertext = ciphertext[blowfish.BlockSize:]

        stream := cipher.NewOFB(block, iv)
        stream.XORKeyStream(ciphertext, ciphertext)
        return ciphertext, nil</span>
}</pre>
		
		<pre class="file" id="file89" style="display: none">package cryptox

import (
        "crypto/rand"
        "errors"
        "io"

        "golang.org/x/crypto/chacha20"
        "golang.org/x/crypto/chacha20poly1305"
)

// Global variables for dependency injection during testing
var (
        chacha20NewUnauthenticatedCipher = chacha20.NewUnauthenticatedCipher
        chacha20poly1305New              = chacha20poly1305.New
        chacha20RandReader               = rand.Reader
)

// ChaCha20Encrypt 使用 ChaCha20 流密码加密明文
func ChaCha20Encrypt(key, plaintext []byte) ([]byte, error) <span class="cov8" title="6">{
        if len(key) != chacha20.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20")
        }</span>

        // Generate random nonce
        <span class="cov7" title="5">nonce := make([]byte, chacha20.NonceSize)
        _, err := io.ReadFull(chacha20RandReader, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="4">cipher, err := chacha20NewUnauthenticatedCipher(key, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="3">ciphertext := make([]byte, chacha20.NonceSize+len(plaintext))
        copy(ciphertext[:chacha20.NonceSize], nonce)
        
        cipher.XORKeyStream(ciphertext[chacha20.NonceSize:], plaintext)
        return ciphertext, nil</span>
}

// ChaCha20Decrypt 使用 ChaCha20 流密码解密密文
func ChaCha20Decrypt(key, ciphertext []byte) ([]byte, error) <span class="cov8" title="6">{
        if len(key) != chacha20.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20")
        }</span>

        <span class="cov7" title="5">if len(ciphertext) &lt; chacha20.NonceSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov6" title="4">nonce := ciphertext[:chacha20.NonceSize]
        ciphertext = ciphertext[chacha20.NonceSize:]

        cipher, err := chacha20NewUnauthenticatedCipher(key, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="3">plaintext := make([]byte, len(ciphertext))
        cipher.XORKeyStream(plaintext, ciphertext)
        return plaintext, nil</span>
}

// ChaCha20Poly1305Encrypt 使用 ChaCha20-Poly1305 AEAD 加密明文
func ChaCha20Poly1305Encrypt(key, plaintext []byte) ([]byte, error) <span class="cov9" title="8">{
        if len(key) != chacha20poly1305.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20-Poly1305")
        }</span>

        <span class="cov8" title="7">aead, err := chacha20poly1305New(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Generate random nonce
        <span class="cov8" title="6">nonce := make([]byte, aead.NonceSize())
        _, err = io.ReadFull(chacha20RandReader, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Seal encrypts and authenticates plaintext
        <span class="cov7" title="5">ciphertext := aead.Seal(nonce, nonce, plaintext, nil)
        return ciphertext, nil</span>
}

// ChaCha20Poly1305Decrypt 使用 ChaCha20-Poly1305 AEAD 解密密文
func ChaCha20Poly1305Decrypt(key, ciphertext []byte) ([]byte, error) <span class="cov9" title="8">{
        if len(key) != chacha20poly1305.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20-Poly1305")
        }</span>

        <span class="cov8" title="7">aead, err := chacha20poly1305New(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="6">if len(ciphertext) &lt; aead.NonceSize() </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov7" title="5">nonce := ciphertext[:aead.NonceSize()]
        ciphertext = ciphertext[aead.NonceSize():]

        // Open decrypts and verifies ciphertext
        plaintext, err := aead.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="3">return plaintext, nil</span>
}

// ChaCha20WithNonce 使用指定的 nonce 进行 ChaCha20 加密（用于测试或特殊需求）
func ChaCha20WithNonce(key, nonce, plaintext []byte) ([]byte, error) <span class="cov10" title="10">{
        if len(key) != chacha20.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20")
        }</span>

        <span class="cov9" title="9">if len(nonce) != chacha20.NonceSize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid nonce length: must be 12 bytes for ChaCha20")
        }</span>

        <span class="cov9" title="8">cipher, err := chacha20NewUnauthenticatedCipher(key, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="7">ciphertext := make([]byte, len(plaintext))
        cipher.XORKeyStream(ciphertext, plaintext)
        return ciphertext, nil</span>
}

// ChaCha20Poly1305WithNonce 使用指定的 nonce 进行 ChaCha20-Poly1305 加密（用于测试或特殊需求）
func ChaCha20Poly1305WithNonce(key, nonce, plaintext []byte) ([]byte, error) <span class="cov6" title="4">{
        if len(key) != chacha20poly1305.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20-Poly1305")
        }</span>

        <span class="cov5" title="3">aead, err := chacha20poly1305New(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">if len(nonce) != aead.NonceSize() </span><span class="cov1" title="1">{
                return nil, errors.New("invalid nonce length: must be 12 bytes for ChaCha20-Poly1305")
        }</span>

        // Seal encrypts and authenticates plaintext
        <span class="cov1" title="1">ciphertext := aead.Seal(nil, nonce, plaintext, nil)
        return ciphertext, nil</span>
}

// ChaCha20Poly1305WithNonceDecrypt 使用指定的 nonce 进行 ChaCha20-Poly1305 解密
func ChaCha20Poly1305WithNonceDecrypt(key, nonce, ciphertext []byte) ([]byte, error) <span class="cov8" title="7">{
        if len(key) != chacha20poly1305.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20-Poly1305")
        }</span>

        <span class="cov8" title="6">aead, err := chacha20poly1305New(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="5">if len(nonce) != aead.NonceSize() </span><span class="cov1" title="1">{
                return nil, errors.New("invalid nonce length: must be 12 bytes for ChaCha20-Poly1305")
        }</span>

        // Open decrypts and verifies ciphertext
        <span class="cov6" title="4">plaintext, err := aead.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov5" title="3">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return plaintext, nil</span>
}</pre>
		
		<pre class="file" id="file90" style="display: none">package cryptox

import (
        "crypto/cipher"
        "crypto/des"
        "crypto/rand"
        "errors"
        "io"
)

// Global variables for dependency injection during testing
var (
        desNewCipher    = des.NewCipher
        desNewTripleDES = des.NewTripleDESCipher
        desRandReader   = rand.Reader
)

// DESEncryptECB 使用 DES 在 ECB 模式下加密明文
// 警告：DES 已被认为是不安全的，仅用于兼容性目的。推荐使用 AES。
// 警告：ECB 模式在密码学上是不安全的，相同的明文块会产生相同的密文块。
func DESEncryptECB(key, plaintext []byte) ([]byte, error) <span class="cov4" title="6">{
        if len(key) != 8 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 8 bytes for DES")
        }</span>

        <span class="cov4" title="5">block, err := desNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="4">plaintext = padPKCS7(plaintext, des.BlockSize)
        ciphertext := make([]byte, len(plaintext))
        for i := 0; i &lt; len(plaintext); i += des.BlockSize </span><span class="cov10" title="100">{
                block.Encrypt(ciphertext[i:i+des.BlockSize], plaintext[i:i+des.BlockSize])
        }</span>
        <span class="cov3" title="4">return ciphertext, nil</span>
}

// DESDecryptECB 使用 DES 在 ECB 模式下解密密文
// 警告：DES 已被认为是不安全的，仅用于兼容性目的。推荐使用 AES。
// 警告：ECB 模式在密码学上是不安全的，相同的明文块会产生相同的密文块。
func DESDecryptECB(key, ciphertext []byte) ([]byte, error) <span class="cov4" title="7">{
        if len(key) != 8 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 8 bytes for DES")
        }</span>

        <span class="cov4" title="6">block, err := desNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="5">if len(ciphertext)%des.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov3" title="4">plaintext := make([]byte, len(ciphertext))
        for i := 0; i &lt; len(ciphertext); i += des.BlockSize </span><span class="cov10" title="100">{
                block.Decrypt(plaintext[i:i+des.BlockSize], ciphertext[i:i+des.BlockSize])
        }</span>
        <span class="cov3" title="4">return unpadPKCS7(plaintext)</span>
}

// DESEncryptCBC 使用 DES 在 CBC 模式下加密明文
// 警告：DES 已被认为是不安全的，仅用于兼容性目的。推荐使用 AES。
func DESEncryptCBC(key, plaintext []byte) ([]byte, error) <span class="cov4" title="7">{
        if len(key) != 8 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 8 bytes for DES")
        }</span>

        <span class="cov4" title="6">block, err := desNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="5">plaintext = padPKCS7(plaintext, des.BlockSize)
        ciphertext := make([]byte, des.BlockSize+len(plaintext))
        iv := ciphertext[:des.BlockSize]
        _, err = io.ReadFull(desRandReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="4">mode := cipher.NewCBCEncrypter(block, iv)
        mode.CryptBlocks(ciphertext[des.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// DESDecryptCBC 使用 DES 在 CBC 模式下解密密文
// 警告：DES 已被认为是不安全的，仅用于兼容性目的。推荐使用 AES。
func DESDecryptCBC(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="8">{
        if len(key) != 8 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 8 bytes for DES")
        }</span>

        <span class="cov4" title="7">block, err := desNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="6">if len(ciphertext) &lt; des.BlockSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov4" title="5">iv := ciphertext[:des.BlockSize]
        ciphertext = ciphertext[des.BlockSize:]

        if len(ciphertext)%des.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov3" title="4">mode := cipher.NewCBCDecrypter(block, iv)
        mode.CryptBlocks(ciphertext, ciphertext)

        return unpadPKCS7(ciphertext)</span>
}

// TripleDESEncryptECB 使用 3DES 在 ECB 模式下加密明文
// 警告：ECB 模式在密码学上是不安全的，相同的明文块会产生相同的密文块。
func TripleDESEncryptECB(key, plaintext []byte) ([]byte, error) <span class="cov4" title="6">{
        if len(key) != 24 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 24 bytes for 3DES")
        }</span>

        <span class="cov4" title="5">block, err := desNewTripleDES(key)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov3" title="3">plaintext = padPKCS7(plaintext, des.BlockSize)
        ciphertext := make([]byte, len(plaintext))
        for i := 0; i &lt; len(plaintext); i += des.BlockSize </span><span class="cov5" title="8">{
                block.Encrypt(ciphertext[i:i+des.BlockSize], plaintext[i:i+des.BlockSize])
        }</span>
        <span class="cov3" title="3">return ciphertext, nil</span>
}

// TripleDESDecryptECB 使用 3DES 在 ECB 模式下解密密文
// 警告：ECB 模式在密码学上是不安全的，相同的明文块会产生相同的密文块。
func TripleDESDecryptECB(key, ciphertext []byte) ([]byte, error) <span class="cov4" title="7">{
        if len(key) != 24 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 24 bytes for 3DES")
        }</span>

        <span class="cov4" title="6">block, err := desNewTripleDES(key)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov3" title="4">if len(ciphertext)%des.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov3" title="3">plaintext := make([]byte, len(ciphertext))
        for i := 0; i &lt; len(ciphertext); i += des.BlockSize </span><span class="cov5" title="8">{
                block.Decrypt(plaintext[i:i+des.BlockSize], ciphertext[i:i+des.BlockSize])
        }</span>
        <span class="cov3" title="3">return unpadPKCS7(plaintext)</span>
}

// TripleDESEncryptCBC 使用 3DES 在 CBC 模式下加密明文
func TripleDESEncryptCBC(key, plaintext []byte) ([]byte, error) <span class="cov4" title="7">{
        if len(key) != 24 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 24 bytes for 3DES")
        }</span>

        <span class="cov4" title="6">block, err := desNewTripleDES(key)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov3" title="4">plaintext = padPKCS7(plaintext, des.BlockSize)
        ciphertext := make([]byte, des.BlockSize+len(plaintext))
        iv := ciphertext[:des.BlockSize]
        _, err = io.ReadFull(desRandReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="3">mode := cipher.NewCBCEncrypter(block, iv)
        mode.CryptBlocks(ciphertext[des.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// TripleDESDecryptCBC 使用 3DES 在 CBC 模式下解密密文
func TripleDESDecryptCBC(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="8">{
        if len(key) != 24 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 24 bytes for 3DES")
        }</span>

        <span class="cov4" title="7">block, err := desNewTripleDES(key)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="5">if len(ciphertext) &lt; des.BlockSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov3" title="4">iv := ciphertext[:des.BlockSize]
        ciphertext = ciphertext[des.BlockSize:]

        if len(ciphertext)%des.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov3" title="3">mode := cipher.NewCBCDecrypter(block, iv)
        mode.CryptBlocks(ciphertext, ciphertext)

        return unpadPKCS7(ciphertext)</span>
}</pre>
		
		<pre class="file" id="file91" style="display: none">package cryptox

import (
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/sha256"
        "errors"
        "fmt"
        "hash"
        "math/big"
)

// Global variables for dependency injection during testing
var (
        ecdhRandReader = rand.Reader
)

// ECDHKeyPair represents an ECDH key pair (same as ECDSA but used for key exchange)
type ECDHKeyPair struct {
        PrivateKey *ecdsa.PrivateKey
        PublicKey  *ecdsa.PublicKey
}

// GenerateECDHKey 生成 ECDH 密钥对
func GenerateECDHKey(curve elliptic.Curve) (*ECDHKeyPair, error) <span class="cov10" title="636">{
        if curve == nil </span><span class="cov1" title="1">{
                return nil, errors.New("curve cannot be nil")
        }</span>

        <span class="cov9" title="635">privateKey, err := ecdsa.GenerateKey(curve, ecdhRandReader)
        if err != nil </span><span class="cov2" title="4">{
                return nil, fmt.Errorf("failed to generate ECDH key: %w", err)
        }</span>

        <span class="cov9" title="631">return &amp;ECDHKeyPair{
                PrivateKey: privateKey,
                PublicKey:  &amp;privateKey.PublicKey,
        }, nil</span>
}

// GenerateECDHP256Key 生成 P-256 ECDH 密钥对
func GenerateECDHP256Key() (*ECDHKeyPair, error) <span class="cov9" title="559">{
        return GenerateECDHKey(elliptic.P256())
}</span>

// GenerateECDHP384Key 生成 P-384 ECDH 密钥对
func GenerateECDHP384Key() (*ECDHKeyPair, error) <span class="cov6" title="60">{
        return GenerateECDHKey(elliptic.P384())
}</span>

// GenerateECDHP521Key 生成 P-521 ECDH 密钥对
func GenerateECDHP521Key() (*ECDHKeyPair, error) <span class="cov2" title="3">{
        return GenerateECDHKey(elliptic.P521())
}</span>

// ECDHComputeShared 计算 ECDH 共享密钥
func ECDHComputeShared(privateKey *ecdsa.PrivateKey, publicKey *ecdsa.PublicKey) ([]byte, error) <span class="cov9" title="572">{
        if privateKey == nil </span><span class="cov1" title="2">{
                return nil, errors.New("private key cannot be nil")
        }</span>
        <span class="cov9" title="570">if publicKey == nil </span><span class="cov1" title="2">{
                return nil, errors.New("public key cannot be nil")
        }</span>

        // 验证公钥是否在曲线上
        <span class="cov9" title="568">if !privateKey.Curve.IsOnCurve(publicKey.X, publicKey.Y) </span><span class="cov4" title="14">{
                return nil, errors.New("public key is not on the curve")
        }</span>

        // 验证曲线是否匹配
        <span class="cov9" title="554">if privateKey.Curve != publicKey.Curve </span><span class="cov1" title="1">{
                return nil, errors.New("curve mismatch between private and public keys")
        }</span>

        // 计算共享点
        <span class="cov9" title="553">x, _ := privateKey.Curve.ScalarMult(publicKey.X, publicKey.Y, privateKey.D.Bytes())

        // 返回 x 坐标作为共享密钥
        return x.Bytes(), nil</span>
}

// ECDHComputeSharedWithKDF 计算 ECDH 共享密钥并使用 KDF 派生最终密钥
func ECDHComputeSharedWithKDF(privateKey *ecdsa.PrivateKey, publicKey *ecdsa.PublicKey, keyLength int, kdf func() hash.Hash) ([]byte, error) <span class="cov6" title="43">{
        if keyLength &lt;= 0 </span><span class="cov2" title="3">{
                return nil, errors.New("key length must be greater than 0")
        }</span>
        <span class="cov6" title="40">if kdf == nil </span><span class="cov1" title="2">{
                return nil, errors.New("KDF function cannot be nil")
        }</span>

        <span class="cov6" title="38">sharedSecret, err := ECDHComputeShared(privateKey, publicKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // 使用简单的 KDF (Hash-based)
        <span class="cov6" title="37">h := kdf()
        h.Write(sharedSecret)
        derivedKey := h.Sum(nil)

        // 如果需要的密钥长度超过哈希输出长度，截断或重复
        if len(derivedKey) &gt;= keyLength </span><span class="cov5" title="22">{
                return derivedKey[:keyLength], nil
        }</span>

        // 如果需要更长的密钥，使用计数器模式扩展
        <span class="cov4" title="15">result := make([]byte, 0, keyLength)
        counter := uint32(0)
        
        for len(result) &lt; keyLength </span><span class="cov6" title="56">{
                h := kdf()
                h.Write(sharedSecret)
                h.Write([]byte{byte(counter &gt;&gt; 24), byte(counter &gt;&gt; 16), byte(counter &gt;&gt; 8), byte(counter)})
                block := h.Sum(nil)
                result = append(result, block...)
                counter++
        }</span>

        <span class="cov4" title="15">return result[:keyLength], nil</span>
}

// ECDHComputeSharedSHA256 使用 SHA256 KDF 计算 ECDH 共享密钥
func ECDHComputeSharedSHA256(privateKey *ecdsa.PrivateKey, publicKey *ecdsa.PublicKey, keyLength int) ([]byte, error) <span class="cov3" title="7">{
        return ECDHComputeSharedWithKDF(privateKey, publicKey, keyLength, sha256.New)
}</span>

// ECDHKeyExchange 执行完整的 ECDH 密钥交换
func ECDHKeyExchange(alicePrivateKey *ecdsa.PrivateKey, bobPublicKey *ecdsa.PublicKey, keyLength int) ([]byte, error) <span class="cov3" title="5">{
        return ECDHComputeSharedSHA256(alicePrivateKey, bobPublicKey, keyLength)
}</span>

// ValidateECDHKeyPair 验证 ECDH 密钥对的有效性
func ValidateECDHKeyPair(keyPair *ECDHKeyPair) error <span class="cov5" title="19">{
        if keyPair == nil </span><span class="cov1" title="2">{
                return errors.New("key pair cannot be nil")
        }</span>
        <span class="cov4" title="17">if keyPair.PrivateKey == nil </span><span class="cov1" title="2">{
                return errors.New("private key cannot be nil")
        }</span>
        <span class="cov4" title="15">if keyPair.PublicKey == nil </span><span class="cov1" title="2">{
                return errors.New("public key cannot be nil")
        }</span>

        // 验证公钥是否在曲线上
        <span class="cov4" title="13">if !keyPair.PrivateKey.Curve.IsOnCurve(keyPair.PublicKey.X, keyPair.PublicKey.Y) </span><span class="cov2" title="3">{
                return errors.New("public key is not on the curve")
        }</span>

        // 验证曲线是否匹配
        <span class="cov4" title="10">if keyPair.PrivateKey.Curve != keyPair.PublicKey.Curve </span><span class="cov1" title="1">{
                return errors.New("curve mismatch between private and public keys")
        }</span>

        // 验证公钥是否与私钥匹配
        <span class="cov4" title="9">expectedX, expectedY := keyPair.PrivateKey.Curve.ScalarBaseMult(keyPair.PrivateKey.D.Bytes())
        if keyPair.PublicKey.X.Cmp(expectedX) != 0 || keyPair.PublicKey.Y.Cmp(expectedY) != 0 </span><span class="cov2" title="3">{
                return errors.New("public key does not match private key")
        }</span>

        <span class="cov3" title="6">return nil</span>
}

// ECDHPublicKeyFromCoordinates 从 x, y 坐标创建 ECDH 公钥
func ECDHPublicKeyFromCoordinates(curve elliptic.Curve, x, y *big.Int) (*ecdsa.PublicKey, error) <span class="cov3" title="6">{
        if curve == nil </span><span class="cov1" title="1">{
                return nil, errors.New("curve cannot be nil")
        }</span>
        <span class="cov3" title="5">if x == nil || y == nil </span><span class="cov1" title="2">{
                return nil, errors.New("coordinates cannot be nil")
        }</span>

        // 验证点是否在曲线上
        <span class="cov2" title="3">if !curve.IsOnCurve(x, y) </span><span class="cov1" title="1">{
                return nil, errors.New("point is not on the curve")
        }</span>

        <span class="cov1" title="2">return &amp;ecdsa.PublicKey{
                Curve: curve,
                X:     new(big.Int).Set(x),
                Y:     new(big.Int).Set(y),
        }, nil</span>
}

// ECDHPublicKeyToCoordinates 将 ECDH 公钥转换为 x, y 坐标
func ECDHPublicKeyToCoordinates(publicKey *ecdsa.PublicKey) (x, y *big.Int, err error) <span class="cov2" title="3">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return nil, nil, errors.New("public key cannot be nil")
        }</span>

        <span class="cov1" title="2">return new(big.Int).Set(publicKey.X), new(big.Int).Set(publicKey.Y), nil</span>
}

// ECDHSharedSecretTest 测试两个密钥对是否能生成相同的共享密钥（用于测试）
func ECDHSharedSecretTest(keyPair1, keyPair2 *ECDHKeyPair) (bool, error) <span class="cov5" title="31">{
        if keyPair1 == nil || keyPair2 == nil </span><span class="cov2" title="4">{
                return false, errors.New("key pairs cannot be nil")
        }</span>

        // Alice 使用她的私钥和 Bob 的公钥
        <span class="cov5" title="27">secret1, err := ECDHComputeShared(keyPair1.PrivateKey, keyPair2.PublicKey)
        if err != nil </span><span class="cov2" title="4">{
                return false, err
        }</span>

        // Bob 使用他的私钥和 Alice 的公钥
        <span class="cov5" title="23">secret2, err := ECDHComputeShared(keyPair2.PrivateKey, keyPair1.PublicKey)
        if err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>

        // 比较共享密钥是否相同
        <span class="cov5" title="22">if len(secret1) != len(secret2) </span><span class="cov1" title="1">{
                return false, nil
        }</span>

        <span class="cov5" title="21">for i := 0; i &lt; len(secret1); i++ </span><span class="cov9" title="610">{
                if secret1[i] != secret2[i] </span><span class="cov1" title="2">{
                        return false, nil
                }</span>
        }

        <span class="cov5" title="19">return true, nil</span>
}</pre>
		
		<pre class="file" id="file92" style="display: none">package cryptox

import (
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/sha256"
        "crypto/sha512"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "hash"
        "math/big"
)

// Global variables for dependency injection during testing
var (
        ecdsaRandReader = rand.Reader
)

// ECDSAKeyPair represents an ECDSA key pair
type ECDSAKeyPair struct {
        PrivateKey *ecdsa.PrivateKey
        PublicKey  *ecdsa.PublicKey
}

// GenerateECDSAKey 生成 ECDSA 密钥对
func GenerateECDSAKey(curve elliptic.Curve) (*ECDSAKeyPair, error) <span class="cov10" title="31">{
        if curve == nil </span><span class="cov1" title="1">{
                return nil, errors.New("curve cannot be nil")
        }</span>

        <span class="cov9" title="30">privateKey, err := ecdsa.GenerateKey(curve, ecdsaRandReader)
        if err != nil </span><span class="cov4" title="4">{
                return nil, fmt.Errorf("failed to generate ECDSA key: %w", err)
        }</span>

        <span class="cov9" title="26">return &amp;ECDSAKeyPair{
                PrivateKey: privateKey,
                PublicKey:  &amp;privateKey.PublicKey,
        }, nil</span>
}

// GenerateECDSAP256Key 生成 P-256 (secp256r1) ECDSA 密钥对
func GenerateECDSAP256Key() (*ECDSAKeyPair, error) <span class="cov8" title="20">{
        return GenerateECDSAKey(elliptic.P256())
}</span>

// GenerateECDSAP384Key 生成 P-384 (secp384r1) ECDSA 密钥对
func GenerateECDSAP384Key() (*ECDSAKeyPair, error) <span class="cov3" title="3">{
        return GenerateECDSAKey(elliptic.P384())
}</span>

// GenerateECDSAP521Key 生成 P-521 (secp521r1) ECDSA 密钥对
func GenerateECDSAP521Key() (*ECDSAKeyPair, error) <span class="cov2" title="2">{
        return GenerateECDSAKey(elliptic.P521())
}</span>

// ECDSASign 使用私钥对数据进行 ECDSA 签名
func ECDSASign(privateKey *ecdsa.PrivateKey, data []byte, hashFunc func() hash.Hash) (r, s *big.Int, err error) <span class="cov8" title="21">{
        if privateKey == nil </span><span class="cov1" title="1">{
                return nil, nil, errors.New("private key cannot be nil")
        }</span>
        <span class="cov8" title="20">if hashFunc == nil </span><span class="cov1" title="1">{
                return nil, nil, errors.New("hash function cannot be nil")
        }</span>

        <span class="cov8" title="19">h := hashFunc()
        h.Write(data)
        hashed := h.Sum(nil)

        return ecdsa.Sign(ecdsaRandReader, privateKey, hashed)</span>
}

// ECDSASignSHA256 使用 SHA256 哈希对数据进行 ECDSA 签名
func ECDSASignSHA256(privateKey *ecdsa.PrivateKey, data []byte) (r, s *big.Int, err error) <span class="cov7" title="14">{
        return ECDSASign(privateKey, data, sha256.New)
}</span>

// ECDSASignSHA512 使用 SHA512 哈希对数据进行 ECDSA 签名
func ECDSASignSHA512(privateKey *ecdsa.PrivateKey, data []byte) (r, s *big.Int, err error) <span class="cov2" title="2">{
        return ECDSASign(privateKey, data, sha512.New)
}</span>

// ECDSAVerify 使用公钥验证 ECDSA 签名
func ECDSAVerify(publicKey *ecdsa.PublicKey, data []byte, r, s *big.Int, hashFunc func() hash.Hash) bool <span class="cov9" title="22">{
        if publicKey == nil || r == nil || s == nil || hashFunc == nil </span><span class="cov4" title="4">{
                return false
        }</span>

        <span class="cov8" title="18">h := hashFunc()
        h.Write(data)
        hashed := h.Sum(nil)

        return ecdsa.Verify(publicKey, hashed, r, s)</span>
}

// ECDSAVerifySHA256 使用 SHA256 哈希验证 ECDSA 签名
func ECDSAVerifySHA256(publicKey *ecdsa.PublicKey, data []byte, r, s *big.Int) bool <span class="cov7" title="14">{
        return ECDSAVerify(publicKey, data, r, s, sha256.New)
}</span>

// ECDSAVerifySHA512 使用 SHA512 哈希验证 ECDSA 签名
func ECDSAVerifySHA512(publicKey *ecdsa.PublicKey, data []byte, r, s *big.Int) bool <span class="cov1" title="1">{
        return ECDSAVerify(publicKey, data, r, s, sha512.New)
}</span>

// ECDSAPrivateKeyToPEM 将 ECDSA 私钥转换为 PEM 格式
func ECDSAPrivateKeyToPEM(privateKey *ecdsa.PrivateKey) ([]byte, error) <span class="cov7" title="13">{
        if privateKey == nil </span><span class="cov2" title="2">{
                return nil, errors.New("private key cannot be nil")
        }</span>

        <span class="cov7" title="11">x509Encoded, err := x509.MarshalECPrivateKey(privateKey)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to marshal private key: %w", err)
        }</span>

        <span class="cov6" title="9">pemEncoded := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "EC PRIVATE KEY",
                Bytes: x509Encoded,
        })

        return pemEncoded, nil</span>
}

// ECDSAPrivateKeyFromPEM 从 PEM 格式解析 ECDSA 私钥
func ECDSAPrivateKeyFromPEM(pemData []byte) (*ecdsa.PrivateKey, error) <span class="cov8" title="15">{
        if len(pemData) == 0 </span><span class="cov2" title="2">{
                return nil, errors.New("PEM data cannot be empty")
        }</span>

        <span class="cov7" title="13">block, _ := pem.Decode(pemData)
        if block == nil </span><span class="cov3" title="3">{
                return nil, errors.New("failed to decode PEM block")
        }</span>

        <span class="cov7" title="10">if block.Type != "EC PRIVATE KEY" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid PEM block type: expected 'EC PRIVATE KEY', got '%s'", block.Type)
        }</span>

        <span class="cov6" title="9">privateKey, err := x509.ParseECPrivateKey(block.Bytes)
        if err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to parse EC private key: %w", err)
        }</span>

        <span class="cov5" title="6">return privateKey, nil</span>
}

// ECDSAPublicKeyToPEM 将 ECDSA 公钥转换为 PEM 格式
func ECDSAPublicKeyToPEM(publicKey *ecdsa.PublicKey) ([]byte, error) <span class="cov7" title="11">{
        if publicKey == nil </span><span class="cov2" title="2">{
                return nil, errors.New("public key cannot be nil")
        }</span>

        <span class="cov6" title="9">x509Encoded, err := x509.MarshalPKIXPublicKey(publicKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to marshal public key: %w", err)
        }</span>

        <span class="cov6" title="8">pemEncoded := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: x509Encoded,
        })

        return pemEncoded, nil</span>
}

// ECDSAPublicKeyFromPEM 从 PEM 格式解析 ECDSA 公钥
func ECDSAPublicKeyFromPEM(pemData []byte) (*ecdsa.PublicKey, error) <span class="cov8" title="17">{
        if len(pemData) == 0 </span><span class="cov1" title="1">{
                return nil, errors.New("PEM data cannot be empty")
        }</span>

        <span class="cov8" title="16">block, _ := pem.Decode(pemData)
        if block == nil </span><span class="cov5" title="5">{
                return nil, errors.New("failed to decode PEM block")
        }</span>

        <span class="cov7" title="11">if block.Type != "PUBLIC KEY" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid PEM block type: expected 'PUBLIC KEY', got '%s'", block.Type)
        }</span>

        <span class="cov7" title="10">publicKeyInterface, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        <span class="cov6" title="7">publicKey, ok := publicKeyInterface.(*ecdsa.PublicKey)
        if !ok </span><span class="cov1" title="1">{
                return nil, errors.New("not an ECDSA public key")
        }</span>

        <span class="cov5" title="6">return publicKey, nil</span>
}

// ECDSASignature represents an ECDSA signature
type ECDSASignature struct {
        R *big.Int
        S *big.Int
}

// ECDSASignatureToBytes 将 ECDSA 签名转换为字节数组（DER 编码）
func ECDSASignatureToBytes(r, s *big.Int) ([]byte, error) <span class="cov6" title="9">{
        if r == nil || s == nil </span><span class="cov2" title="2">{
                return nil, errors.New("signature components cannot be nil")
        }</span>

        // 简单的 DER 编码实现
        <span class="cov6" title="7">rBytes := r.Bytes()
        sBytes := s.Bytes()

        // 如果最高位是1，需要添加0x00前缀
        if len(rBytes) &gt; 0 &amp;&amp; rBytes[0]&amp;0x80 != 0 </span><span class="cov4" title="4">{
                rBytes = append([]byte{0x00}, rBytes...)
        }</span>
        <span class="cov6" title="7">if len(sBytes) &gt; 0 &amp;&amp; sBytes[0]&amp;0x80 != 0 </span><span class="cov5" title="6">{
                sBytes = append([]byte{0x00}, sBytes...)
        }</span>

        // 构建 DER 结构
        <span class="cov6" title="7">rDER := append([]byte{0x02, byte(len(rBytes))}, rBytes...)
        sDER := append([]byte{0x02, byte(len(sBytes))}, sBytes...)
        
        signature := append(rDER, sDER...)
        derEncoded := append([]byte{0x30, byte(len(signature))}, signature...)

        return derEncoded, nil</span>
}

// ECDSASignatureFromBytes 从字节数组解析 ECDSA 签名（DER 解码）
func ECDSASignatureFromBytes(data []byte) (r, s *big.Int, err error) <span class="cov9" title="29">{
        if len(data) &lt; 6 </span><span class="cov7" title="13">{
                return nil, nil, errors.New("signature data too short")
        }</span>

        // 检查 DER 结构
        <span class="cov8" title="16">if data[0] != 0x30 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("invalid DER signature: missing SEQUENCE tag")
        }</span>

        <span class="cov8" title="15">seqLen := int(data[1])
        if len(data) &lt; seqLen+2 </span><span class="cov4" title="4">{
                return nil, nil, errors.New("invalid DER signature: incorrect sequence length")
        }</span>

        <span class="cov7" title="11">data = data[2:] // 跳过 SEQUENCE 头部

        // 解析 r
        if len(data) &lt; 2 || data[0] != 0x02 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("invalid DER signature: missing INTEGER tag for r")
        }</span>

        <span class="cov7" title="10">rLen := int(data[1])
        if len(data) &lt; rLen+2 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("invalid DER signature: incorrect r length")
        }</span>

        <span class="cov6" title="9">rBytes := data[2 : 2+rLen]
        r = new(big.Int).SetBytes(rBytes)
        data = data[2+rLen:]

        // 解析 s
        if len(data) &lt; 2 || data[0] != 0x02 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("invalid DER signature: missing INTEGER tag for s")
        }</span>

        <span class="cov6" title="8">sLen := int(data[1])
        if len(data) &lt; sLen+2 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("invalid DER signature: incorrect s length")
        }</span>

        <span class="cov6" title="7">sBytes := data[2 : 2+sLen]
        s = new(big.Int).SetBytes(sBytes)

        return r, s, nil</span>
}

// GetCurveName 获取椭圆曲线的名称
func GetCurveName(curve elliptic.Curve) string <span class="cov7" title="10">{
        switch curve </span>{
        case elliptic.P224():<span class="cov2" title="2">
                return "P-224"</span>
        case elliptic.P256():<span class="cov2" title="2">
                return "P-256"</span>
        case elliptic.P384():<span class="cov2" title="2">
                return "P-384"</span>
        case elliptic.P521():<span class="cov2" title="2">
                return "P-521"</span>
        default:<span class="cov2" title="2">
                return "Unknown"</span>
        }
}

// IsValidCurve 检查椭圆曲线是否有效
func IsValidCurve(curve elliptic.Curve) bool <span class="cov7" title="10">{
        switch curve </span>{
        case elliptic.P224(), elliptic.P256(), elliptic.P384(), elliptic.P521():<span class="cov6" title="8">
                return true</span>
        default:<span class="cov2" title="2">
                return false</span>
        }
}</pre>
		
		<pre class="file" id="file93" style="display: none">package cryptox

import (
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "fmt"
        "golang.org/x/crypto/ripemd160"
)

// Md5 计算输入字符串或字节切片的 MD5 哈希值，并返回十六进制表示的字符串。
func Md5[M string | []byte](s M) string <span class="cov10" title="6">{
        return fmt.Sprintf("%x", md5.Sum([]byte(s)))
}</span>

// SHA1 计算输入字符串或字节切片的 SHA1 哈希值，并返回十六进制表示的字符串。
// 注意：SHA1 已被认为不安全，仅用于兼容性目的。
func SHA1[M string | []byte](s M) string <span class="cov7" title="4">{
        return fmt.Sprintf("%x", sha1.Sum([]byte(s)))
}</span>

// Sha224 计算输入字符串或字节切片的 SHA-224 哈希值，并返回十六进制表示的字符串。
func Sha224[M string | []byte](s M) string <span class="cov1" title="1">{
        return fmt.Sprintf("%x", sha256.Sum224([]byte(s)))
}</span>

// Sha256 计算输入字符串或字节切片的 SHA-256 哈希值，并返回十六进制表示的字符串。
func Sha256[M string | []byte](s M) string <span class="cov9" title="5">{
        return fmt.Sprintf("%x", sha256.Sum256([]byte(s)))
}</span>

// Sha384 计算输入字符串或字节切片的 SHA-384 哈希值，并返回十六进制表示的字符串。
func Sha384[M string | []byte](s M) string <span class="cov1" title="1">{
        return fmt.Sprintf("%x", sha512.Sum384([]byte(s)))
}</span>

// Sha512 计算输入字符串或字节切片的 SHA-512 哈希值，并返回十六进制表示的字符串。
func Sha512[M string | []byte](s M) string <span class="cov1" title="1">{
        return fmt.Sprintf("%x", sha512.Sum512([]byte(s)))
}</span>

// Sha512_224 计算输入字符串或字节切片的 SHA-512/224 哈希值，并返回十六进制表示的字符串。
func Sha512_224[M string | []byte](s M) string <span class="cov1" title="1">{
        return fmt.Sprintf("%x", sha512.Sum512_224([]byte(s)))
}</span>

// Sha512_256 计算输入字符串或字节切片的 SHA-512/256 哈希值，并返回十六进制表示的字符串。
func Sha512_256[M string | []byte](s M) string <span class="cov1" title="1">{
        return fmt.Sprintf("%x", sha512.Sum512_256([]byte(s)))
}</span>

// RIPEMD160 计算输入字符串或字节切片的 RIPEMD-160 哈希值，并返回十六进制表示的字符串。
func RIPEMD160[M string | []byte](s M) string <span class="cov7" title="4">{
        h := ripemd160.New()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</pre>
		
		<pre class="file" id="file94" style="display: none">package cryptox

import (
        "fmt"
        "golang.org/x/crypto/blake2b"
        "golang.org/x/crypto/blake2s"
)

// Global variables for dependency injection during testing
var (
        blake2bNew    = blake2b.New
        blake2sNew256 = blake2s.New256
)

// BLAKE2b 计算输入字符串或字节切片的 BLAKE2b 哈希值，并返回指定长度的十六进制表示的字符串。
func BLAKE2b[M string | []byte](s M, size int) (string, error) <span class="cov9" title="69">{
        if size &lt;= 0 </span><span class="cov2" title="2">{
                return "", fmt.Errorf("size must be greater than 0")
        }</span>
        <span class="cov9" title="67">var key []byte
        h, err := blake2b.New(size, key)
        if err != nil </span><span class="cov2" title="2">{
                return "", fmt.Errorf("failed to create BLAKE2b hash: %w", err)
        }</span>
        <span class="cov9" title="65">_, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil)), nil</span>
}

// BLAKE2s 计算输入字符串或字节切片的 BLAKE2s 哈希值，并返回256位十六进制表示的字符串。
// 注意：BLAKE2s 固定输出256位，size参数被忽略以保持兼容性。
func BLAKE2s[M string | []byte](s M, size int) (string, error) <span class="cov9" title="71">{
        if size &lt;= 0 </span><span class="cov3" title="4">{
                return "", fmt.Errorf("size must be greater than 0")
        }</span>
        <span class="cov9" title="67">var key []byte
        h, err := blake2sNew256(key)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to create BLAKE2s hash: %w", err)
        }</span>
        <span class="cov9" title="66">_, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil)), nil</span>
}

// BLAKE2b512 计算输入字符串或字节切片的 BLAKE2b-512 哈希值，并返回十六进制表示的字符串。
func BLAKE2b512[M string | []byte](s M) string <span class="cov3" title="4">{
        h, _ := blake2b.New512(nil)
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// BLAKE2b256 计算输入字符串或字节切片的 BLAKE2b-256 哈希值，并返回十六进制表示的字符串。
func BLAKE2b256[M string | []byte](s M) string <span class="cov3" title="4">{
        h, _ := blake2b.New256(nil)
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// BLAKE2s256 计算输入字符串或字节切片的 BLAKE2s-256 哈希值，并返回十六进制表示的字符串。
func BLAKE2s256[M string | []byte](s M) string <span class="cov3" title="4">{
        h, _ := blake2s.New256(nil)
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// BLAKE2bWithKey 使用密钥计算输入字符串或字节切片的 BLAKE2b 哈希值，并返回指定长度的十六进制表示的字符串。
func BLAKE2bWithKey[M string | []byte](s M, key []byte, size int) (string, error) <span class="cov10" title="72">{
        if size &lt;= 0 || size &gt; 64 </span><span class="cov4" title="5">{
                return "", fmt.Errorf("size must be between 1 and 64 bytes")
        }</span>
        <span class="cov9" title="67">h, err := blake2bNew(size, key)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to create BLAKE2b hash with key: %w", err)
        }</span>
        <span class="cov9" title="66">_, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil)), nil</span>
}

// BLAKE2sWithKey 使用密钥计算输入字符串或字节切片的 BLAKE2s 哈希值，并返回256位十六进制表示的字符串。
func BLAKE2sWithKey[M string | []byte](s M, key []byte) (string, error) <span class="cov8" title="35">{
        h, err := blake2sNew256(key)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to create BLAKE2s hash with key: %w", err)
        }</span>
        <span class="cov8" title="34">_, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil)), nil</span>
}</pre>
		
		<pre class="file" id="file95" style="display: none">package cryptox

import (
        "hash/crc32"
        "hash/crc64"
)

// CRC32 计算输入字符串或字节切片的 CRC32 校验值。
func CRC32[M string | []byte](s M) uint32 <span class="cov10" title="4">{
        return crc32.ChecksumIEEE([]byte(s))
}</span>

// CRC64 计算输入字符串或字节切片的 CRC64 校验值。
func CRC64[M string | []byte](s M) uint64 <span class="cov10" title="4">{
        table := crc64.MakeTable(crc64.ECMA)
        return crc64.Checksum([]byte(s), table)
}</pre>
		
		<pre class="file" id="file96" style="display: none">package cryptox

import (
        "hash/fnv"
)

// Hash32 使用 FNV-1 算法计算输入字符串或字节切片的 32 位哈希值。
func Hash32[M string | []byte](s M) uint32 <span class="cov10" title="4">{
        h := fnv.New32()
        _, _ = h.Write([]byte(s))
        return h.Sum32()
}</span>

// Hash32a 使用 FNV-1a 算法计算输入字符串或字节切片的 32 位哈希值。
func Hash32a[M string | []byte](s M) uint32 <span class="cov10" title="4">{
        h := fnv.New32a()
        _, _ = h.Write([]byte(s))
        return h.Sum32()
}</span>

// Hash64 使用 FNV-1 算法计算输入字符串或字节切片的 64 位哈希值。
func Hash64[M string | []byte](s M) uint64 <span class="cov10" title="4">{
        h := fnv.New64()
        _, _ = h.Write([]byte(s))
        return h.Sum64()
}</span>

// Hash64a 使用 FNV-1a 算法计算输入字符串或字节切片的 64 位哈希值。
func Hash64a[M string | []byte](s M) uint64 <span class="cov10" title="4">{
        h := fnv.New64a()
        _, _ = h.Write([]byte(s))
        return h.Sum64()
}</pre>
		
		<pre class="file" id="file97" style="display: none">package cryptox

import (
        "crypto/hmac"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "fmt"
)

// HMACMd5 使用 MD5 作为底层哈希函数计算 HMAC 值，并返回十六进制表示的字符串。
func HMACMd5[M string | []byte](key, message M) string <span class="cov10" title="4">{
        h := hmac.New(md5.New, []byte(key))
        _, _ = h.Write([]byte(message))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// HMACSHA1 使用 SHA1 作为底层哈希函数计算 HMAC 值，并返回十六进制表示的字符串。
func HMACSHA1[M string | []byte](key, message M) string <span class="cov10" title="4">{
        h := hmac.New(sha1.New, []byte(key))
        _, _ = h.Write([]byte(message))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// HMACSHA256 使用 SHA256 作为底层哈希函数计算 HMAC 值，并返回十六进制表示的字符串。
func HMACSHA256[M string | []byte](key, message M) string <span class="cov10" title="4">{
        h := hmac.New(sha256.New, []byte(key))
        _, _ = h.Write([]byte(message))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// HMACSHA384 使用 SHA384 作为底层哈希函数计算 HMAC 值，并返回十六进制表示的字符串。
func HMACSHA384[M string | []byte](key, message M) string <span class="cov10" title="4">{
        h := hmac.New(sha512.New384, []byte(key))
        _, _ = h.Write([]byte(message))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// HMACSHA512 使用 SHA512 作为底层哈希函数计算 HMAC 值，并返回十六进制表示的字符串。
func HMACSHA512[M string | []byte](key, message M) string <span class="cov10" title="4">{
        h := hmac.New(sha512.New, []byte(key))
        _, _ = h.Write([]byte(message))
        return fmt.Sprintf("%x", h.Sum(nil))
}</pre>
		
		<pre class="file" id="file98" style="display: none">package cryptox

import (
        "fmt"
        "golang.org/x/crypto/sha3"
)

// SHA3_224 计算输入字符串或字节切片的 SHA3-224 哈希值，并返回十六进制表示的字符串。
func SHA3_224[M string | []byte](s M) string <span class="cov3" title="3">{
        h := sha3.New224()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// SHA3_256 计算输入字符串或字节切片的 SHA3-256 哈希值，并返回十六进制表示的字符串。
func SHA3_256[M string | []byte](s M) string <span class="cov3" title="3">{
        h := sha3.New256()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// SHA3_384 计算输入字符串或字节切片的 SHA3-384 哈希值，并返回十六进制表示的字符串。
func SHA3_384[M string | []byte](s M) string <span class="cov3" title="3">{
        h := sha3.New384()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// SHA3_512 计算输入字符串或字节切片的 SHA3-512 哈希值，并返回十六进制表示的字符串。
func SHA3_512[M string | []byte](s M) string <span class="cov3" title="3">{
        h := sha3.New512()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// SHAKE128 计算输入字符串或字节切片的 SHAKE128 哈希值，并返回指定长度的十六进制表示的字符串。
func SHAKE128[M string | []byte](s M, size int) (string, error) <span class="cov10" title="107">{
        if size &lt;= 0 </span><span class="cov3" title="4">{
                return "", fmt.Errorf("size must be greater than 0")
        }</span>
        <span class="cov9" title="103">h := sha3.NewShake128()
        _, _ = h.Write([]byte(s))
        buf := make([]byte, size)
        _, _ = h.Read(buf)
        return fmt.Sprintf("%x", buf), nil</span>
}

// SHAKE256 计算输入字符串或字节切片的 SHAKE256 哈希值，并返回指定长度的十六进制表示的字符串。
func SHAKE256[M string | []byte](s M, size int) (string, error) <span class="cov10" title="107">{
        if size &lt;= 0 </span><span class="cov3" title="4">{
                return "", fmt.Errorf("size must be greater than 0")
        }</span>
        <span class="cov9" title="103">h := sha3.NewShake256()
        _, _ = h.Write([]byte(s))
        buf := make([]byte, size)
        _, _ = h.Read(buf)
        return fmt.Sprintf("%x", buf), nil</span>
}

// Keccak256 计算输入字符串或字节切片的 Keccak-256 哈希值，并返回十六进制表示的字符串。
// 注意：这是原始的 Keccak，不是 NIST 标准化的 SHA3。
func Keccak256[M string | []byte](s M) string <span class="cov3" title="4">{
        h := sha3.NewLegacyKeccak256()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</pre>
		
		<pre class="file" id="file99" style="display: none">package cryptox

import (
        "crypto/hmac"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "fmt"
        "golang.org/x/crypto/sha3"
        "hash"
)

// hmacEncode 是一个通用的 HMAC 编码函数，支持传入不同的哈希函数
func hmacEncode(key, data string, h func() hash.Hash) string <span class="cov10" title="10">{
        sha := hmac.New(h, []byte(key))
        sha.Write([]byte(data))
        return fmt.Sprintf("%x", sha.Sum(nil))
}</span>

// HmacMd5 使用 MD5 哈希算法进行 HMAC 编码
func HmacMd5(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, md5.New)
}</span>

// HmacSha1 使用 SHA-1 哈希算法进行 HMAC 编码
func HmacSha1(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha1.New)
}</span>

// HmacSha256 使用 SHA-256 哈希算法进行 HMAC 编码
func HmacSha256(key, data string) string <span class="cov3" title="2">{
        return hmacEncode(key, data, sha256.New)
}</span>

// HmacSha224 使用 SHA-224 哈希算法进行 HMAC 编码
func HmacSha224(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha256.New224)
}</span>

// HmacSha512 使用 SHA-512 哈希算法进行 HMAC 编码
func HmacSha512(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha512.New)
}</span>

// HmacSha384 使用 SHA-384 哈希算法进行 HMAC 编码
func HmacSha384(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha512.New384)
}</span>

// HmacSha3_256 使用 SHA3-256 哈希算法进行 HMAC 编码
func HmacSha3_256(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha3.New256)
}</span>

// HmacSha3_384 使用 SHA3-384 哈希算法进行 HMAC 编码
func HmacSha3_384(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha3.New384)
}</span>

// HmacSha3_512 使用 SHA3-512 哈希算法进行 HMAC 编码
func HmacSha3_512(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha3.New512)
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package cryptox

import (
        "crypto/rand"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "errors"
        "fmt"
        "io"

        "golang.org/x/crypto/argon2"
        "golang.org/x/crypto/pbkdf2"
        "golang.org/x/crypto/scrypt"
)

// Global variables for dependency injection during testing
var (
        kdfRandReader = rand.Reader
)

// PBKDF2WithSHA256 使用 PBKDF2 和 SHA256 从密码派生密钥
func PBKDF2WithSHA256(password, salt []byte, iterations, keyLength int) []byte <span class="cov5" title="38">{
        return pbkdf2.Key(password, salt, iterations, keyLength, sha256.New)
}</span>

// PBKDF2WithSHA1 使用 PBKDF2 和 SHA1 从密码派生密钥
// 注意：SHA1 已被认为不安全，仅用于兼容性目的
func PBKDF2WithSHA1(password, salt []byte, iterations, keyLength int) []byte <span class="cov1" title="2">{
        return pbkdf2.Key(password, salt, iterations, keyLength, sha1.New)
}</span>

// PBKDF2WithSHA512 使用 PBKDF2 和 SHA512 从密码派生密钥
func PBKDF2WithSHA512(password, salt []byte, iterations, keyLength int) []byte <span class="cov1" title="2">{
        return pbkdf2.Key(password, salt, iterations, keyLength, sha512.New)
}</span>

// PBKDF2Config PBKDF2 配置参数
type PBKDF2Config struct {
        SaltLength int // 盐长度（字节）
        Iterations int // 迭代次数
        KeyLength  int // 密钥长度（字节）
}

// DefaultPBKDF2Config 返回推荐的 PBKDF2 配置
func DefaultPBKDF2Config() PBKDF2Config <span class="cov3" title="8">{
        return PBKDF2Config{
                SaltLength: 16,     // 128位盐
                Iterations: 100000, // 10万次迭代
                KeyLength:  32,     // 256位密钥
        }
}</span>

// PBKDF2Generate 生成随机盐并使用 PBKDF2-SHA256 派生密钥
func PBKDF2Generate(password string, config PBKDF2Config) (key, salt []byte, err error) <span class="cov5" title="26">{
        if config.SaltLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("salt length must be greater than 0")
        }</span>
        <span class="cov4" title="25">if config.Iterations &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("iterations must be greater than 0")
        }</span>
        <span class="cov4" title="24">if config.KeyLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("key length must be greater than 0")
        }</span>

        <span class="cov4" title="23">salt = make([]byte, config.SaltLength)
        _, err = io.ReadFull(kdfRandReader, salt)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov4" title="22">key = PBKDF2WithSHA256([]byte(password), salt, config.Iterations, config.KeyLength)
        return key, salt, nil</span>
}

// PBKDF2Verify 验证密码是否匹配给定的密钥和盐
func PBKDF2Verify(password string, key, salt []byte, config PBKDF2Config) bool <span class="cov4" title="13">{
        derivedKey := PBKDF2WithSHA256([]byte(password), salt, config.Iterations, config.KeyLength)
        return len(key) == len(derivedKey) &amp;&amp; constantTimeCompare(key, derivedKey)
}</span>

// ScryptConfig Scrypt 配置参数
type ScryptConfig struct {
        SaltLength int // 盐长度（字节）
        N          int // CPU/内存成本参数（必须是2的幂）
        R          int // 块大小参数
        P          int // 并行化参数
        KeyLength  int // 密钥长度（字节）
}

// DefaultScryptConfig 返回推荐的 Scrypt 配置
func DefaultScryptConfig() ScryptConfig <span class="cov3" title="8">{
        return ScryptConfig{
                SaltLength: 16,    // 128位盐
                N:          32768, // 2^15, 推荐值
                R:          8,     // 推荐值
                P:          1,     // 推荐值
                KeyLength:  32,    // 256位密钥
        }
}</span>

// ScryptDerive 使用 Scrypt 从密码派生密钥
func ScryptDerive(password, salt []byte, config ScryptConfig) ([]byte, error) <span class="cov4" title="24">{
        if config.N &lt;= 0 || (config.N&amp;(config.N-1)) != 0 </span><span class="cov2" title="4">{
                return nil, errors.New("N must be a positive power of 2")
        }</span>
        <span class="cov4" title="20">if config.R &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("R must be greater than 0")
        }</span>
        <span class="cov4" title="19">if config.P &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("P must be greater than 0")
        }</span>
        <span class="cov4" title="18">if config.KeyLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("key length must be greater than 0")
        }</span>

        <span class="cov4" title="17">return scrypt.Key(password, salt, config.N, config.R, config.P, config.KeyLength)</span>
}

// ScryptGenerate 生成随机盐并使用 Scrypt 派生密钥
func ScryptGenerate(password string, config ScryptConfig) (key, salt []byte, err error) <span class="cov4" title="15">{
        if config.SaltLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("salt length must be greater than 0")
        }</span>

        <span class="cov4" title="14">salt = make([]byte, config.SaltLength)
        _, err = io.ReadFull(kdfRandReader, salt)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov4" title="13">key, err = ScryptDerive([]byte(password), salt, config)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("scrypt derivation failed: %w", err)
        }</span>

        <span class="cov4" title="12">return key, salt, nil</span>
}

// ScryptVerify 验证密码是否匹配给定的密钥和盐
func ScryptVerify(password string, key, salt []byte, config ScryptConfig) bool <span class="cov2" title="4">{
        derivedKey, err := ScryptDerive([]byte(password), salt, config)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov2" title="3">return len(key) == len(derivedKey) &amp;&amp; constantTimeCompare(key, derivedKey)</span>
}

// Argon2Config Argon2 配置参数
type Argon2Config struct {
        SaltLength int    // 盐长度（字节）
        Time       uint32 // 时间参数（迭代次数）
        Memory     uint32 // 内存参数（KB）
        Threads    uint8  // 并行度参数
        KeyLength  int    // 密钥长度（字节）
}

// DefaultArgon2Config 返回推荐的 Argon2 配置
func DefaultArgon2Config() Argon2Config <span class="cov3" title="8">{
        return Argon2Config{
                SaltLength: 16,      // 128位盐
                Time:       1,       // 1次迭代（推荐值）
                Memory:     64 * 1024, // 64MB 内存
                Threads:    4,       // 4线程
                KeyLength:  32,      // 256位密钥
        }
}</span>

// Argon2IDDerive 使用 Argon2id 从密码派生密钥
func Argon2IDDerive(password, salt []byte, config Argon2Config) []byte <span class="cov4" title="16">{
        return argon2.IDKey(password, salt, config.Time, config.Memory, config.Threads, uint32(config.KeyLength))
}</span>

// Argon2IDerive 使用 Argon2i 从密码派生密钥
func Argon2IDerive(password, salt []byte, config Argon2Config) []byte <span class="cov1" title="2">{
        return argon2.Key(password, salt, config.Time, config.Memory, config.Threads, uint32(config.KeyLength))
}</span>

// Argon2Generate 生成随机盐并使用 Argon2id 派生密钥
func Argon2Generate(password string, config Argon2Config) (key, salt []byte, err error) <span class="cov4" title="16">{
        if config.SaltLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("salt length must be greater than 0")
        }</span>
        <span class="cov4" title="15">if config.Time == 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("time parameter must be greater than 0")
        }</span>
        <span class="cov4" title="14">if config.Memory == 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("memory parameter must be greater than 0")
        }</span>
        <span class="cov4" title="13">if config.Threads == 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("threads parameter must be greater than 0")
        }</span>
        <span class="cov4" title="12">if config.KeyLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("key length must be greater than 0")
        }</span>

        <span class="cov3" title="11">salt = make([]byte, config.SaltLength)
        _, err = io.ReadFull(kdfRandReader, salt)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov3" title="10">key = Argon2IDDerive([]byte(password), salt, config)
        return key, salt, nil</span>
}

// Argon2Verify 验证密码是否匹配给定的密钥和盐
func Argon2Verify(password string, key, salt []byte, config Argon2Config) bool <span class="cov2" title="3">{
        derivedKey := Argon2IDDerive([]byte(password), salt, config)
        return len(key) == len(derivedKey) &amp;&amp; constantTimeCompare(key, derivedKey)
}</span>

// constantTimeCompare 恒定时间比较，防止时间攻击
func constantTimeCompare(a, b []byte) bool <span class="cov5" title="57">{
        if len(a) != len(b) </span><span class="cov1" title="2">{
                return false
        }</span>
        
        <span class="cov5" title="55">var result byte
        for i := 0; i &lt; len(a); i++ </span><span class="cov10" title="1482">{
                result |= a[i] ^ b[i]
        }</span>
        <span class="cov5" title="55">return result == 0</span>
}

// GenerateSalt 生成指定长度的随机盐
func GenerateSalt(length int) ([]byte, error) <span class="cov3" title="11">{
        if length &lt;= 0 </span><span class="cov1" title="2">{
                return nil, errors.New("salt length must be greater than 0")
        }</span>
        
        <span class="cov3" title="9">salt := make([]byte, length)
        _, err := io.ReadFull(kdfRandReader, salt)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to generate salt: %w", err)
        }</span>
        
        <span class="cov3" title="8">return salt, nil</span>
}</pre>
		
		<pre class="file" id="file101" style="display: none">package cryptox

import (
        "crypto"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
)

// Global variables for dependency injection during testing
var (
        rsaGenerateKey    = rsa.GenerateKey
        rsaEncryptOAEP    = rsa.EncryptOAEP
        rsaEncryptPKCS1v15 = rsa.EncryptPKCS1v15
        rsaDecryptOAEP    = rsa.DecryptOAEP
        rsaDecryptPKCS1v15 = rsa.DecryptPKCS1v15
        rsaSignPSS        = rsa.SignPSS
        rsaSignPKCS1v15   = rsa.SignPKCS1v15
        rsaVerifyPSS      = rsa.VerifyPSS
        rsaVerifyPKCS1v15 = rsa.VerifyPKCS1v15
        rsaRandReader     = rand.Reader
)

// RSAKeyPair 表示 RSA 公私钥对
type RSAKeyPair struct {
        PrivateKey *rsa.PrivateKey
        PublicKey  *rsa.PublicKey
}

// GenerateRSAKeyPair 生成指定长度的 RSA 密钥对
// keySize: 密钥长度，建议使用 2048、3072 或 4096 位
func GenerateRSAKeyPair(keySize int) (*RSAKeyPair, error) <span class="cov10" title="25">{
        if keySize &lt; 1024 </span><span class="cov1" title="1">{
                return nil, errors.New("RSA key size must be at least 1024 bits")
        }</span>

        <span class="cov9" title="24">privateKey, err := rsaGenerateKey(rsaRandReader, keySize)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to generate RSA key pair: %w", err)
        }</span>

        <span class="cov9" title="23">return &amp;RSAKeyPair{
                PrivateKey: privateKey,
                PublicKey:  &amp;privateKey.PublicKey,
        }, nil</span>
}

// PrivateKeyToPEM 将私钥转换为 PEM 格式
func (kp *RSAKeyPair) PrivateKeyToPEM() ([]byte, error) <span class="cov7" title="11">{
        if kp.PrivateKey == nil </span><span class="cov4" title="3">{
                return nil, errors.New("private key is nil")
        }</span>

        <span class="cov6" title="8">privateKeyBytes, err := x509.MarshalPKCS8PrivateKey(kp.PrivateKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to marshal private key: %w", err)
        }</span>

        <span class="cov6" title="7">privateKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PRIVATE KEY",
                Bytes: privateKeyBytes,
        })

        return privateKeyPEM, nil</span>
}

// PublicKeyToPEM 将公钥转换为 PEM 格式
func (kp *RSAKeyPair) PublicKeyToPEM() ([]byte, error) <span class="cov9" title="18">{
        if kp.PublicKey == nil </span><span class="cov4" title="3">{
                return nil, errors.New("public key is nil")
        }</span>

        <span class="cov8" title="15">publicKeyBytes, err := x509.MarshalPKIXPublicKey(kp.PublicKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to marshal public key: %w", err)
        }</span>

        <span class="cov8" title="14">publicKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: publicKeyBytes,
        })

        return publicKeyPEM, nil</span>
}

// PrivateKeyFromPEM 从 PEM 格式加载私钥
func PrivateKeyFromPEM(pemData []byte) (*rsa.PrivateKey, error) <span class="cov9" title="20">{
        block, _ := pem.Decode(pemData)
        if block == nil </span><span class="cov6" title="8">{
                return nil, errors.New("failed to decode PEM block")
        }</span>

        <span class="cov7" title="12">if block.Type != "PRIVATE KEY" &amp;&amp; block.Type != "RSA PRIVATE KEY" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid PEM block type: %s", block.Type)
        }</span>

        <span class="cov7" title="11">var privateKey *rsa.PrivateKey
        var err error

        if block.Type == "PRIVATE KEY" </span><span class="cov7" title="10">{
                // PKCS#8 format
                key, err := x509.ParsePKCS8PrivateKey(block.Bytes)
                if err != nil </span><span class="cov4" title="4">{
                        return nil, fmt.Errorf("failed to parse PKCS8 private key: %w", err)
                }</span>
                
                <span class="cov6" title="6">var ok bool
                privateKey, ok = key.(*rsa.PrivateKey)
                if !ok </span><span class="cov1" title="1">{
                        return nil, errors.New("key is not an RSA private key")
                }</span>
        } else<span class="cov1" title="1"> {
                // PKCS#1 format
                privateKey, err = x509.ParsePKCS1PrivateKey(block.Bytes)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to parse PKCS1 private key: %w", err)
                }</span>
        }

        <span class="cov5" title="5">return privateKey, nil</span>
}

// PublicKeyFromPEM 从 PEM 格式加载公钥
func PublicKeyFromPEM(pemData []byte) (*rsa.PublicKey, error) <span class="cov9" title="19">{
        block, _ := pem.Decode(pemData)
        if block == nil </span><span class="cov6" title="7">{
                return nil, errors.New("failed to decode PEM block")
        }</span>

        <span class="cov7" title="12">if block.Type != "PUBLIC KEY" &amp;&amp; block.Type != "RSA PUBLIC KEY" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid PEM block type: %s", block.Type)
        }</span>

        <span class="cov7" title="11">var publicKey *rsa.PublicKey
        var err error

        if block.Type == "PUBLIC KEY" </span><span class="cov7" title="10">{
                // PKIX format
                key, err := x509.ParsePKIXPublicKey(block.Bytes)
                if err != nil </span><span class="cov4" title="4">{
                        return nil, fmt.Errorf("failed to parse PKIX public key: %w", err)
                }</span>
                
                <span class="cov6" title="6">var ok bool
                publicKey, ok = key.(*rsa.PublicKey)
                if !ok </span><span class="cov1" title="1">{
                        return nil, errors.New("key is not an RSA public key")
                }</span>
        } else<span class="cov1" title="1"> {
                // PKCS#1 format
                publicKey, err = x509.ParsePKCS1PublicKey(block.Bytes)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to parse PKCS1 public key: %w", err)
                }</span>
        }

        <span class="cov5" title="5">return publicKey, nil</span>
}

// RSAEncryptOAEP 使用 OAEP 填充方式进行 RSA 加密
func RSAEncryptOAEP(publicKey *rsa.PublicKey, plaintext []byte) ([]byte, error) <span class="cov7" title="10">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("public key is nil")
        }</span>

        <span class="cov7" title="9">hash := sha256.New()
        ciphertext, err := rsaEncryptOAEP(hash, rsaRandReader, publicKey, plaintext, nil)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("RSA OAEP encryption failed: %w", err)
        }</span>

        <span class="cov6" title="7">return ciphertext, nil</span>
}

// RSADecryptOAEP 使用 OAEP 填充方式进行 RSA 解密
func RSADecryptOAEP(privateKey *rsa.PrivateKey, ciphertext []byte) ([]byte, error) <span class="cov6" title="8">{
        if privateKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("private key is nil")
        }</span>

        <span class="cov6" title="7">hash := sha256.New()
        plaintext, err := rsaDecryptOAEP(hash, rsaRandReader, privateKey, ciphertext, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("RSA OAEP decryption failed: %w", err)
        }</span>

        <span class="cov6" title="6">return plaintext, nil</span>
}

// RSAEncryptPKCS1v15 使用 PKCS1v15 填充方式进行 RSA 加密
func RSAEncryptPKCS1v15(publicKey *rsa.PublicKey, plaintext []byte) ([]byte, error) <span class="cov5" title="5">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("public key is nil")
        }</span>

        <span class="cov4" title="4">ciphertext, err := rsaEncryptPKCS1v15(rsaRandReader, publicKey, plaintext)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("RSA PKCS1v15 encryption failed: %w", err)
        }</span>

        <span class="cov4" title="3">return ciphertext, nil</span>
}

// RSADecryptPKCS1v15 使用 PKCS1v15 填充方式进行 RSA 解密
func RSADecryptPKCS1v15(privateKey *rsa.PrivateKey, ciphertext []byte) ([]byte, error) <span class="cov4" title="4">{
        if privateKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("private key is nil")
        }</span>

        <span class="cov4" title="3">plaintext, err := rsaDecryptPKCS1v15(rsaRandReader, privateKey, ciphertext)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("RSA PKCS1v15 decryption failed: %w", err)
        }</span>

        <span class="cov2" title="2">return plaintext, nil</span>
}

// RSASignPSS 使用 PSS 填充方式进行数字签名
func RSASignPSS(privateKey *rsa.PrivateKey, message []byte) ([]byte, error) <span class="cov4" title="4">{
        if privateKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("private key is nil")
        }</span>

        <span class="cov4" title="3">hash := sha256.Sum256(message)
        signature, err := rsaSignPSS(rsaRandReader, privateKey, crypto.SHA256, hash[:], nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("RSA PSS signing failed: %w", err)
        }</span>

        <span class="cov2" title="2">return signature, nil</span>
}

// RSAVerifyPSS 使用 PSS 填充方式验证数字签名
func RSAVerifyPSS(publicKey *rsa.PublicKey, message []byte, signature []byte) error <span class="cov4" title="4">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return errors.New("public key is nil")
        }</span>

        <span class="cov4" title="3">hash := sha256.Sum256(message)
        err := rsaVerifyPSS(publicKey, crypto.SHA256, hash[:], signature, nil)
        if err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("RSA PSS signature verification failed: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// RSASignPKCS1v15 使用 PKCS1v15 填充方式进行数字签名
func RSASignPKCS1v15(privateKey *rsa.PrivateKey, message []byte) ([]byte, error) <span class="cov4" title="4">{
        if privateKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("private key is nil")
        }</span>

        <span class="cov4" title="3">hash := sha256.Sum256(message)
        signature, err := rsaSignPKCS1v15(rsaRandReader, privateKey, crypto.SHA256, hash[:])
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("RSA PKCS1v15 signing failed: %w", err)
        }</span>

        <span class="cov2" title="2">return signature, nil</span>
}

// RSAVerifyPKCS1v15 使用 PKCS1v15 填充方式验证数字签名
func RSAVerifyPKCS1v15(publicKey *rsa.PublicKey, message []byte, signature []byte) error <span class="cov4" title="4">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return errors.New("public key is nil")
        }</span>

        <span class="cov4" title="3">hash := sha256.Sum256(message)
        err := rsaVerifyPKCS1v15(publicKey, crypto.SHA256, hash[:], signature)
        if err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("RSA PKCS1v15 signature verification failed: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetRSAKeySize 获取 RSA 密钥长度（位）
func GetRSAKeySize(key *rsa.PublicKey) int <span class="cov6" title="7">{
        if key == nil </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov6" title="6">return key.Size() * 8</span>
}

// RSAMaxMessageLength 计算 RSA 加密时的最大消息长度
func RSAMaxMessageLength(publicKey *rsa.PublicKey, padding string) (int, error) <span class="cov5" title="5">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return 0, errors.New("public key is nil")
        }</span>

        <span class="cov4" title="4">keySize := publicKey.Size()
        
        switch padding </span>{
        case "OAEP":<span class="cov2" title="2">
                // OAEP: keySize - 2*hashLen - 2 (SHA256 hash length is 32 bytes)
                return keySize - 2*32 - 2, nil</span>
        case "PKCS1v15":<span class="cov1" title="1">
                // PKCS1v15: keySize - 11
                return keySize - 11, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unsupported padding: %s", padding)</span>
        }
}</pre>
		
		<pre class="file" id="file102" style="display: none">package cryptox

import (
        "github.com/google/uuid"
        "strings"
)

func UUID() string <span class="cov10" title="3">{
        return strings.ReplaceAll(uuid.NewString(), "-", "")
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">package defaults

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"
)

// DefaultFunc 自定义默认值函数类型
type DefaultFunc func() interface{}

// Options 配置选项
type Options struct {
        // ErrorMode 错误处理模式
        ErrorMode ErrorMode
        // CustomDefaults 自定义默认值函数映射
        CustomDefaults map[string]DefaultFunc
        // ValidateDefaults 是否验证默认值
        ValidateDefaults bool
        // AllowOverwrite 是否允许覆盖非零值
        AllowOverwrite bool
}

// ErrorMode 错误处理模式
type ErrorMode int

const (
        // ErrorModePanic 遇到错误时 panic（默认）
        ErrorModePanic ErrorMode = iota
        // ErrorModeIgnore 忽略错误，继续处理
        ErrorModeIgnore
        // ErrorModeReturn 返回错误
        ErrorModeReturn
)

var (
        // 默认配置
        defaultOptions = &amp;Options{
                ErrorMode:        ErrorModePanic,
                CustomDefaults:   make(map[string]DefaultFunc),
                ValidateDefaults: false,
                AllowOverwrite:   false,
        }
)

// SetDefaultsWithOptions 使用自定义选项设置默认值
func SetDefaultsWithOptions(value interface{}, opts *Options) error <span class="cov7" title="57">{
        if opts == nil </span><span class="cov1" title="1">{
                opts = defaultOptions
        }</span>
        
        <span class="cov7" title="57">return setDefaultWithOptions(reflect.ValueOf(value), "", opts)</span>
}

// SetDefaults 设置默认值（使用默认配置）
func SetDefaults(value interface{}) <span class="cov6" title="30">{
        err := SetDefaultsWithOptions(value, defaultOptions)
        if err != nil </span><span class="cov1" title="1">{
                panic(err)</span>
        }
}

// setDefaultWithOptions 内部实现函数
func setDefaultWithOptions(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov10" title="331">{
        if !vv.IsValid() </span><span class="cov1" title="1">{
                return handleError("invalid reflect value", opts.ErrorMode)
        }</span>

        <span class="cov9" title="330">switch vv.Kind() </span>{
        case reflect.String:<span class="cov6" title="47">
                return setStringDefault(vv, defaultStr, opts)</span>

        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov5" title="24">
                return setUintDefault(vv, defaultStr, opts)</span>

        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov7" title="69">
                return setIntDefault(vv, defaultStr, opts)</span>

        case reflect.Float32, reflect.Float64:<span class="cov5" title="14">
                return setFloatDefault(vv, defaultStr, opts)</span>

        case reflect.Bool:<span class="cov4" title="10">
                return setBoolDefault(vv, defaultStr, opts)</span>

        case reflect.Ptr:<span class="cov7" title="64">
                return setPtrDefault(vv, defaultStr, opts)</span>

        case reflect.Struct:<span class="cov7" title="71">
                return setStructDefault(vv, defaultStr, opts)</span>

        case reflect.Interface:<span class="cov2" title="2">
                return setInterfaceDefault(vv, defaultStr, opts)</span>

        case reflect.Slice:<span class="cov4" title="8">
                return setSliceDefault(vv, defaultStr, opts)</span>

        case reflect.Array:<span class="cov4" title="11">
                return setArrayDefault(vv, defaultStr, opts)</span>

        case reflect.Map:<span class="cov3" title="4">
                return setMapDefault(vv, defaultStr, opts)</span>

        case reflect.Chan:<span class="cov3" title="4">
                return setChanDefault(vv, defaultStr, opts)</span>

        case reflect.Func:<span class="cov1" title="1">
                return setFuncDefault(vv, defaultStr, opts)</span>

        default:<span class="cov1" title="1">
                return handleError(fmt.Sprintf("unsupported kind: %s", vv.Kind().String()), opts.ErrorMode)</span>
        }
}

// setStringDefault 设置字符串默认值
func setStringDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov6" title="47">{
        if shouldSetValue(vv.String() == "", defaultStr, opts.AllowOverwrite) </span><span class="cov6" title="30">{
                if customFunc, ok := opts.CustomDefaults["string"]; ok </span><span class="cov3" title="5">{
                        if val := customFunc(); val != nil </span><span class="cov3" title="4">{
                                if strVal, ok := val.(string); ok </span><span class="cov2" title="3">{
                                        vv.SetString(strVal)
                                }</span>
                        }
                } else<span class="cov5" title="25"> if defaultStr != "" </span><span class="cov5" title="25">{
                        vv.SetString(defaultStr)
                }</span>
        }
        <span class="cov6" title="47">return nil</span>
}

// setUintDefault 设置无符号整数默认值
func setUintDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov5" title="24">{
        if shouldSetValue(vv.Uint() == 0, defaultStr, opts.AllowOverwrite) </span><span class="cov5" title="23">{
                if customFunc, ok := opts.CustomDefaults["uint"]; ok </span><span class="cov2" title="2">{
                        if val := customFunc(); val != nil </span><span class="cov1" title="1">{
                                if uintVal, ok := val.(uint64); ok </span><span class="cov1" title="1">{
                                        vv.SetUint(uintVal)
                                }</span>
                        }
                } else<span class="cov5" title="21"> if defaultStr != "" </span><span class="cov5" title="21">{
                        val, err := strconv.ParseUint(defaultStr, 10, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                return handleError(fmt.Sprintf("invalid default value for uint field: %s", defaultStr), opts.ErrorMode)
                        }</span>
                        <span class="cov5" title="20">vv.SetUint(val)</span>
                }
        }
        <span class="cov5" title="23">return nil</span>
}

// setIntDefault 设置整数默认值
func setIntDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov7" title="69">{
        if shouldSetValue(vv.Int() == 0, defaultStr, opts.AllowOverwrite) </span><span class="cov7" title="51">{
                if customFunc, ok := opts.CustomDefaults["int"]; ok </span><span class="cov1" title="1">{
                        if val := customFunc(); val != nil </span><span class="cov1" title="1">{
                                if intVal, ok := val.(int64); ok </span><span class="cov1" title="1">{
                                        vv.SetInt(intVal)
                                }</span>
                        }
                } else<span class="cov7" title="50"> if defaultStr != "" </span><span class="cov7" title="50">{
                        val, err := strconv.ParseInt(defaultStr, 10, 64)
                        if err != nil </span><span class="cov4" title="11">{
                                return handleError(fmt.Sprintf("invalid default value for int field: %s", defaultStr), opts.ErrorMode)
                        }</span>
                        <span class="cov6" title="39">vv.SetInt(val)</span>
                }
        }
        <span class="cov7" title="58">return nil</span>
}

// setFloatDefault 设置浮点数默认值
func setFloatDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov5" title="14">{
        if shouldSetValue(vv.Float() == 0, defaultStr, opts.AllowOverwrite) </span><span class="cov4" title="13">{
                if customFunc, ok := opts.CustomDefaults["float"]; ok </span><span class="cov2" title="2">{
                        if val := customFunc(); val != nil </span><span class="cov2" title="2">{
                                if floatVal, ok := val.(float64); ok </span><span class="cov1" title="1">{
                                        vv.SetFloat(floatVal)
                                }</span>
                        }
                } else<span class="cov4" title="11"> if defaultStr != "" </span><span class="cov4" title="11">{
                        val, err := strconv.ParseFloat(defaultStr, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                return handleError(fmt.Sprintf("invalid default value for float field: %s", defaultStr), opts.ErrorMode)
                        }</span>
                        <span class="cov4" title="10">vv.SetFloat(val)</span>
                }
        }
        <span class="cov4" title="13">return nil</span>
}

// setBoolDefault 设置布尔值默认值
func setBoolDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov4" title="10">{
        if shouldSetValue(vv.Bool() == false, defaultStr, opts.AllowOverwrite) </span><span class="cov4" title="9">{
                if customFunc, ok := opts.CustomDefaults["bool"]; ok </span><span class="cov2" title="2">{
                        if val := customFunc(); val != nil </span><span class="cov2" title="2">{
                                if boolVal, ok := val.(bool); ok </span><span class="cov1" title="1">{
                                        vv.SetBool(boolVal)
                                }</span>
                        }
                } else<span class="cov4" title="7"> if defaultStr != "" </span><span class="cov4" title="7">{
                        val, err := strconv.ParseBool(defaultStr)
                        if err != nil </span><span class="cov1" title="1">{
                                return handleError(fmt.Sprintf("invalid default value for bool field: %s", defaultStr), opts.ErrorMode)
                        }</span>
                        <span class="cov3" title="6">vv.SetBool(val)</span>
                }
        }
        <span class="cov4" title="9">return nil</span>
}

// setPtrDefault 设置指针默认值
func setPtrDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov7" title="64">{
        if vv.IsNil() </span><span class="cov4" title="8">{
                vv.Set(reflect.New(vv.Type().Elem()))
        }</span>
        
        // 处理多层指针
        <span class="cov7" title="64">for vv.Kind() == reflect.Ptr </span><span class="cov7" title="67">{
                vv = vv.Elem()
                if vv.Kind() == reflect.Ptr &amp;&amp; vv.IsNil() </span><span class="cov2" title="3">{
                        vv.Set(reflect.New(vv.Type().Elem()))
                }</span>
        }
        
        <span class="cov7" title="64">return setDefaultWithOptions(vv, defaultStr, opts)</span>
}

// setStructDefault 设置结构体默认值
func setStructDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov7" title="71">{
        // 处理特殊类型
        if vv.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov3" title="5">{
                return setTimeDefault(vv, defaultStr, opts)
        }</span>

        <span class="cov7" title="66">for i := 0; i &lt; vv.NumField(); i++ </span><span class="cov8" title="153">{
                field := vv.Field(i)
                fieldType := vv.Type().Field(i)

                if !field.CanSet() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov8" title="152">defaultTag := fieldType.Tag.Get("default")
                if err := setDefaultWithOptions(field, defaultTag, opts); err != nil </span><span class="cov5" title="18">{
                        if opts.ErrorMode == ErrorModeReturn </span><span class="cov5" title="18">{
                                return fmt.Errorf("failed to set default for field %s: %w", fieldType.Name, err)
                        }</span>
                }
        }
        <span class="cov6" title="43">return nil</span>
}

// setTimeDefault 设置时间默认值
func setTimeDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov3" title="5">{
        if shouldSetValue(vv.Interface().(time.Time).IsZero(), defaultStr, opts.AllowOverwrite) </span><span class="cov3" title="5">{
                if defaultStr == "now" </span><span class="cov1" title="1">{
                        vv.Set(reflect.ValueOf(time.Now()))
                }</span> else<span class="cov3" title="4"> if defaultStr != "" </span><span class="cov3" title="4">{
                        // 尝试解析时间字符串
                        layouts := []string{
                                time.RFC3339,
                                time.RFC3339Nano,
                                "2006-01-02 15:04:05",
                                "2006-01-02",
                                "15:04:05",
                        }
                        
                        var t time.Time
                        var err error
                        for _, layout := range layouts </span><span class="cov4" title="13">{
                                t, err = time.Parse(layout, defaultStr)
                                if err == nil </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        
                        <span class="cov3" title="4">if err != nil </span><span class="cov1" title="1">{
                                return handleError(fmt.Sprintf("invalid time format: %s", defaultStr), opts.ErrorMode)
                        }</span>
                        <span class="cov2" title="3">vv.Set(reflect.ValueOf(t))</span>
                }
        }
        <span class="cov3" title="4">return nil</span>
}

// setInterfaceDefault 设置接口默认值
func setInterfaceDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov2" title="2">{
        // 接口类型通常不设置默认值，除非有特殊指定
        if defaultStr != "" &amp;&amp; vv.IsNil() </span><span class="cov2" title="2">{
                // 尝试设置简单类型的默认值
                if strings.Contains(defaultStr, "{") || strings.Contains(defaultStr, "[") </span><span class="cov1" title="1">{
                        // JSON 格式
                        var result interface{}
                        if err := json.Unmarshal([]byte(defaultStr), &amp;result); err == nil </span><span class="cov1" title="1">{
                                vv.Set(reflect.ValueOf(result))
                        }</span>
                } else<span class="cov1" title="1"> {
                        // 简单字符串
                        vv.Set(reflect.ValueOf(defaultStr))
                }</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// setSliceDefault 设置切片默认值
func setSliceDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov4" title="8">{
        if vv.IsNil() </span><span class="cov4" title="7">{
                if defaultStr == "" </span><span class="cov1" title="1">{
                        // 初始化为空切片
                        vv.Set(reflect.MakeSlice(vv.Type(), 0, 0))
                }</span> else<span class="cov3" title="6"> {
                        // 解析默认值
                        if err := parseSliceDefault(vv, defaultStr, opts); err != nil </span><span class="cov2" title="2">{
                                return err
                        }</span>
                }
        }
        
        // 为已存在的切片元素设置默认值
        <span class="cov3" title="6">for i := 0; i &lt; vv.Len(); i++ </span><span class="cov5" title="16">{
                elem := vv.Index(i)
                if elem.CanSet() </span><span class="cov5" title="16">{
                        if err := setDefaultWithOptions(elem, "", opts); err != nil &amp;&amp; opts.ErrorMode == ErrorModeReturn </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
        }
        
        <span class="cov3" title="5">return nil</span>
}

// setArrayDefault 设置数组默认值
func setArrayDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov4" title="11">{
        if defaultStr != "" </span><span class="cov4" title="10">{
                if err := parseArrayDefault(vv, defaultStr, opts); err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>
        }
        
        // 为数组元素设置默认值
        <span class="cov4" title="9">for i := 0; i &lt; vv.Len(); i++ </span><span class="cov5" title="15">{
                elem := vv.Index(i)
                if elem.CanSet() </span><span class="cov5" title="15">{
                        if err := setDefaultWithOptions(elem, "", opts); err != nil &amp;&amp; opts.ErrorMode == ErrorModeReturn </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
        }
        
        <span class="cov4" title="8">return nil</span>
}

// setMapDefault 设置映射默认值
func setMapDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov3" title="4">{
        if vv.IsNil() </span><span class="cov3" title="4">{
                if defaultStr == "" </span><span class="cov1" title="1">{
                        // 初始化为空映射
                        vv.Set(reflect.MakeMap(vv.Type()))
                }</span> else<span class="cov2" title="3"> {
                        // 解析默认值
                        if err := parseMapDefault(vv, defaultStr, opts); err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
        }
        <span class="cov2" title="3">return nil</span>
}

// setChanDefault 设置通道默认值
func setChanDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov3" title="4">{
        if vv.IsNil() &amp;&amp; defaultStr != "" </span><span class="cov3" title="4">{
                // 解析缓冲区大小
                bufSize := 0
                if defaultStr != "0" </span><span class="cov2" title="3">{
                        var err error
                        bufSize, err = strconv.Atoi(defaultStr)
                        if err != nil </span><span class="cov1" title="1">{
                                return handleError(fmt.Sprintf("invalid channel buffer size: %s", defaultStr), opts.ErrorMode)
                        }</span>
                }
                <span class="cov2" title="3">vv.Set(reflect.MakeChan(vv.Type(), bufSize))</span>
        }
        <span class="cov2" title="3">return nil</span>
}

// setFuncDefault 设置函数默认值
func setFuncDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov1" title="1">{
        // 函数类型通常不设置默认值
        // 如果需要，可以通过自定义函数实现
        if customFunc, ok := opts.CustomDefaults["func"]; ok </span><span class="cov1" title="1">{
                if vv.IsNil() </span><span class="cov1" title="1">{
                        if val := customFunc(); val != nil </span><span class="cov1" title="1">{
                                if reflect.TypeOf(val).AssignableTo(vv.Type()) </span><span class="cov1" title="1">{
                                        vv.Set(reflect.ValueOf(val))
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return nil</span>
}

// parseSliceDefault 解析切片默认值
func parseSliceDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov3" title="6">{
        // 尝试 JSON 解析
        if strings.HasPrefix(defaultStr, "[") &amp;&amp; strings.HasSuffix(defaultStr, "]") </span><span class="cov2" title="3">{
                // 创建切片类型的实例用于解析
                slicePtr := reflect.New(vv.Type())
                if err := json.Unmarshal([]byte(defaultStr), slicePtr.Interface()); err == nil </span><span class="cov2" title="2">{
                        vv.Set(slicePtr.Elem())
                        return nil
                }</span>
        }
        
        // 简单值解析，用逗号分隔
        <span class="cov3" title="4">if strings.Contains(defaultStr, ",") </span><span class="cov2" title="3">{
                parts := strings.Split(defaultStr, ",")
                slice := reflect.MakeSlice(vv.Type(), len(parts), len(parts))
                
                for i, part := range parts </span><span class="cov4" title="8">{
                        elem := slice.Index(i)
                        if err := setDefaultWithOptions(elem, strings.TrimSpace(part), opts); err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
                <span class="cov2" title="2">vv.Set(slice)
                return nil</span>
        }
        
        <span class="cov1" title="1">return handleError(fmt.Sprintf("unable to parse slice default: %s", defaultStr), opts.ErrorMode)</span>
}

// parseArrayDefault 解析数组默认值
func parseArrayDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov5" title="17">{
        // 类似于切片的解析逻辑
        if strings.HasPrefix(defaultStr, "[") &amp;&amp; strings.HasSuffix(defaultStr, "]") </span><span class="cov2" title="2">{
                arrayPtr := reflect.New(vv.Type())
                if err := json.Unmarshal([]byte(defaultStr), arrayPtr.Interface()); err == nil </span><span class="cov2" title="2">{
                        vv.Set(arrayPtr.Elem())
                        return nil
                }</span>
        }
        
        // 简单值解析
        <span class="cov5" title="15">if strings.Contains(defaultStr, ",") </span><span class="cov5" title="14">{
                parts := strings.Split(defaultStr, ",")
                maxParts := vv.Len()
                // 只有在数组有容量时才截断，这样零长度数组会保持parts不截断
                // 从而在循环中触发边界检查
                if len(parts) &gt; maxParts &amp;&amp; maxParts &gt; 0 </span><span class="cov3" title="6">{
                        parts = parts[:maxParts]
                }</span>
                
                <span class="cov5" title="14">for i, part := range parts </span><span class="cov5" title="21">{
                        if i &gt;= vv.Len() </span><span class="cov3" title="4">{
                                break</span> // 对于零长度数组，这个分支现在可以被触发
                        }
                        <span class="cov5" title="17">elem := vv.Index(i)
                        if err := setDefaultWithOptions(elem, strings.TrimSpace(part), opts); err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
                <span class="cov4" title="13">return nil</span>
        }
        
        <span class="cov1" title="1">return handleError(fmt.Sprintf("unable to parse array default: %s", defaultStr), opts.ErrorMode)</span>
}

// parseMapDefault 解析映射默认值
func parseMapDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov2" title="3">{
        // 尝试 JSON 解析
        if strings.HasPrefix(defaultStr, "{") &amp;&amp; strings.HasSuffix(defaultStr, "}") </span><span class="cov2" title="3">{
                mapPtr := reflect.New(vv.Type())
                if err := json.Unmarshal([]byte(defaultStr), mapPtr.Interface()); err == nil </span><span class="cov2" title="2">{
                        vv.Set(mapPtr.Elem())
                        return nil
                }</span>
        }
        
        <span class="cov1" title="1">return handleError(fmt.Sprintf("unable to parse map default: %s", defaultStr), opts.ErrorMode)</span>
}

// shouldSetValue 判断是否应该设置值
func shouldSetValue(isZeroValue bool, defaultStr string, allowOverwrite bool) bool <span class="cov8" title="169">{
        return (isZeroValue || allowOverwrite) &amp;&amp; defaultStr != ""
}</span>

// handleError 处理错误
func handleError(msg string, mode ErrorMode) error <span class="cov5" title="21">{
        switch mode </span>{
        case ErrorModePanic:<span class="cov3" title="5">
                panic(msg)</span>
        case ErrorModeIgnore:<span class="cov1" title="1">
                return nil</span>
        case ErrorModeReturn:<span class="cov5" title="14">
                return fmt.Errorf("%s", msg)</span>
        default:<span class="cov1" title="1">
                panic(msg)</span>
        }
}

// RegisterCustomDefault 注册自定义默认值函数
func RegisterCustomDefault(typeName string, fn DefaultFunc) <span class="cov4" title="9">{
        if defaultOptions.CustomDefaults == nil </span><span class="cov1" title="1">{
                defaultOptions.CustomDefaults = make(map[string]DefaultFunc)
        }</span>
        <span class="cov4" title="9">defaultOptions.CustomDefaults[typeName] = fn</span>
}

// ClearCustomDefaults 清除所有自定义默认值函数
func ClearCustomDefaults() <span class="cov4" title="9">{
        defaultOptions.CustomDefaults = make(map[string]DefaultFunc)
}</pre>
		
		<pre class="file" id="file104" style="display: none">package event

import (
        "github.com/lazygophers/utils/routine"
        "github.com/lazygophers/utils/runtime"
        "sync"
)

var defaultManager = NewManager()

type EventHandler func(args any)

type eventItem struct {
        handler EventHandler

        async bool
}

type Manager struct {
        eventMux sync.RWMutex
        events   map[string][]*eventItem
        c        chan *emitItem
}

func (p *Manager) register(eventName string, item *eventItem) <span class="cov0" title="0">{
        p.eventMux.Lock()
        defer p.eventMux.Unlock()

        p.events[eventName] = append(p.events[eventName], item)
}</span>

func Register(eventName string, handler EventHandler) <span class="cov0" title="0">{
        defaultManager.Register(eventName, handler)
}</span>

func (p *Manager) Register(eventName string, handler EventHandler) <span class="cov0" title="0">{
        p.register(eventName, &amp;eventItem{
                handler: handler,
        })
}</span>

func RegisterAsync(eventName string, handler EventHandler) <span class="cov0" title="0">{
        defaultManager.RegisterAsync(eventName, handler)
}</span>

func (p *Manager) RegisterAsync(eventName string, handler EventHandler) <span class="cov0" title="0">{
        p.register(eventName, &amp;eventItem{
                handler: handler,
                async:   true,
        })
}</span>

func (p *Manager) getItems(eventName string) []*eventItem <span class="cov0" title="0">{
        p.eventMux.RLock()
        defer p.eventMux.RUnlock()

        return p.events[eventName]
}</span>

func Emit(eventName string, args any) <span class="cov0" title="0">{
        defaultManager.Emit(eventName, args)
}</span>

type emitItem struct {
        handler EventHandler
        args    any
}

func (p *emitItem) do() <span class="cov0" title="0">{
        defer runtime.CachePanic()

        p.handler(p.args)
}</span>

func (p *Manager) Emit(eventName string, args any) <span class="cov0" title="0">{
        for _, event := range p.getItems(eventName) </span><span class="cov0" title="0">{
                if event.async </span><span class="cov0" title="0">{
                        p.c &lt;- &amp;emitItem{
                                handler: event.handler,
                                args:    args,
                        }
                        continue</span>
                }

                <span class="cov0" title="0">event.handler(args)</span>
        }
}

func NewManager() *Manager <span class="cov0" title="0">{
        p := &amp;Manager{
                events: make(map[string][]*eventItem),

                c: make(chan *emitItem, 10),
        }

        routine.GoWithRecover(func() (err error) </span><span class="cov0" title="0">{
                for item := range p.c </span><span class="cov0" title="0">{
                        item.do()
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return p</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package fake

import "github.com/lazygophers/utils/randx"

var userAgents = []string{
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; Moto C Build/NRD90M.059) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-G532M Build/MMB29T; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/55.0.2883.91 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1.1; SM-J120M Build/LMY47X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; Moto G (5) Build/NPPS25.137-93-14) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-G570M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0; CAM-L03 Build/HUAWEICAM-L03) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.44 Safari/534.7",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3",
        "Mozilla/5.0 (Linux; Android 8.0.0; FIG-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.237 Safari/534.10",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36",
        "Mozilla/5.0 (X11; Datanyze; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1.1; SM-J111M Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.107 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-J700M Build/MMB29K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.63 Safari/537.36",
        "Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Slackware/Chrome/12.0.742.100 Safari/534.30",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36",
        "Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 8.0.0; WAS-LX3 Build/HUAWEIWAS-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.1805 Safari/537.36 MVisionPlayer/1.0.0.0",
        "Mozilla/5.0 (Linux; Android 7.0; TRT-LX3 Build/HUAWEITRT-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.89 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0; vivo 1610 Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.124 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 4.4.2; de-de; SAMSUNG GT-I9195 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Version/1.5 Chrome/28.0.1500.94 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 8.0.0; ANE-LX3 Build/HUAWEIANE-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (X11; U; Linux i586; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.65 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-G610M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-J500M Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.44 Safari/534.7",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.104 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0; vivo 1606 Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.124 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-G610M Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.1; vivo 1716 Build/N2G47H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.98 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-G570M Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0; MYA-L22 Build/HUAWEIMYA-L22) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1; A1601 Build/LMY47I) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.98 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; TRT-LX2 Build/HUAWEITRT-LX2; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/59.0.3071.125 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/10.0.649.0 Safari/534.17",
        "Mozilla/5.0 (Linux; Android 6.0; CAM-L21 Build/HUAWEICAM-L21; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.3 Safari/534.24",
        "Mozilla/5.0 (Linux; Android 7.1.2; Redmi 4X Build/N2G47H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 4.4.2; SM-G7102 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.109 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1; HUAWEI CUN-L22 Build/HUAWEICUN-L22; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1.1; A37fw Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-J730GM Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-G610F Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.1.2; Redmi Note 5A Build/N2G47H; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; Redmi Note 4 Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36",
        "Mozilla/5.0 (Unknown; Linux) AppleWebKit/538.1 (KHTML, like Gecko) Chrome/v1.0.0 Safari/538.1",
        "Mozilla/5.0 (Linux; Android 7.0; BLL-L22 Build/HUAWEIBLL-L22) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.91 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-J710F Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-G532M Build/MMB29T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.91 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.1.1; CPH1723 Build/N6F26Q) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.98 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 8.0.0; FIG-LX3 Build/HUAWEIFIG-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 6.1; de-DE) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/10.0.649.0 Safari/534.17",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.63 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.65 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.1; Mi A1 Build/N2G47H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.83 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36 MVisionPlayer/1.0.0.0",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1; A37f Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.93 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; CPH1607 Build/MMB29M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; vivo 1603 Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.83 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-G532M Build/MMB29T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; Redmi 4A Build/MMB29M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/60.0.3112.116 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.157 Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.71 Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-G532G Build/MMB29T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.83 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.109 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.131 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0; vivo 1713 Build/MRA58K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.124 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36"}

func RandomUserAgent() string <span class="cov0" title="0">{
        return randx.Choose(userAgents)
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">package hystrix

import (
        "errors"
        "sync"
        "sync/atomic"
        "time"
        "unsafe"
)

// requestResult 保存单个请求的执行结果
type requestResult struct {
        success bool
        time    time.Time
}

// State 熔断器状态类型
type State string

const (
        Closed   State = "closed"    // closed 表示熔断关闭（服务可用）
        Open     State = "open"      // open 表示熔断开启（服务不可用）
        HalfOpen State = "half-open" // half-open 表示半开状态（尝试探测）
)

// StateChange 状态变化回调函数类型
type StateChange func(oldState, newState State)

// ReadyToTrip 熔断条件判断函数类型
// 根据成功/失败次数返回是否需要熔断
type ReadyToTrip func(successes, failures uint64) bool

// Probe 探测函数类型
// 半开状态下决定是否尝试调用服务
type Probe func() bool

// CircuitBreakerConfig 熔断器配置参数
type CircuitBreakerConfig struct {
        TimeWindow    time.Duration // 统计成功率的时间窗口
        OnStateChange StateChange   // 状态变化回调函数
        ReadyToTrip   ReadyToTrip   // 熔断条件判断函数
        Probe         Probe         // 半开状态探测函数
        BufferSize    int           // 请求结果缓存的大小，默认1000
}

// CircuitBreaker 高性能优化版本的熔断器
type CircuitBreaker struct {
        // 配置参数 (只读，无需同步)
        timeWindow    int64 // 纳秒
        onStateChange StateChange
        readyToTrip   ReadyToTrip
        probe         Probe
        bufferSize    int

        // 状态管理 (原子操作优化)
        state atomic.Uint32 // 0=Closed, 1=Open, 2=HalfOpen

        // 统计计数器 (内存对齐优化，避免伪共享)
        stats struct {
                successes       atomic.Uint64
                _               [56]byte // 缓存行填充
                failures        atomic.Uint64
                _               [56]byte // 缓存行填充
                lastCleanupTime atomic.Int64
                _               [56]byte // 缓存行填充
                changed         atomic.Uint32 // 0=false, 1=true
                _               [60]byte // 缓存行填充
        }

        // 环形缓冲区优化
        ringBuffer *optimizedRingBuffer
}

// optimizedRingBuffer 优化的环形缓冲区
type optimizedRingBuffer struct {
        // 使用连续内存块减少间接访问
        buffer []int64 // 紧凑存储：高32位存储时间戳(相对)，低32位存储状态+标志
        _      [56]byte
        head   atomic.Uint64
        _      [56]byte
        tail   atomic.Uint64
        _      [56]byte
        size   uint64
        mask   uint64 // size-1，用于快速取模
}

const (
        stateClosedOpt   = 0
        stateOpenOpt     = 1
        stateHalfOpenOpt = 2

        // 紧凑存储标志位
        successFlag = 0x01
        timeShift   = 32
)

// NewCircuitBreaker 创建优化版本的熔断器
func NewCircuitBreaker(c CircuitBreakerConfig) *CircuitBreaker <span class="cov5" title="11">{
        if c.Probe == nil </span><span class="cov5" title="11">{
                c.Probe = ProbeWithChance(50)
        }</span>

        <span class="cov5" title="11">if c.ReadyToTrip == nil </span><span class="cov5" title="9">{
                c.ReadyToTrip = func(successes, failures uint64) bool </span><span class="cov3" title="3">{
                        total := successes + failures
                        return total &gt;= 10 &amp;&amp; failures &gt; successes
                }</span>
        }

        <span class="cov5" title="11">if c.BufferSize &lt;= 0 </span><span class="cov5" title="11">{
                c.BufferSize = 1000
        }</span>

        // 确保 BufferSize 是2的幂，用于快速取模
        <span class="cov5" title="11">bufferSize := 1
        for bufferSize &lt; c.BufferSize </span><span class="cov10" title="110">{
                bufferSize &lt;&lt;= 1
        }</span>

        <span class="cov5" title="11">cb := &amp;CircuitBreaker{
                timeWindow:    c.TimeWindow.Nanoseconds(),
                onStateChange: c.OnStateChange,
                readyToTrip:   c.ReadyToTrip,
                probe:         c.Probe,
                bufferSize:    bufferSize,
                ringBuffer:    newOptimizedRingBuffer(bufferSize),
        }

        cb.state.Store(stateClosedOpt)
        cb.stats.changed.Store(1)
        cb.stats.lastCleanupTime.Store(time.Now().UnixNano())

        return cb</span>
}

// newOptimizedRingBuffer 创建优化的环形缓冲区
func newOptimizedRingBuffer(size int) *optimizedRingBuffer <span class="cov5" title="12">{
        return &amp;optimizedRingBuffer{
                buffer: make([]int64, size),
                size:   uint64(size),
                mask:   uint64(size - 1),
        }
}</span>

// Before 判断是否允许执行新请求 (无锁优化)
func (p *CircuitBreaker) Before() bool <span class="cov6" title="14">{
        p.updateStateOptimized()

        state := p.state.Load()
        switch state </span>{
        case stateClosedOpt:<span class="cov4" title="7">
                return true</span>
        case stateOpenOpt:<span class="cov4" title="5">
                return false</span>
        case stateHalfOpenOpt:<span class="cov2" title="2">
                return p.probe()</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// After 记录请求执行结果 (无锁优化)
func (p *CircuitBreaker) After(success bool) <span class="cov5" title="13">{
        now := time.Now().UnixNano()
        
        // 紧凑存储：时间戳(相对) + 成功标志
        baseTime := p.stats.lastCleanupTime.Load()
        relativeTime := now - baseTime
        if relativeTime &lt; 0 </span><span class="cov0" title="0">{
                relativeTime = 0
        }</span>
        
        <span class="cov5" title="13">var packed int64
        if relativeTime &gt; 0x7FFFFFFF </span><span class="cov0" title="0">{ // 超过32位，使用绝对时间
                packed = now &lt;&lt; timeShift
        }</span> else<span class="cov5" title="13"> {
                packed = relativeTime &lt;&lt; timeShift
        }</span>
        
        <span class="cov5" title="13">if success </span><span class="cov3" title="3">{
                packed |= successFlag
                p.stats.successes.Add(1)
        }</span> else<span class="cov5" title="10"> {
                p.stats.failures.Add(1)
        }</span>

        // 无锁添加到环形缓冲区
        <span class="cov5" title="13">p.ringBuffer.addOptimized(packed)
        p.stats.changed.Store(1)</span>
}

// addOptimized 无锁添加元素到环形缓冲区
func (rb *optimizedRingBuffer) addOptimized(packed int64) <span class="cov6" title="14">{
        tail := rb.tail.Add(1) - 1
        rb.buffer[tail&amp;rb.mask] = packed
}</span>

// updateStateOptimized 无锁状态更新
func (p *CircuitBreaker) updateStateOptimized() <span class="cov6" title="14">{
        if p.stats.changed.Load() == 0 &amp;&amp; !p.cleanUpOptimized() </span><span class="cov4" title="5">{
                return
        }</span>

        // 使用CAS避免锁竞争
        <span class="cov5" title="9">if !p.stats.changed.CompareAndSwap(1, 0) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov5" title="9">oldState := p.state.Load()
        successes := p.stats.successes.Load()
        failures := p.stats.failures.Load()

        shouldTrip := p.readyToTrip(successes, failures)
        var newState uint32

        switch oldState </span>{
        case stateClosedOpt:<span class="cov5" title="9">
                if shouldTrip </span><span class="cov2" title="2">{
                        newState = stateOpenOpt
                }</span> else<span class="cov4" title="7"> {
                        newState = stateClosedOpt
                }</span>
        case stateOpenOpt:<span class="cov0" title="0">
                if !shouldTrip </span><span class="cov0" title="0">{
                        newState = stateHalfOpenOpt
                }</span> else<span class="cov0" title="0"> {
                        newState = stateOpenOpt
                }</span>
        case stateHalfOpenOpt:<span class="cov0" title="0">
                if p.ringBuffer.hasRecentRequest() </span><span class="cov0" title="0">{
                        if p.ringBuffer.lastRequestSuccess() </span><span class="cov0" title="0">{
                                newState = stateClosedOpt
                                p.ringBuffer.reset()
                        }</span> else<span class="cov0" title="0"> {
                                newState = stateOpenOpt
                        }</span>
                } else<span class="cov0" title="0"> {
                        newState = stateHalfOpenOpt
                }</span>
        default:<span class="cov0" title="0">
                newState = stateClosedOpt</span>
        }

        <span class="cov5" title="9">if p.state.CompareAndSwap(oldState, newState) &amp;&amp; oldState != newState &amp;&amp; p.onStateChange != nil </span><span class="cov0" title="0">{
                // 状态转换成功，触发回调
                oldStateEnum := stateFromUint32(oldState)
                newStateEnum := stateFromUint32(newState)
                p.onStateChange(oldStateEnum, newStateEnum)
        }</span>
}

// cleanUpOptimized 无锁清理过期数据
func (p *CircuitBreaker) cleanUpOptimized() bool <span class="cov4" title="5">{
        now := time.Now().UnixNano()
        lastCleanup := p.stats.lastCleanupTime.Load()
        
        if now-lastCleanup &lt; p.timeWindow </span><span class="cov4" title="5">{
                return false
        }</span>

        <span class="cov0" title="0">if !p.stats.lastCleanupTime.CompareAndSwap(lastCleanup, now) </span><span class="cov0" title="0">{
                return false // 其他goroutine已经在清理
        }</span>

        <span class="cov0" title="0">threshold := now - p.timeWindow
        removedSuccesses, removedFailures := p.ringBuffer.cleanupOptimized(threshold, lastCleanup)

        if removedSuccesses &gt; 0 || removedFailures &gt; 0 </span><span class="cov0" title="0">{
                p.stats.successes.Add(^(removedSuccesses - 1)) // 原子减法
                p.stats.failures.Add(^(removedFailures - 1))   // 原子减法
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// cleanupOptimized 无锁清理环形缓冲区
func (rb *optimizedRingBuffer) cleanupOptimized(threshold, baseTime int64) (removedSuccesses, removedFailures uint64) <span class="cov0" title="0">{
        head := rb.head.Load()
        tail := rb.tail.Load()

        for head &lt; tail </span><span class="cov0" title="0">{
                idx := head &amp; rb.mask
                packed := rb.buffer[idx]
                
                if packed == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // 解析时间戳
                <span class="cov0" title="0">var timestamp int64
                if packed&gt;&gt;timeShift &gt; 0x7FFFFFFF </span><span class="cov0" title="0">{
                        timestamp = packed &gt;&gt; timeShift // 绝对时间
                }</span> else<span class="cov0" title="0"> {
                        timestamp = baseTime + (packed &gt;&gt; timeShift) // 相对时间
                }</span>

                <span class="cov0" title="0">if timestamp &gt;= threshold </span><span class="cov0" title="0">{
                        break</span>
                }

                // 统计被清理的请求
                <span class="cov0" title="0">if packed&amp;successFlag != 0 </span><span class="cov0" title="0">{
                        removedSuccesses++
                }</span> else<span class="cov0" title="0"> {
                        removedFailures++
                }</span>

                // 清理数据防止内存泄漏
                <span class="cov0" title="0">rb.buffer[idx] = 0
                head++</span>
        }

        <span class="cov0" title="0">rb.head.Store(head)
        return</span>
}

// hasRecentRequest 检查是否有最近的请求
func (rb *optimizedRingBuffer) hasRecentRequest() bool <span class="cov1" title="1">{
        return rb.head.Load() &lt; rb.tail.Load()
}</span>

// lastRequestSuccess 获取最后一个请求的成功状态
func (rb *optimizedRingBuffer) lastRequestSuccess() bool <span class="cov1" title="1">{
        head := rb.head.Load()
        tail := rb.tail.Load()
        if head &gt;= tail </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov1" title="1">lastIdx := (tail - 1) &amp; rb.mask
        packed := rb.buffer[lastIdx]
        return packed&amp;successFlag != 0</span>
}

// reset 重置环形缓冲区
func (rb *optimizedRingBuffer) reset() <span class="cov1" title="1">{
        rb.head.Store(0)
        rb.tail.Store(0)
}</span>

// Call 执行服务调用 (优化版本)
func (p *CircuitBreaker) Call(fn func() error) error <span class="cov4" title="8">{
        if !p.Before() </span><span class="cov2" title="2">{
                return errors.New("circuit breaker is open")
        }</span>

        <span class="cov4" title="6">err := fn()
        p.After(err == nil)
        return err</span>
}

// State 返回当前熔断器状态
func (p *CircuitBreaker) State() State <span class="cov4" title="7">{
        return stateFromUint32(p.state.Load())
}</span>

// Stat 获取成功和失败计数
func (p *CircuitBreaker) Stat() (successes, failures uint64) <span class="cov4" title="5">{
        return p.stats.successes.Load(), p.stats.failures.Load()
}</span>

// Total 获取总请求数
func (p *CircuitBreaker) Total() uint64 <span class="cov2" title="2">{
        return p.stats.successes.Load() + p.stats.failures.Load()
}</span>

// 状态转换辅助函数
func stateFromUint32(state uint32) State <span class="cov4" title="7">{
        switch state </span>{
        case stateClosedOpt:<span class="cov3" title="4">
                return Closed</span>
        case stateOpenOpt:<span class="cov3" title="3">
                return Open</span>
        case stateHalfOpenOpt:<span class="cov0" title="0">
                return HalfOpen</span>
        default:<span class="cov0" title="0">
                return Closed</span>
        }
}

// FastCircuitBreaker 超轻量级版本 (仅基础功能)
type FastCircuitBreaker struct {
        state     atomic.Uint32 // 状态
        successes atomic.Uint64 // 成功计数
        failures  atomic.Uint64 // 失败计数
        lastReset atomic.Int64  // 上次重置时间

        threshold   uint64 // 失败阈值
        windowNanos int64  // 时间窗口(纳秒)
}

// NewFastCircuitBreaker 创建超轻量级熔断器
func NewFastCircuitBreaker(failureThreshold uint64, timeWindow time.Duration) *FastCircuitBreaker <span class="cov2" title="2">{
        cb := &amp;FastCircuitBreaker{
                threshold:   failureThreshold,
                windowNanos: timeWindow.Nanoseconds(),
        }
        cb.lastReset.Store(time.Now().UnixNano())
        return cb
}</span>

// AllowRequest 检查是否允许请求 (超快速)
func (cb *FastCircuitBreaker) AllowRequest() bool <span class="cov4" title="5">{
        now := time.Now().UnixNano()
        lastReset := cb.lastReset.Load()

        // 检查是否需要重置窗口
        if now-lastReset &gt; cb.windowNanos </span><span class="cov1" title="1">{
                if cb.lastReset.CompareAndSwap(lastReset, now) </span><span class="cov1" title="1">{
                        cb.successes.Store(0)
                        cb.failures.Store(0)
                        cb.state.Store(stateClosedOpt) // 重置状态到关闭
                }</span>
        }

        <span class="cov4" title="5">state := cb.state.Load()
        if state == stateOpenOpt </span><span class="cov2" title="2">{
                // 熔断状态：检查是否可以尝试半开
                return false
        }</span>

        <span class="cov3" title="3">return true</span> // Closed 或 HalfOpen 状态允许请求
}

// RecordResult 记录请求结果 (超快速)
func (cb *FastCircuitBreaker) RecordResult(success bool) <span class="cov4" title="6">{
        if success </span><span class="cov1" title="1">{
                cb.successes.Add(1)
        }</span> else<span class="cov4" title="5"> {
                failures := cb.failures.Add(1)
                if failures &gt;= cb.threshold </span><span class="cov2" title="2">{
                        cb.state.Store(stateOpenOpt)
                }</span>
        }
}

// CallFast 快速执行服务调用
func (cb *FastCircuitBreaker) CallFast(fn func() error) error <span class="cov0" title="0">{
        if !cb.AllowRequest() </span><span class="cov0" title="0">{
                return errors.New("circuit breaker is open")
        }</span>

        <span class="cov0" title="0">err := fn()
        cb.RecordResult(err == nil)
        
        // 半开状态的快速恢复逻辑
        if err == nil &amp;&amp; cb.state.Load() == stateHalfOpenOpt </span><span class="cov0" title="0">{
                cb.state.Store(stateClosedOpt)
        }</span>
        
        <span class="cov0" title="0">return err</span>
}

// 内存池优化 - 复用 requestResult 对象
var requestResultPool = sync.Pool{
        New: func() interface{} <span class="cov1" title="1">{
                return &amp;requestResult{}
        }</span>,
}

// getRequestResult 从池中获取对象
func getRequestResult() *requestResult <span class="cov2" title="2">{
        return requestResultPool.Get().(*requestResult)
}</span>

// putRequestResult 归还对象到池中
func putRequestResult(r *requestResult) <span class="cov1" title="1">{
        r.success = false
        r.time = time.Time{}
        requestResultPool.Put(r)
}</span>

// BatchCircuitBreaker 批量操作优化版本
type BatchCircuitBreaker struct {
        *CircuitBreaker
        batchSize    int
        batchBuffer  []bool
        batchIndex   atomic.Int32
        batchMutex   sync.Mutex
        batchTimeout time.Duration
        lastFlush    atomic.Int64
}

// NewBatchCircuitBreaker 创建批量处理版本
func NewBatchCircuitBreaker(config CircuitBreakerConfig, batchSize int, batchTimeout time.Duration) *BatchCircuitBreaker <span class="cov1" title="1">{
        if batchSize &lt;= 0 </span><span class="cov0" title="0">{
                batchSize = 100
        }</span>
        
        <span class="cov1" title="1">cb := &amp;BatchCircuitBreaker{
                CircuitBreaker:  NewCircuitBreaker(config),
                batchSize:       batchSize,
                batchBuffer:     make([]bool, batchSize),
                batchTimeout:    batchTimeout,
        }
        cb.lastFlush.Store(time.Now().UnixNano())
        
        // 启动定时刷新
        go cb.flushLoop()
        
        return cb</span>
}

// AfterBatch 批量记录结果
func (cb *BatchCircuitBreaker) AfterBatch(success bool) <span class="cov4" title="5">{
        now := time.Now().UnixNano()
        
        // 检查是否需要强制刷新
        if now-cb.lastFlush.Load() &gt; cb.batchTimeout.Nanoseconds() </span><span class="cov0" title="0">{
                cb.flush()
                return
        }</span>
        
        <span class="cov4" title="5">index := cb.batchIndex.Add(1) - 1
        if int(index) &gt;= cb.batchSize </span><span class="cov0" title="0">{
                cb.flush()
                cb.AfterBatch(success) // 重试
                return
        }</span>
        
        <span class="cov4" title="5">cb.batchBuffer[index] = success
        
        if int(index) &gt;= cb.batchSize-1 </span><span class="cov0" title="0">{
                cb.flush()
        }</span>
}

// flush 刷新批量数据
func (cb *BatchCircuitBreaker) flush() <span class="cov1" title="1">{
        cb.batchMutex.Lock()
        defer cb.batchMutex.Unlock()
        
        index := cb.batchIndex.Swap(0)
        if index == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov1" title="1">var successes, failures uint64
        for i := int32(0); i &lt; index; i++ </span><span class="cov4" title="5">{
                if cb.batchBuffer[i] </span><span class="cov4" title="5">{
                        successes++
                }</span> else<span class="cov0" title="0"> {
                        failures++
                }</span>
        }
        
        // 批量更新统计
        <span class="cov1" title="1">if successes &gt; 0 </span><span class="cov1" title="1">{
                cb.stats.successes.Add(successes)
        }</span>
        <span class="cov1" title="1">if failures &gt; 0 </span><span class="cov0" title="0">{
                cb.stats.failures.Add(failures)
        }</span>
        
        <span class="cov1" title="1">cb.stats.changed.Store(1)
        cb.lastFlush.Store(time.Now().UnixNano())</span>
}

// flushLoop 定时刷新循环
func (cb *BatchCircuitBreaker) flushLoop() <span class="cov1" title="1">{
        ticker := time.NewTicker(cb.batchTimeout)
        defer ticker.Stop()
        
        for range ticker.C </span><span class="cov0" title="0">{
                if cb.batchIndex.Load() &gt; 0 </span><span class="cov0" title="0">{
                        cb.flush()
                }</span>
        }
}

// 零分配版本的状态查询
func (p *CircuitBreaker) GetState() uint32 <span class="cov1" title="1">{
        return p.state.Load()
}</span>

// IsOpen 零分配检查是否熔断
func (p *CircuitBreaker) IsOpen() bool <span class="cov2" title="2">{
        return p.state.Load() == stateOpenOpt
}</span>

// IsClosed 零分配检查是否正常
func (p *CircuitBreaker) IsClosed() bool <span class="cov2" title="2">{
        return p.state.Load() == stateClosedOpt
}</span>

// ringBuffer 兼容性别名，保持向后兼容
type ringBuffer = optimizedRingBuffer

// newRingBuffer 兼容性函数
func newRingBuffer(size int) *ringBuffer <span class="cov1" title="1">{
        return newOptimizedRingBuffer(size)
}</span>

// add 兼容性方法
func (rb *ringBuffer) add(result *requestResult) <span class="cov1" title="1">{
        now := time.Now().UnixNano()
        packed := now &lt;&lt; timeShift
        if result.success </span><span class="cov1" title="1">{
                packed |= successFlag
        }</span>
        <span class="cov1" title="1">rb.addOptimized(packed)</span>
}

// cleanup 兼容性方法
func (rb *ringBuffer) cleanup(threshold int64) (removedSuccesses, removedFailures uint64) <span class="cov0" title="0">{
        return rb.cleanupOptimized(threshold, 0)
}</span>

// len 获取当前有效元素数量
func (rb *ringBuffer) len() int <span class="cov3" title="3">{
        tail := rb.tail.Load()
        head := rb.head.Load()
        return int(tail - head)
}</span>

// last 获取最近一次请求结果
func (rb *ringBuffer) last() *requestResult <span class="cov1" title="1">{
        if !rb.hasRecentRequest() </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // 返回兼容的 requestResult 对象
        <span class="cov1" title="1">result := &amp;requestResult{
                success: rb.lastRequestSuccess(),
                time:    time.Now(), // 近似时间
        }
        return result</span>
}

// 编译时检查接口是否被正确实现
var (
        _ unsafe.Pointer = unsafe.Pointer(&amp;CircuitBreaker{})
        _ unsafe.Pointer = unsafe.Pointer(&amp;FastCircuitBreaker{})
        _ unsafe.Pointer = unsafe.Pointer(&amp;BatchCircuitBreaker{})
)</pre>
		
		<pre class="file" id="file107" style="display: none">package hystrix

import "github.com/lazygophers/utils/randx"

// ProbeWithChance [0, 100]
func ProbeWithChance(percent float64) Probe <span class="cov10" title="11">{
        return func() bool </span><span class="cov0" title="0">{
                return randx.Booln(percent)
        }</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package json

import (
        "os"
)

func UnmarshalFromFile(filename string, v any) error <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return NewDecoder(file).Decode(v)</span>
}

func MustUnmarshalFromFile(filename string, v any) <span class="cov0" title="0">{
        err := UnmarshalFromFile(filename, v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func MarshalToFile(filename string, v any) error <span class="cov0" title="0">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return NewEncoder(file).Encode(v)</span>
}

func MustMarshalToFile(filename string, v any) <span class="cov0" title="0">{
        err := MarshalToFile(filename, v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package json

func MustMarshal(v any) []byte <span class="cov0" title="0">{
        buf, err := Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return buf</span>
}

func MustMarshalString(v any) string <span class="cov0" title="0">{
        buf, err := MarshalString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return buf</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package json

import (
        "bytes"
        "encoding/json"
)

func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error <span class="cov0" title="0">{
        return json.Indent(dst, src, prefix, indent)
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">//go:build (linux &amp;&amp; amd64) || darwin

package json

import (
        "github.com/bytedance/sonic"
        "io"
)

func Marshal(v any) ([]byte, error) <span class="cov0" title="0">{
        return sonic.Marshal(v)
}</span>

func Unmarshal(data []byte, v any) error <span class="cov0" title="0">{
        return sonic.Unmarshal(data, v)
}</span>

func MarshalString(v any) (string, error) <span class="cov0" title="0">{
        buf, err := sonic.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(buf), nil</span>
}

func UnmarshalString(data string, v any) error <span class="cov0" title="0">{
        return sonic.Unmarshal([]byte(data), v)
}</span>

func NewEncoder(w io.Writer) sonic.Encoder <span class="cov0" title="0">{
        return sonic.ConfigDefault.NewEncoder(w)
}</span>

func NewDecoder(r io.Reader) sonic.Decoder <span class="cov0" title="0">{
        return sonic.ConfigDefault.NewDecoder(r)
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package utils

import "github.com/lazygophers/log"

// MustOk 如果 ok 为 false 则触发 panic
// 返回 T 类型值用于链式调用
//
// 参数:
//
//        value: 需要验证的值
//        ok:    状态标识
//
// 返回:
//
//        T 类型值
func MustOk[T any](value T, ok bool) T <span class="cov0" title="0">{
        if !ok </span><span class="cov0" title="0">{
                log.Panic("is not ok")
        }</span>
        <span class="cov0" title="0">return value</span>
}

// MustSuccess 如果 error 不为 nil 则格式化 panic
// 用于验证函数执行状态
//
// 参数:
//
//        err: 错误对象
func MustSuccess(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("err:%s", err)
        }</span>
}

// Must 组合验证函数
// 先验证错误状态，成功后返回值对象
//
// 参数:
//
//        value: 准备返回的值对象
//        err:   需要验证的错误对象
//
// 返回:
//
//        T 类型值
func Must[T any](value T, err error) T <span class="cov0" title="0">{
        MustSuccess(err)
        return value
}</span>

// Ignore 强制忽略任意参数
// 用于处理需要显式声明但实际不使用的返回值
//
// 参数:
//
//        value: 需要返回的值
//        _:     被忽略的任意参数
//
// 返回:
//
//        T 类型值
func Ignore[T any](value T, _ any) T <span class="cov0" title="0">{
        return value
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package network

import (
        "net"
        "net/http"
        "strings"
)

func RealIpFromHeader(header http.Header) string <span class="cov10" title="40">{
        val := header.Get("Cf-Connecting-Ip")
        if val != "" </span><span class="cov5" title="6">{
                if !IsLocalIp(val) </span><span class="cov4" title="5">{
                        return val
                }</span>
        }

        <span class="cov9" title="35">val = header.Get("Cf-Pseudo-Ipv4")
        if val != "" </span><span class="cov2" title="2">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov9" title="34">val = header.Get("Cf-Connecting-Ipv6")
        if val != "" </span><span class="cov2" title="2">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov9" title="33">val = header.Get("Cf-Pseudo-Ipv6")
        if val != "" </span><span class="cov1" title="1">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov9" title="32">val = header.Get("Fastly-Client-Ip")
        if val != "" </span><span class="cov1" title="1">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov9" title="31">val = header.Get("True-Client-Ip")
        if val != "" </span><span class="cov1" title="1">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov9" title="30">val = header.Get("X-Real-IP")
        if val != "" </span><span class="cov6" title="8">{
                if !IsLocalIp(val) </span><span class="cov4" title="4">{
                        return val
                }</span>
        }

        <span class="cov8" title="26">val = header.Get("X-Client-IP")
        if val != "" </span><span class="cov1" title="1">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov8" title="25">val = header.Get("X-Original-Forwarded-For")
        if val != "" </span><span class="cov3" title="3">{
                for _, v := range strings.Split(val, ",") </span><span class="cov5" title="7">{
                        v = strings.TrimSpace(v)
                        if v != "" &amp;&amp; net.ParseIP(v) != nil &amp;&amp; !IsLocalIp(v) </span><span class="cov2" title="2">{
                                return v
                        }</span>
                }
        }

        <span class="cov8" title="23">val = header.Get("X-Forwarded-For")
        if val != "" </span><span class="cov6" title="9">{
                for _, v := range strings.Split(val, ",") </span><span class="cov8" title="24">{
                        v = strings.TrimSpace(v)
                        if v != "" &amp;&amp; net.ParseIP(v) != nil &amp;&amp; !IsLocalIp(v) </span><span class="cov5" title="6">{
                                return v
                        }</span>
                }
        }

        <span class="cov7" title="17">val = header.Get("X-Forwarded")
        if val != "" </span><span class="cov1" title="1">{
                for _, v := range strings.Split(val, ",") </span><span class="cov2" title="2">{
                        v = strings.TrimSpace(v)
                        if v != "" &amp;&amp; net.ParseIP(v) != nil &amp;&amp; !IsLocalIp(v) </span><span class="cov1" title="1">{
                                return v
                        }</span>
                }
        }

        <span class="cov7" title="16">val = header.Get("Forwarded-For")
        if val != "" </span><span class="cov1" title="1">{
                for _, v := range strings.Split(val, ",") </span><span class="cov2" title="2">{
                        v = strings.TrimSpace(v)
                        if v != "" &amp;&amp; net.ParseIP(v) != nil &amp;&amp; !IsLocalIp(v) </span><span class="cov1" title="1">{
                                return v
                        }</span>
                }
        }

        <span class="cov7" title="15">val = header.Get("Forwarded")
        if val != "" </span><span class="cov1" title="1">{
                for _, v := range strings.Split(val, ",") </span><span class="cov2" title="2">{
                        v = strings.TrimSpace(v)
                        if v != "" &amp;&amp; net.ParseIP(v) != nil &amp;&amp; !IsLocalIp(v) </span><span class="cov1" title="1">{
                                return v
                        }</span>
                }
        }

        <span class="cov7" title="14">return ""</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package network

import (
        "github.com/lazygophers/log"
        "net"
)

func GetInterfaceIpByName(name string, prev6 bool) string <span class="cov10" title="17">{
        inter, err := net.InterfaceByName(name)
        if err != nil </span><span class="cov8" title="11">{
                log.Debugf("err:%v", err)
                return ""
        }</span>

        <span class="cov6" title="6">address, err := inter.Addrs()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return ""
        }</span>

        <span class="cov6" title="6">return GetInterfaceIpByAddrs(address, prev6)</span>
}

func GetInterfaceIpByAddrs(address []net.Addr, prev6 bool) string <span class="cov9" title="16">{
        var v4 string
        for _, addr := range address </span><span class="cov10" title="17">{
                if ipnet, ok := addr.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() </span><span class="cov9" title="13">{
                        if ipnet.IP.To4() == nil &amp;&amp; ipnet.IP.To16() != nil </span><span class="cov3" title="2">{
                                // v6 的地址 (To4()为nil表示不是IPv4，但To16()不为nil表示是有效IP)
                                if prev6 </span><span class="cov3" title="2">{
                                        return ipnet.IP.String()
                                }</span>
                        } else<span class="cov8" title="11"> if ipnet.IP.To4() != nil </span><span class="cov8" title="11">{
                                // v4 地址
                                if !prev6 </span><span class="cov6" title="6">{
                                        return ipnet.IP.String()
                                }</span> else<span class="cov6" title="5"> {
                                        v4 = ipnet.IP.String()
                                }</span>
                        }
                }
        }

        <span class="cov7" title="8">return v4</span>
}

func GetListenIp(prev6 ...bool) string <span class="cov5" title="4">{
        // 找到内网 IP
        var _prev6 bool
        _prev6 = len(prev6) &gt; 0 &amp;&amp; prev6[0]

        // 先尝试一下常用 eth0 网卡
        if ip := GetInterfaceIpByName("eth0", _prev6); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>

        // 先尝试一下常用 en0 网卡
        <span class="cov5" title="4">if ip := GetInterfaceIpByName("en0", _prev6); ip != "" </span><span class="cov5" title="4">{
                return ip
        }</span>

        <span class="cov0" title="0">address, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return ""
        }</span>

        <span class="cov0" title="0">if ip := GetInterfaceIpByAddrs(address, _prev6); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>

        <span class="cov0" title="0">log.Error("get interface ip failed")

        return ""</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package network

import "net/netip"

func IsLocalIp(ip string) bool <span class="cov10" title="64">{
        i, err := netip.ParseAddr(ip)
        if err != nil </span><span class="cov4" title="4">{
                return false
        }</span>

        <span class="cov9" title="60">return i.IsPrivate() || i.IsLoopback() || i.IsLinkLocalUnicast()</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">// utils 包提供数据库操作的实用工具
// 主要功能包括：
// 1. 扫描数据库字段到结构体(Scan)
// 2. 将结构体转换为数据库值(Value)
// 3. 自动填充默认值和错误处理
package utils

import (
        "database/sql/driver"
        "fmt"
        "reflect"

        "github.com/lazygophers/log"
        "github.com/lazygophers/utils/json"

        "github.com/mcuadros/go-defaults"
        "github.com/pkg/errors"
)

// Scan 实现数据库字段到目标结构体的扫描逻辑
// 支持[]byte和string类型的源数据，自动调用defaults.SetDefaults填充默认值
// 参数:
//   - src: 数据源（[]byte或string）
//   - dst: 目标结构体指针
//
// 返回:
//   - error: 反序列化失败时返回错误
//
// 特殊处理:
// 1. 当src为JSON数组或对象时调用json.Unmarshal
// 2. 空字符串时调用defaults.SetDefaults
func Scan(src interface{}, dst interface{}) (err error) <span class="cov0" title="0">{
        x := func(buf []byte) error </span><span class="cov0" title="0">{
                bufLen := len(buf)
                if bufLen &gt;= 2 &amp;&amp; ((buf[0] == '{' &amp;&amp; buf[bufLen-1] == '}') || (buf[0] == '[' &amp;&amp; buf[bufLen-1] == ']')) </span><span class="cov0" title="0">{
                        err = json.Unmarshal(buf, dst)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("err:%v", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                } else<span class="cov0" title="0"> if bufLen &gt; 0 </span><span class="cov0" title="0">{
                        err = json.Unmarshal(buf, dst)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("err:%v", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                } else<span class="cov0" title="0"> {
                        defaults.SetDefaults(dst)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">switch r := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                buf := src.([]byte)
                return x(buf)</span>
        case string:<span class="cov0" title="0">
                buf := []byte(src.(string))
                return x(buf)</span>
        default:<span class="cov0" title="0">
                return errors.New(
                        fmt.Sprintf("unknown type %v %s to scan", r, reflect.ValueOf(src).String()))</span>
        }
}

func Value(m interface{}) (value driver.Value, err error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                defaults.SetDefaults(m)
        }</span>

        <span class="cov0" title="0">value, err = json.Marshal(m)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package osx

import (
        "io"
        "io/fs"
        "os"
)

func Exists(path string) bool <span class="cov6" title="21">{
        _, err := os.Stat(path)
        if err != nil </span><span class="cov5" title="13">{
                return os.IsExist(err)
        }</span>
        <span class="cov4" title="8">return true</span>
}

func IsDir(path string) bool <span class="cov3" title="5">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov2" title="2">{
                return false
        }</span>
        <span class="cov2" title="3">return info.IsDir()</span>
}

func IsFile(path string) bool <span class="cov3" title="5">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov2" title="2">{
                return false
        }</span>
        <span class="cov2" title="3">return !info.IsDir()</span>
}

func Exist(path string) bool <span class="cov6" title="24">{
        _, err := os.Stat(path)
        if err != nil </span><span class="cov4" title="9">{
                return false
        }</span>
        <span class="cov5" title="15">return true</span>
}

func FsHasFile(fs fs.FS, path string) bool <span class="cov5" title="11">{
        f, err := fs.Open(path)
        if err != nil </span><span class="cov3" title="4">{
                return false
        }</span>
        <span class="cov4" title="7">defer f.Close()
        return true</span>
}

func RenameForce(oldpath, newpath string) (err error) <span class="cov5" title="14">{
        if Exists(newpath) </span><span class="cov4" title="6">{
                err = os.RemoveAll(newpath)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov5" title="13">err = os.Rename(oldpath, newpath)
        if err != nil </span><span class="cov4" title="6">{
                return err
        }</span>
        <span class="cov4" title="7">return nil</span>
}

func Copy(src, dst string) error <span class="cov10" title="164">{
        srcFile, err := os.Open(src)
        if err != nil </span><span class="cov3" title="4">{
                return err
        }</span>
        <span class="cov9" title="160">defer srcFile.Close()

        stat, err := srcFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="160">dstFile, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, stat.Mode())
        if err != nil </span><span class="cov3" title="4">{
                return err
        }</span>
        <span class="cov9" title="156">defer dstFile.Close()

        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov9" title="154">return nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package pyroscope

import (
        "github.com/grafana/pyroscope-go"
        "github.com/lazygophers/log"
        "github.com/lazygophers/utils/app"
        "github.com/pterm/pterm"
        "os"
)

// docker run -itd -p 4040:4040 pyroscope/pyroscope:latest server
func load(address string) <span class="cov0" title="0">{
        if address == "" </span><span class="cov0" title="0">{
                address = "http://127.0.0.1:4040"
        }</span>

        <span class="cov0" title="0">log.Info("pyroscope address:", address)

        _, err := pyroscope.Start(pyroscope.Config{
                ApplicationName: app.Name,
                Tags:            map[string]string{"hostname": os.Getenv("HOSTNAME")},
                ServerAddress:   address,
                UploadRate:      0,
                ProfileTypes: []pyroscope.ProfileType{
                        pyroscope.ProfileCPU,
                        pyroscope.ProfileInuseObjects,
                        pyroscope.ProfileAllocObjects,
                        pyroscope.ProfileInuseSpace,
                        pyroscope.ProfileAllocSpace,
                        pyroscope.ProfileGoroutines,
                        pyroscope.ProfileMutexCount,
                        pyroscope.ProfileMutexDuration,
                        pyroscope.ProfileBlockCount,
                        pyroscope.ProfileBlockDuration,
                },
                DisableGCRuns: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                pterm.Error.Printfln("start pyroscope err:%v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">//go:build !release

package pyroscope

func Load(address string) <span class="cov0" title="0">{
        load(address)
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">package randx

// Choose 高性能版本，使用优化的随机数生成器
func Choose[T any](s []T) T <span class="cov10" title="3257">{
        if len(s) == 0 </span><span class="cov1" title="2">{
                return *new(T)
        }</span>

        <span class="cov9" title="3255">if len(s) == 1 </span><span class="cov1" title="2">{
                return s[0]
        }</span>

        <span class="cov9" title="3253">return s[FastIntn(len(s))]</span>
}

// FastChoose 使用全局生成器的超快版本
func FastChoose[T any](s []T) T <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return *new(T)
        }</span>

        <span class="cov0" title="0">if len(s) == 1 </span><span class="cov0" title="0">{
                return s[0]
        }</span>

        <span class="cov0" title="0">globalMu.Lock()
        idx := globalRand.Intn(len(s))
        globalMu.Unlock()
        
        return s[idx]</span>
}

// ChooseN 从切片中选择N个不重复的元素（高性能版本）
func ChooseN[T any](s []T, n int) []T <span class="cov0" title="0">{
        if len(s) == 0 || n &lt;= 0 </span><span class="cov0" title="0">{
                return []T{}
        }</span>
        
        <span class="cov0" title="0">if n &gt;= len(s) </span><span class="cov0" title="0">{
                // 返回所有元素的副本
                result := make([]T, len(s))
                copy(result, s)
                return result
        }</span>
        
        // 使用Fisher-Yates洗牌算法选择前N个
        <span class="cov0" title="0">sCopy := make([]T, len(s))
        copy(sCopy, s)
        
        r := getFastRand()
        
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                j := i + r.Intn(len(sCopy)-i)
                sCopy[i], sCopy[j] = sCopy[j], sCopy[i]
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        
        return sCopy[:n]</span>
}

// Shuffle 随机打乱切片（高性能版本）
func Shuffle[T any](s []T) <span class="cov0" title="0">{
        if len(s) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">r := getFastRand()
        
        // Fisher-Yates 洗牌算法
        for i := len(s) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                j := r.Intn(i + 1)
                s[i], s[j] = s[j], s[i]
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)</span>
}

// FastShuffle 使用全局生成器的超快版本
func FastShuffle[T any](s []T) <span class="cov0" title="0">{
        if len(s) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">globalMu.Lock()
        defer globalMu.Unlock()
        
        for i := len(s) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                j := globalRand.Intn(i + 1)
                s[i], s[j] = s[j], s[i]
        }</span>
}

// WeightedChoose 加权选择（权重数组对应元素选择概率）
func WeightedChoose[T any](items []T, weights []float64) T <span class="cov0" title="0">{
        if len(items) == 0 || len(items) != len(weights) </span><span class="cov0" title="0">{
                return *new(T)
        }</span>
        
        <span class="cov0" title="0">if len(items) == 1 </span><span class="cov0" title="0">{
                return items[0]
        }</span>
        
        // 计算权重总和
        <span class="cov0" title="0">totalWeight := 0.0
        for _, w := range weights </span><span class="cov0" title="0">{
                totalWeight += w
        }</span>
        
        <span class="cov0" title="0">if totalWeight &lt;= 0 </span><span class="cov0" title="0">{
                return items[FastIntn(len(items))]
        }</span>
        
        // 生成随机数
        <span class="cov0" title="0">r := FastFloat64() * totalWeight
        
        // 找到对应的元素
        accumWeight := 0.0
        for i, weight := range weights </span><span class="cov0" title="0">{
                accumWeight += weight
                if r &lt;= accumWeight </span><span class="cov0" title="0">{
                        return items[i]
                }</span>
        }
        
        // 理论上不应该到达这里，但为安全起见
        <span class="cov0" title="0">return items[len(items)-1]</span>
}

// BatchChoose 批量从切片中选择元素
func BatchChoose[T any](s []T, count int) []T <span class="cov0" title="0">{
        if len(s) == 0 || count &lt;= 0 </span><span class="cov0" title="0">{
                return []T{}
        }</span>
        
        <span class="cov0" title="0">results := make([]T, count)
        
        if len(s) == 1 </span><span class="cov0" title="0">{
                for i := range results </span><span class="cov0" title="0">{
                        results[i] = s[0]
                }</span>
                <span class="cov0" title="0">return results</span>
        }
        
        <span class="cov0" title="0">r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = s[r.Intn(len(s))]
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}</pre>
		
		<pre class="file" id="file121" style="display: none">package randx

// Bool 高性能版本，使用优化的随机数生成器
func Bool() bool <span class="cov8" title="10100">{
        return FastIntn(2) == 0
}</span>

// Booln 高性能概率布尔值生成器
func Booln(n float64) bool <span class="cov10" title="32490">{
        if n &gt;= 100 </span><span class="cov5" title="250">{
                return true
        }</span> else<span class="cov9" title="32240"> if n &lt;= 0 </span><span class="cov5" title="200">{
                return false
        }</span>

        <span class="cov9" title="32040">return FastFloat64()*100 &lt; n</span>
}

// FastBool 使用全局生成器的超快版本
func FastBool() bool <span class="cov0" title="0">{
        globalMu.Lock()
        result := globalRand.Intn(2) == 0
        globalMu.Unlock()
        return result
}</span>

// WeightedBool 加权布尔值，weight为true的权重(0.0-1.0)
func WeightedBool(weight float64) bool <span class="cov0" title="0">{
        if weight &gt;= 1.0 </span><span class="cov0" title="0">{
                return true
        }</span> else<span class="cov0" title="0"> if weight &lt;= 0.0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return Float64() &lt; weight</span>
}

// BatchBool 批量生成布尔值
func BatchBool(count int) []bool <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">results := make([]bool, count)
        r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = r.Intn(2) == 0
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}

// BatchBooln 批量生成概率布尔值
func BatchBooln(n float64, count int) []bool <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">if n &gt;= 100 </span><span class="cov0" title="0">{
                results := make([]bool, count)
                for i := range results </span><span class="cov0" title="0">{
                        results[i] = true
                }</span>
                <span class="cov0" title="0">return results</span>
        } else<span class="cov0" title="0"> if n &lt;= 0 </span><span class="cov0" title="0">{
                return make([]bool, count) // 默认为false
        }</span>
        
        <span class="cov0" title="0">results := make([]bool, count)
        r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = r.Float64()*100 &lt; n
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}</pre>
		
		<pre class="file" id="file122" style="display: none">package randx

import (
        "math/rand"
        "sync"
        "time"
        "unsafe"
)

// 高性能随机数生成器池
var (
        // 全局随机数生成器，用于最高性能场景
        globalRand = rand.New(rand.NewSource(time.Now().UnixNano()))
        globalMu   sync.Mutex

        // 线程本地存储池，避免锁竞争
        randPool = sync.Pool{
                New: func() interface{} <span class="cov2" title="5">{
                        return rand.New(rand.NewSource(time.Now().UnixNano()))
                }</span>,
        }

        // 快速种子生成器，避免频繁调用time.Now()
        fastSeedCounter uint64 = uint64(time.Now().UnixNano())
)

// getFastRand 获取高性能随机数生成器
func getFastRand() *rand.Rand <span class="cov9" title="21394">{
        return randPool.Get().(*rand.Rand)
}</span>

// putFastRand 归还随机数生成器到池中
func putFastRand(r *rand.Rand) <span class="cov9" title="21390">{
        randPool.Put(r)
}</span>

// fastSeed 生成快速种子，避免系统调用
func fastSeed() int64 <span class="cov0" title="0">{
        // 使用原子操作递增计数器，混合当前纳秒时间
        counter := (*uint64)(unsafe.Pointer(&amp;fastSeedCounter))
        return int64(*counter&lt;&lt;8 | uint64(time.Now().UnixNano()&amp;0xFF))
}</span>

// globalRandIntn 使用全局锁定的随机数生成器
func globalRandIntn(n int) int <span class="cov9" title="13353">{
        globalMu.Lock()
        result := globalRand.Intn(n)
        globalMu.Unlock()
        return result
}</span>

// Intn 高性能版本
func Intn(n int) int <span class="cov9" title="10500">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov9" title="10500">if n == 1 </span><span class="cov4" title="100">{
                return 0
        }</span>
        
        <span class="cov9" title="10400">r := getFastRand()
        result := r.Intn(n)
        putFastRand(r)
        return result</span>
}

// Int 高性能版本
func Int() int <span class="cov7" title="1100">{
        r := getFastRand()
        result := r.Int()
        putFastRand(r)
        return result
}</span>

// IntnRange 高性能范围随机数 [min, max]
func IntnRange(min, max int) int <span class="cov8" title="5505">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov8" title="5504"> if min == max </span><span class="cov2" title="4">{
                return min
        }</span>

        <span class="cov8" title="5500">r := getFastRand()
        result := min + r.Intn(max-min+1)
        putFastRand(r)
        return result</span>
}

// Int64n 高性能版本
func Int64n(n int64) int64 <span class="cov5" title="250">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov5" title="250">if n == 1 </span><span class="cov4" title="50">{
                return 0
        }</span>
        
        <span class="cov5" title="200">r := getFastRand()
        result := r.Int63n(n)
        putFastRand(r)
        return result</span>
}

// Int64 高性能版本
func Int64() int64 <span class="cov4" title="100">{
        r := getFastRand()
        result := r.Int63()
        putFastRand(r)
        return result
}</span>

// Int64nRange 高性能范围随机数 [min, max]
func Int64nRange(min, max int64) int64 <span class="cov5" title="252">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov5" title="251"> if min == max </span><span class="cov1" title="1">{
                return min
        }</span>

        <span class="cov5" title="250">r := getFastRand()
        result := min + r.Int63n(max-min+1)
        putFastRand(r)
        return result</span>
}

// Float64 高性能版本
func Float64() float64 <span class="cov7" title="1100">{
        r := getFastRand()
        result := r.Float64()
        putFastRand(r)
        return result
}</span>

// Float64Range 高性能范围随机数 [min, max]
func Float64Range(min, max float64) float64 <span class="cov5" title="202">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov5" title="201"> if min == max </span><span class="cov1" title="1">{
                return min
        }</span>

        <span class="cov5" title="200">r := getFastRand()
        result := min + r.Float64()*(max-min)
        putFastRand(r)
        return result</span>
}

// Float32 高性能版本
func Float32() float32 <span class="cov4" title="100">{
        r := getFastRand()
        result := r.Float32()
        putFastRand(r)
        return result
}</span>

// Float32Range 高性能范围随机数 [min, max]
func Float32Range(min, max float32) float32 <span class="cov5" title="152">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov5" title="151"> if min == max </span><span class="cov1" title="1">{
                return min
        }</span>

        <span class="cov5" title="150">r := getFastRand()
        result := min + r.Float32()*(max-min)
        putFastRand(r)
        return result</span>
}

// Uint32 高性能版本
func Uint32() uint32 <span class="cov4" title="100">{
        r := getFastRand()
        result := r.Uint32()
        putFastRand(r)
        return result
}</span>

// Uint32Range 高性能范围随机数 [min, max]
func Uint32Range(min, max uint32) uint32 <span class="cov5" title="202">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov5" title="201"> if min == max </span><span class="cov1" title="1">{
                return min
        }</span>

        <span class="cov5" title="200">r := getFastRand()
        result := min + r.Uint32()%(max-min+1)
        putFastRand(r)
        return result</span>
}

// Uint64 高性能版本
func Uint64() uint64 <span class="cov4" title="100">{
        r := getFastRand()
        result := r.Uint64()
        putFastRand(r)
        return result
}</span>

// Uint64Range 高性能范围随机数 [min, max]
func Uint64Range(min, max uint64) uint64 <span class="cov5" title="202">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov5" title="201"> if min == max </span><span class="cov1" title="1">{
                return min
        }</span>

        <span class="cov5" title="200">r := getFastRand()
        result := min + r.Uint64()%(max-min+1)
        putFastRand(r)
        return result</span>
}

// FastIntn 超快版本，使用全局锁定生成器（适合单线程或低并发）
func FastIntn(n int) int <span class="cov9" title="13353">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov9" title="13353">if n == 1 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov9" title="13353">return globalRandIntn(n)</span>
}

// FastInt 超快版本
func FastInt() int <span class="cov0" title="0">{
        globalMu.Lock()
        result := globalRand.Int()
        globalMu.Unlock()
        return result
}</span>

// FastFloat64 超快版本
func FastFloat64() float64 <span class="cov10" title="32040">{
        globalMu.Lock()
        result := globalRand.Float64()
        globalMu.Unlock()
        return result
}</span>

// BatchIntn 批量生成随机数，减少池获取开销
func BatchIntn(n int, count int) []int <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">results := make([]int, count)
        r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = r.Intn(n)
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}

// BatchInt64n 批量生成int64随机数
func BatchInt64n(n int64, count int) []int64 <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">results := make([]int64, count)
        r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = r.Int63n(n)
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}

// BatchFloat64 批量生成float64随机数
func BatchFloat64(count int) []float64 <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">results := make([]float64, count)
        r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = r.Float64()
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}</pre>
		
		<pre class="file" id="file123" style="display: none">package randx

import (
        "time"
)

// TimeDuration4Sleep 高性能版本，使用优化的随机数生成器
func TimeDuration4Sleep(s ...time.Duration) time.Duration <span class="cov10" title="1694">{
        start, end := time.Second, time.Second*3
        if len(s) &gt; 1 </span><span class="cov9" title="1402">{
                start = s[0]
                end = s[1]
        }</span> else<span class="cov7" title="292"> if len(s) &gt; 0 </span><span class="cov7" title="192">{
                start = 0
                end = s[0]
        }</span>

        // 保持原始行为兼容性
        <span class="cov10" title="1694">r := getFastRand()
        result := time.Duration(r.Int63n(int64(end-start))) + start
        putFastRand(r)
        
        return result</span>
}

// FastTimeDuration4Sleep 使用全局生成器的超快版本
func FastTimeDuration4Sleep(s ...time.Duration) time.Duration <span class="cov0" title="0">{
        start, end := time.Second, time.Second*3
        if len(s) &gt; 1 </span><span class="cov0" title="0">{
                start = s[0]
                end = s[1]
        }</span> else<span class="cov0" title="0"> if len(s) &gt; 0 </span><span class="cov0" title="0">{
                start = 0
                end = s[0]
        }</span>

        <span class="cov0" title="0">if start &gt;= end </span><span class="cov0" title="0">{
                return start
        }</span>

        <span class="cov0" title="0">globalMu.Lock()
        result := time.Duration(globalRand.Int63n(int64(end-start))) + start
        globalMu.Unlock()
        
        return result</span>
}

// RandomDuration 在指定范围内生成随机时间间隔 [min, max]
func RandomDuration(min, max time.Duration) time.Duration <span class="cov0" title="0">{
        if min &gt; max </span><span class="cov0" title="0">{
                return min
        }</span> else<span class="cov0" title="0"> if min == max </span><span class="cov0" title="0">{
                return min
        }</span>

        <span class="cov0" title="0">r := getFastRand()
        result := min + time.Duration(r.Int63n(int64(max-min+1)))
        putFastRand(r)
        
        return result</span>
}

// RandomTime 在指定时间范围内生成随机时间点
func RandomTime(start, end time.Time) time.Time <span class="cov0" title="0">{
        if start.After(end) </span><span class="cov0" title="0">{
                return start
        }</span> else<span class="cov0" title="0"> if start.Equal(end) </span><span class="cov0" title="0">{
                return start
        }</span>

        <span class="cov0" title="0">diff := end.Sub(start)
        r := getFastRand()
        randomDiff := time.Duration(r.Int63n(int64(diff)))
        putFastRand(r)
        
        return start.Add(randomDiff)</span>
}

// RandomTimeInDay 在指定日期的一天内生成随机时间点
func RandomTimeInDay(date time.Time) time.Time <span class="cov0" title="0">{
        // 获取当天的开始时间
        startOfDay := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
        // 当天结束时间（下一天的开始时间）
        endOfDay := startOfDay.Add(24 * time.Hour)
        
        return RandomTime(startOfDay, endOfDay)
}</span>

// RandomTimeInHour 在指定小时内生成随机时间点
func RandomTimeInHour(baseTime time.Time, hour int) time.Time <span class="cov0" title="0">{
        if hour &lt; 0 || hour &gt; 23 </span><span class="cov0" title="0">{
                hour = baseTime.Hour()
        }</span>
        
        <span class="cov0" title="0">startOfHour := time.Date(baseTime.Year(), baseTime.Month(), baseTime.Day(), hour, 0, 0, 0, baseTime.Location())
        endOfHour := startOfHour.Add(time.Hour)
        
        return RandomTime(startOfHour, endOfHour)</span>
}

// BatchRandomDuration 批量生成随机时间间隔
func BatchRandomDuration(min, max time.Duration, count int) []time.Duration <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">if min &gt; max </span><span class="cov0" title="0">{
                min, max = max, min
        }</span> else<span class="cov0" title="0"> if min == max </span><span class="cov0" title="0">{
                results := make([]time.Duration, count)
                for i := range results </span><span class="cov0" title="0">{
                        results[i] = min
                }</span>
                <span class="cov0" title="0">return results</span>
        }
        
        <span class="cov0" title="0">results := make([]time.Duration, count)
        r := getFastRand()
        
        diff := int64(max - min + 1)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = min + time.Duration(r.Int63n(diff))
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}

// SleepRandom 随机睡眠指定范围的时间
func SleepRandom(min, max time.Duration) <span class="cov0" title="0">{
        duration := RandomDuration(min, max)
        time.Sleep(duration)
}</span>

// SleepRandomMilliseconds 随机睡眠指定毫秒数范围
func SleepRandomMilliseconds(minMs, maxMs int) <span class="cov0" title="0">{
        min := time.Duration(minMs) * time.Millisecond
        max := time.Duration(maxMs) * time.Millisecond
        SleepRandom(min, max)
}</span>

// Jitter 为时间间隔添加抖动（±jitterPercent%的随机变化）
func Jitter(duration time.Duration, jitterPercent float64) time.Duration <span class="cov0" title="0">{
        if jitterPercent &lt;= 0 </span><span class="cov0" title="0">{
                return duration
        }</span>
        
        <span class="cov0" title="0">if jitterPercent &gt; 100 </span><span class="cov0" title="0">{
                jitterPercent = 100
        }</span>
        
        // 计算抖动范围
        <span class="cov0" title="0">jitterRange := time.Duration(float64(duration) * jitterPercent / 100)
        
        // 生成 [-jitterRange, +jitterRange] 的随机变化
        randomJitter := RandomDuration(-jitterRange, jitterRange)
        
        result := duration + randomJitter
        if result &lt; 0 </span><span class="cov0" title="0">{
                result = 0
        }</span>
        
        <span class="cov0" title="0">return result</span>
}</pre>
		
		<pre class="file" id="file124" style="display: none">package routine

import (
        "fmt"
        "github.com/lazygophers/log"
        "github.com/petermattis/goid"
        "os"
        "runtime/debug"
        "strings"
)

type BeforeRoutine func(baseGid, currentGid int64)
type AfterRoutine func(currentGid int64)

var (
        beforeRoutines []BeforeRoutine
        afterRoutines  []AfterRoutine
)

func before(baseGid, currentGid int64) <span class="cov0" title="0">{
        for _, f := range beforeRoutines </span><span class="cov0" title="0">{
                f(baseGid, currentGid)
        }</span>
}

func after(currentGid int64) <span class="cov0" title="0">{
        for _, f := range afterRoutines </span><span class="cov0" title="0">{
                f(currentGid)
        }</span>
}

func AddBeforeRoutine(f BeforeRoutine) <span class="cov0" title="0">{
        beforeRoutines = append(beforeRoutines, f)
}</span>

func AddAfterRoutine(f AfterRoutine) <span class="cov0" title="0">{
        afterRoutines = append(afterRoutines, f)
}</span>

func init() <span class="cov0" title="0">{
        AddBeforeRoutine(func(baseGid, currentGid int64) </span><span class="cov0" title="0">{
                log.SetTraceWithGID(currentGid, fmt.Sprintf("%s.%s", log.GetTraceWithGID(baseGid), log.GenTraceId()))
        }</span>)

        <span class="cov0" title="0">AddAfterRoutine(func(currentGid int64) </span><span class="cov0" title="0">{
                log.DelTraceWithGID(currentGid)
        }</span>)
}

func Go(f func() (err error)) <span class="cov0" title="0">{
        baseGid := goid.Get()
        go func() </span><span class="cov0" title="0">{
                currentGid := goid.Get()
                before(baseGid, currentGid)
                defer func() </span><span class="cov0" title="0">{
                        after(currentGid)
                }</span>()

                <span class="cov0" title="0">err := f()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                }</span>
        }()
}

func GoWithRecover(f func() (err error)) <span class="cov0" title="0">{
        baseGid := goid.Get()
        go func() </span><span class="cov0" title="0">{
                currentGid := goid.Get()
                before(baseGid, currentGid)
                defer func() </span><span class="cov0" title="0">{
                        after(currentGid)
                }</span>()

                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("err:%v", err)
                                st := debug.Stack()
                                if len(st) &gt; 0 </span><span class="cov0" title="0">{
                                        log.Errorf("dump stack (%s):", err)
                                        lines := strings.Split(string(st), "\n")
                                        for _, line := range lines </span><span class="cov0" title="0">{
                                                log.Error("  ", line)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        log.Errorf("stack is empty (%s)", err)
                                }</span>
                        }
                }()

                <span class="cov0" title="0">err := f()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                }</span>
        }()
}

func GoWithMustSuccess(f func() (err error)) <span class="cov0" title="0">{
        baseGid := goid.Get()
        go func() </span><span class="cov0" title="0">{
                currentGid := goid.Get()
                before(baseGid, currentGid)
                defer func() </span><span class="cov0" title="0">{
                        after(currentGid)
                }</span>()

                <span class="cov0" title="0">err := f()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                        os.Exit(1)
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package runtime

import (
        "github.com/lazygophers/log"
        "os"
        "os/signal"
)

func GetExitSign() chan os.Signal <span class="cov10" title="8">{
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, exitSignal...)
        return sigCh
}</span>

func WaitExit() <span class="cov1" title="1">{
        sign := GetExitSign()
        &lt;-sign
}</span>

func Exit() <span class="cov0" title="0">{
        process, err := os.FindProcess(os.Getpid())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                os.Exit(0)
        }</span> else<span class="cov0" title="0"> {
                log.Infof("will stop process:%d", process.Pid)
                // 使用SIGTERM信号而不是SIGKILL，因为SIGKILL无法被进程处理
                err = process.Signal(os.Interrupt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                        os.Exit(0)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package runtime

import (
        "github.com/lazygophers/log"
        "github.com/lazygophers/utils/app"
        "os"
        "path/filepath"
        "runtime/debug"
        "strings"
)

func CachePanic() <span class="cov2" title="2">{
        CachePanicWithHandle(nil)
}</span>

func CachePanicWithHandle(handle func(err interface{})) <span class="cov5" title="11">{
        if err := recover(); err != nil </span><span class="cov4" title="5">{
                log.Errorf("PROCESS PANIC: err %s", err)
                st := debug.Stack()
                if len(st) &gt; 0 </span><span class="cov4" title="5">{
                        log.Errorf("dump stack (%s):", err)
                        lines := strings.Split(string(st), "\n")
                        for _, line := range lines </span><span class="cov10" title="80">{
                                log.Error("  ", line)
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Errorf("stack is empty (%s)", err)
                }</span>
                <span class="cov4" title="5">if handle != nil </span><span class="cov3" title="3">{
                        handle(err)
                }</span>
                // 不再重新panic，真正"缓存"（消化）panic
        }
}

func PrintStack() <span class="cov3" title="4">{
        st := debug.Stack()
        if len(st) &gt; 0 </span><span class="cov3" title="4">{
                log.Error("dump stack:")
                log.Error(string(st))
        }</span> else<span class="cov0" title="0"> {
                log.Error("stack is empty")
        }</span>
}

func ExecDir() string <span class="cov4" title="7">{
        execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov4" title="7">return filepath.Dir(execPath)</span>
}

func ExecFile() string <span class="cov4" title="7">{
        execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov4" title="7">return execPath</span>
}

func Pwd() string <span class="cov4" title="6">{
        pwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov4" title="6">return pwd</span>
}

func UserHomeDir() string <span class="cov4" title="5">{
        path, _ := os.UserHomeDir()
        return path
}</span>

func UserConfigDir() string <span class="cov4" title="5">{
        path, _ := os.UserConfigDir()
        return path
}</span>

func UserCacheDir() string <span class="cov4" title="6">{
        path, _ := os.UserCacheDir()
        return path
}</span>

func LazyConfigDir() string <span class="cov4" title="5">{
        path, _ := os.UserConfigDir()
        return filepath.Join(path, app.Organization)
}</span>

func LazyCacheDir() string <span class="cov4" title="5">{
        path, _ := os.UserCacheDir()
        return filepath.Join(path, app.Organization)
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">//go:build darwin

package runtime

func IsWindows() bool <span class="cov10" title="11006">{
        return false
}</span>

func IsDarwin() bool <span class="cov10" title="11006">{
        return true
}</span>

func IsLinux() bool <span class="cov10" title="11006">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">package singledo

import (
        "sync"
        "time"
)

type Group[T any] struct {
        wait time.Duration

        mux       sync.RWMutex
        singleMap map[string]*Single[T]
}

func (p *Group[T]) getOrAddSingle(key string) *Single[T] <span class="cov0" title="0">{
        p.mux.RLock()
        single := p.singleMap[key]
        p.mux.RUnlock()

        if single != nil </span><span class="cov0" title="0">{
                return single
        }</span>

        <span class="cov0" title="0">p.mux.Lock()
        defer p.mux.Unlock()

        single = p.singleMap[key]

        if single != nil </span><span class="cov0" title="0">{
                return single
        }</span>

        <span class="cov0" title="0">single = NewSingle[T](p.wait)
        p.singleMap[key] = single

        return single</span>
}

func (p *Group[T]) Do(key string, fn func() (T, error)) (v T, err error) <span class="cov0" title="0">{
        return p.getOrAddSingle(key).Do(fn)
}</span>

func NewSingleGroup[T any](wait time.Duration) *Group[T] <span class="cov0" title="0">{
        return &amp;Group[T]{
                wait:      wait,
                singleMap: make(map[string]*Single[T]),
        }
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">package singledo

import (
        "sync"
        "time"
)

type call[T any] struct {
        wg  sync.WaitGroup
        val T
        err error
}

type Single[T any] struct {
        mux    sync.Mutex
        last   time.Time
        wait   time.Duration
        call   *call[T]
        result T
}

func (s *Single[T]) Do(fn func() (T, error)) (v T, err error) <span class="cov0" title="0">{
        s.mux.Lock()
        now := time.Now()
        if now.Before(s.last.Add(s.wait)) </span><span class="cov0" title="0">{
                s.mux.Unlock()
                return s.result, nil
        }</span>

        <span class="cov0" title="0">if callM := s.call; callM != nil </span><span class="cov0" title="0">{
                s.mux.Unlock()
                callM.wg.Wait()
                return callM.val, callM.err
        }</span>

        <span class="cov0" title="0">callM := &amp;call[T]{}
        callM.wg.Add(1)
        s.call = callM
        s.mux.Unlock()

        callM.val, callM.err = fn()
        callM.wg.Done()

        s.mux.Lock()
        if callM.err == nil </span><span class="cov0" title="0">{
                s.last = now
                s.result = callM.val
                s.call = nil
        }</span>
        <span class="cov0" title="0">s.mux.Unlock()

        return callM.val, callM.err</span>
}

func (s *Single[T]) Reset() <span class="cov0" title="0">{
        s.last = time.Time{}
}</span>

func NewSingle[T any](wait time.Duration) *Single[T] <span class="cov0" title="0">{
        return &amp;Single[T]{wait: wait}
}</span>
</pre>
		
		<pre class="file" id="file130" style="display: none">package stringx

import "math/rand"

func RandLetters(n int) string <span class="cov4" title="103">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov4" title="101">return RandStringWithSeed(n, []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))</span>
}

func RandLowerLetters(n int) string <span class="cov1" title="3">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return RandStringWithSeed(n, []rune("abcdefghijklmnopqrstuvwxyz"))</span>
}

func RandUpperLetters(n int) string <span class="cov1" title="3">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return RandStringWithSeed(n, []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZ"))</span>
}

func RandNumbers(n int) string <span class="cov1" title="3">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return RandStringWithSeed(n, []rune("0123456789"))</span>
}

func RandLetterNumbers(n int) string <span class="cov2" title="5">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="3">return RandStringWithSeed(n, []rune("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))</span>
}

func RandLowerLetterNumbers(n int) string <span class="cov1" title="3">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return RandStringWithSeed(n, []rune("0123456789abcdefghijklmnopqrstuvwxyz"))</span>
}

func RandUpperLetterNumbers(n int) string <span class="cov1" title="3">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return RandStringWithSeed(n, []rune("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"))</span>
}

func RandStringWithSeed(n int, seed []rune) string <span class="cov4" title="119">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov4" title="117">if len(seed) == 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov4" title="115">b := make([]rune, n)
        for i := range b </span><span class="cov10" title="1012011">{
                b[i] = seed[rand.Intn(len(seed))]
        }</span>
        <span class="cov4" title="115">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package stringx

import (
        "bytes"
        "strconv"
        "strings"
        "unicode"
        "unsafe"
)

func ToString(b []byte) string <span class="cov2" title="5">{
        if b == nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov2" title="4">if len(b) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov2" title="3">return *(*string)(unsafe.Pointer(&amp;b))</span>
}

func ToBytes(s string) []byte <span class="cov2" title="4">{
        if s == "" </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov2" title="3">return *(*[]byte)(unsafe.Pointer(&amp;s))</span>
}

// Camel2Snake 驼峰转蛇形 - 内存优化版本
func Camel2Snake(s string) string <span class="cov3" title="11">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        // 只处理ASCII字符以获得最大性能
        <span class="cov3" title="10">if isASCII(s) </span><span class="cov3" title="10">{
                return optimizedASCIICamel2Snake(s)
        }</span>
        
        // Unicode版本保持原有逻辑但优化内存分配
        <span class="cov0" title="0">capacity := len(s) + len(s)/3
        result := make([]byte, 0, capacity)
        
        for i, r := range s </span><span class="cov0" title="0">{
                if unicode.IsUpper(r) </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                result = append(result, '_')
                        }</span>
                        <span class="cov0" title="0">result = append(result, byte(unicode.ToLower(r)))</span>
                } else<span class="cov0" title="0"> {
                        if r &lt; 128 </span><span class="cov0" title="0">{
                                result = append(result, byte(r))
                        }</span> else<span class="cov0" title="0"> {
                                // 非ASCII字符
                                charBytes := []byte(string(r))
                                result = append(result, charBytes...)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return *(*string)(unsafe.Pointer(&amp;result))</span>
}

// Snake2Camel 蛇形转驼峰
func Snake2Camel(s string) string <span class="cov3" title="10">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov3" title="9">var b bytes.Buffer
        upper := true
        for _, v := range s </span><span class="cov5" title="120">{
                if v == '_' </span><span class="cov3" title="12">{
                        upper = true
                }</span> else<span class="cov5" title="108"> {
                        if upper </span><span class="cov3" title="17">{
                                b.WriteRune(unicode.ToUpper(v))
                                upper = false
                        }</span> else<span class="cov5" title="91"> {
                                b.WriteRune(v)
                        }</span>
                }
        }
        <span class="cov3" title="9">return b.String()</span>
}

// Snake2SmallCamel 蛇形转小驼峰
func Snake2SmallCamel(s string) string <span class="cov3" title="11">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov3" title="10">var b bytes.Buffer
        upper := false
        isFirst := true
        for _, v := range s </span><span class="cov5" title="130">{
                if v == '_' </span><span class="cov3" title="13">{
                        upper = true
                }</span> else<span class="cov5" title="117"> {
                        if isFirst </span><span class="cov3" title="10">{
                                isFirst = false
                                b.WriteRune(unicode.ToLower(v))
                                upper = false // Reset upper flag after first character
                        }</span> else<span class="cov5" title="107"> if upper </span><span class="cov3" title="9">{
                                b.WriteRune(unicode.ToUpper(v))
                                upper = false
                        }</span> else<span class="cov5" title="98"> {
                                // Convert to lowercase for consistency in camelCase
                                b.WriteRune(unicode.ToLower(v))
                        }</span>
                }
        }
        <span class="cov3" title="10">return b.String()</span>
}

// ToSnake 蛇形 - 零分配优化版本
func ToSnake(s string) string <span class="cov4" title="25">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        // 预估需要的容量，避免多次扩容
        <span class="cov4" title="24">capacity := len(s) + len(s)/4  // 估算增加25%的容量用于下划线
        if capacity &gt; 256 </span><span class="cov0" title="0">{
                capacity = 256 // 限制最大预分配容量
        }</span>
        
        // 使用单次分配的 []byte 替代 bytes.Buffer
        <span class="cov4" title="24">result := make([]byte, 0, capacity)
        runes := []rune(s)
        
        for i, r := range runes </span><span class="cov6" title="253">{
                if unicode.IsLetter(r) || unicode.IsNumber(r) </span><span class="cov6" title="230">{
                        // 检查是否需要下划线
                        if i &gt; 0 </span><span class="cov6" title="208">{
                                prev := runes[i-1]
                                if (unicode.IsUpper(r) &amp;&amp; unicode.IsLetter(prev)) ||
                                        (unicode.IsNumber(r) &amp;&amp; unicode.IsLetter(prev)) ||
                                        (unicode.IsLetter(r) &amp;&amp; unicode.IsNumber(prev)) </span><span class="cov4" title="38">{
                                        result = append(result, '_')
                                }</span>
                        }
                        
                        // 转换为小写并添加
                        <span class="cov6" title="230">if unicode.IsUpper(r) </span><span class="cov4" title="49">{
                                result = append(result, byte(unicode.ToLower(r)))
                        }</span> else<span class="cov6" title="181"> {
                                // 对于ASCII字符直接转换，避免Unicode处理开销
                                if r &lt; 128 </span><span class="cov5" title="164">{
                                        result = append(result, byte(r))
                                }</span> else<span class="cov3" title="17"> {
                                        // 非ASCII字符使用Unicode处理
                                        lowerStr := string(unicode.ToLower(r))
                                        result = append(result, lowerStr...)
                                }</span>
                        }
                } else<span class="cov4" title="23"> {
                        // 避免连续的下划线
                        if len(result) &gt; 0 &amp;&amp; result[len(result)-1] != '_' </span><span class="cov3" title="11">{
                                result = append(result, '_')
                        }</span>
                }
        }
        
        // 零拷贝转换为字符串
        <span class="cov4" title="24">return *(*string)(unsafe.Pointer(&amp;result))</span>
}

// ToKebab - 基于优化ToSnake的变体
func ToKebab(s string) string <span class="cov3" title="10">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        // 重用 ToSnake 的逻辑，然后替换下划线
        <span class="cov3" title="9">snakeResult := ToSnake(s)
        
        // 如果没有下划线，直接返回
        if !strings.Contains(snakeResult, "_") </span><span class="cov1" title="1">{
                return snakeResult
        }</span>
        
        // 零拷贝替换下划线为连字符
        <span class="cov3" title="8">resultBytes := []byte(snakeResult)
        for i, b := range resultBytes </span><span class="cov5" title="121">{
                if b == '_' </span><span class="cov4" title="22">{
                        resultBytes[i] = '-'
                }</span>
        }
        
        <span class="cov3" title="8">return *(*string)(unsafe.Pointer(&amp;resultBytes))</span>
}

// ToCamel 转驼峰
func ToCamel(s string) string <span class="cov3" title="16">{
        var b bytes.Buffer
        upper := true
        prevWasNumber := false
        for _, v := range s </span><span class="cov5" title="149">{
                if unicode.IsLetter(v) || unicode.IsNumber(v) </span><span class="cov5" title="124">{
                        if upper || (prevWasNumber &amp;&amp; unicode.IsLetter(v)) </span><span class="cov4" title="27">{
                                if unicode.IsLetter(v) </span><span class="cov4" title="26">{
                                        b.WriteRune(unicode.ToUpper(v))
                                }</span> else<span class="cov1" title="1"> {
                                        b.WriteRune(v)
                                }</span>
                                <span class="cov4" title="27">upper = false</span>
                        } else<span class="cov5" title="97"> {
                                if unicode.IsLetter(v) </span><span class="cov5" title="95">{
                                        b.WriteRune(unicode.ToLower(v))
                                }</span> else<span class="cov1" title="2"> {
                                        b.WriteRune(v)
                                }</span>
                        }
                        <span class="cov5" title="124">prevWasNumber = unicode.IsNumber(v)</span>
                } else<span class="cov4" title="25"> {
                        upper = true
                        prevWasNumber = false
                }</span>
        }
        <span class="cov3" title="16">return b.String()</span>
}

func ToSlash(s string) string <span class="cov3" title="8">{
        var b bytes.Buffer
        runes := []rune(s)
        for i, v := range runes </span><span class="cov5" title="88">{
                if unicode.IsLetter(v) || unicode.IsNumber(v) </span><span class="cov5" title="83">{
                        needsSlash := false
                        
                        // Check if we need a slash before this character
                        if i &gt; 0 </span><span class="cov5" title="76">{
                                prev := runes[i-1]
                                // Add slash for uppercase letters (camelCase -&gt; camel/case)
                                if unicode.IsUpper(v) &amp;&amp; unicode.IsLetter(prev) </span><span class="cov3" title="11">{
                                        needsSlash = true
                                }</span>
                                // Add slash when transitioning from letter to number
                                <span class="cov5" title="76">if unicode.IsNumber(v) &amp;&amp; unicode.IsLetter(prev) </span><span class="cov1" title="1">{
                                        needsSlash = true
                                }</span>
                                // Add slash when transitioning from number to letter  
                                <span class="cov5" title="76">if unicode.IsLetter(v) &amp;&amp; unicode.IsNumber(prev) </span><span class="cov1" title="1">{
                                        needsSlash = true
                                }</span>
                        }
                        
                        <span class="cov5" title="83">if needsSlash </span><span class="cov3" title="13">{
                                b.WriteRune('/')
                        }</span>
                        
                        <span class="cov5" title="83">if unicode.IsUpper(v) </span><span class="cov3" title="20">{
                                b.WriteRune(unicode.ToLower(v))
                        }</span> else<span class="cov5" title="63"> {
                                b.WriteRune(v)
                        }</span>
                } else<span class="cov2" title="5"> {
                        // Only add slash if the last character wasn't a slash
                        if b.Len() &gt; 0 </span><span class="cov2" title="5">{
                                lastRune := []rune(b.String())
                                if len(lastRune) == 0 || lastRune[len(lastRune)-1] != '/' </span><span class="cov2" title="3">{
                                        b.WriteRune('/')
                                }</span>
                        }
                }
        }
        <span class="cov3" title="8">return b.String()</span>
}

func ToDot(s string) string <span class="cov3" title="8">{
        var b bytes.Buffer
        runes := []rune(s)
        for i, v := range runes </span><span class="cov5" title="88">{
                if unicode.IsLetter(v) || unicode.IsNumber(v) </span><span class="cov5" title="83">{
                        needsDot := false
                        
                        // Check if we need a dot before this character
                        if i &gt; 0 </span><span class="cov5" title="76">{
                                prev := runes[i-1]
                                // Add dot for uppercase letters (camelCase -&gt; camel.case)
                                if unicode.IsUpper(v) &amp;&amp; unicode.IsLetter(prev) </span><span class="cov3" title="11">{
                                        needsDot = true
                                }</span>
                                // Add dot when transitioning from letter to number
                                <span class="cov5" title="76">if unicode.IsNumber(v) &amp;&amp; unicode.IsLetter(prev) </span><span class="cov1" title="1">{
                                        needsDot = true
                                }</span>
                                // Add dot when transitioning from number to letter  
                                <span class="cov5" title="76">if unicode.IsLetter(v) &amp;&amp; unicode.IsNumber(prev) </span><span class="cov1" title="1">{
                                        needsDot = true
                                }</span>
                        }
                        
                        <span class="cov5" title="83">if needsDot </span><span class="cov3" title="13">{
                                b.WriteRune('.')
                        }</span>
                        
                        <span class="cov5" title="83">if unicode.IsUpper(v) </span><span class="cov3" title="20">{
                                b.WriteRune(unicode.ToLower(v))
                        }</span> else<span class="cov5" title="63"> {
                                b.WriteRune(v)
                        }</span>
                } else<span class="cov2" title="5"> {
                        // Only add dot if the last character wasn't a dot
                        if b.Len() &gt; 0 </span><span class="cov2" title="5">{
                                lastRune := []rune(b.String())
                                if len(lastRune) == 0 || lastRune[len(lastRune)-1] != '.' </span><span class="cov2" title="3">{
                                        b.WriteRune('.')
                                }</span>
                        }
                }
        }
        <span class="cov3" title="8">return b.String()</span>
}

// ToSmallCamel 转小驼峰
func ToSmallCamel(s string) string <span class="cov3" title="11">{
        var b bytes.Buffer
        upper := false
        isFirst := true
        prevWasNumber := false
        for _, v := range s </span><span class="cov5" title="126">{
                if unicode.IsLetter(v) || unicode.IsNumber(v) </span><span class="cov5" title="113">{
                        if isFirst </span><span class="cov3" title="10">{
                                isFirst = false
                                if unicode.IsLetter(v) </span><span class="cov3" title="9">{
                                        b.WriteRune(unicode.ToLower(v))
                                }</span> else<span class="cov1" title="1"> {
                                        b.WriteRune(v)
                                }</span>
                                <span class="cov3" title="10">upper = false</span>
                        } else<span class="cov5" title="103"> if upper || (prevWasNumber &amp;&amp; unicode.IsLetter(v)) </span><span class="cov3" title="10">{
                                if unicode.IsLetter(v) </span><span class="cov3" title="10">{
                                        b.WriteRune(unicode.ToUpper(v))
                                }</span> else<span class="cov0" title="0"> {
                                        b.WriteRune(v)
                                }</span>
                                <span class="cov3" title="10">upper = false</span>
                        } else<span class="cov5" title="93"> {
                                if unicode.IsLetter(v) </span><span class="cov5" title="91">{
                                        b.WriteRune(unicode.ToLower(v))
                                }</span> else<span class="cov1" title="2"> {
                                        b.WriteRune(v)
                                }</span>
                        }
                        <span class="cov5" title="113">prevWasNumber = unicode.IsNumber(v)</span>
                } else<span class="cov3" title="13"> if !isFirst </span><span class="cov3" title="11">{
                        upper = true
                        prevWasNumber = false
                }</span>
        }
        <span class="cov3" title="11">return b.String()</span>
}

// SplitLen 按长度分割字符串 - 零拷贝优化版本
func SplitLen(s string, max int) []string <span class="cov2" title="6">{
        if max &lt;= 0 </span><span class="cov1" title="2">{
                return []string{s}
        }</span>
        <span class="cov2" title="4">if s == "" </span><span class="cov1" title="1">{
                return []string{}
        }</span>
        
        <span class="cov2" title="3">runes := []rune(s)
        totalRunes := len(runes)
        if totalRunes &lt;= max </span><span class="cov0" title="0">{
                return []string{s}
        }</span>
        
        // 预计算结果切片容量
        <span class="cov2" title="3">estimatedParts := (totalRunes + max - 1) / max
        result := make([]string, 0, estimatedParts)
        
        for start := 0; start &lt; totalRunes; start += max </span><span class="cov3" title="9">{
                end := start + max
                if end &gt; totalRunes </span><span class="cov1" title="1">{
                        end = totalRunes
                }</span>
                
                // 使用零拷贝字符串转换
                <span class="cov3" title="9">part := string(runes[start:end])
                result = append(result, part)</span>
        }
        
        <span class="cov2" title="3">return result</span>
}

// Shorten 缩短字符串
func Shorten(s string, max int) string <span class="cov2" title="6">{
        if max &lt; 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov2" title="5">if len(s) &lt;= max </span><span class="cov1" title="2">{
                return s
        }</span>
        <span class="cov2" title="3">return s[:max]</span>
}

func ShortenShow(s string, max int) string <span class="cov2" title="6">{
        if max &lt; 0 </span><span class="cov1" title="1">{
                return "..."
        }</span>
        <span class="cov2" title="5">if len(s) &lt;= max </span><span class="cov1" title="2">{
                return s
        }</span>
        <span class="cov2" title="3">if max &lt; 3 </span><span class="cov1" title="1">{
                return "..."
        }</span>
        <span class="cov1" title="2">return s[:max-3] + "..."</span>
}

func IsUpper[M string | []rune](r M) bool <span class="cov3" title="16">{
        return string(r) == strings.ToUpper(string(r))
}</span>

func IsDigit[M string | []rune](r M) bool <span class="cov3" title="15">{
        for _, i := range []rune(r) </span><span class="cov4" title="22">{
                if !unicode.IsDigit(i) </span><span class="cov3" title="9">{
                        return false
                }</span>
        }

        <span class="cov2" title="6">return true</span>
}

func Reverse(s string) string <span class="cov3" title="15">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        // ASCII优化路径
        <span class="cov3" title="14">if isASCII(s) </span><span class="cov2" title="6">{
                return reverseASCII(s)
        }</span>
        
        // Unicode路径 - 使用原地反转避免额外分配
        <span class="cov3" title="8">runes := []rune(s)
        for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov3" title="19">{
                runes[i], runes[j] = runes[j], runes[i]
        }</span>
        <span class="cov3" title="8">return string(runes)</span>
}

func Quote(s string) string <span class="cov3" title="12">{
        return strconv.Quote(s)
}</span>

func QuotePure(s string) string <span class="cov2" title="6">{
        return strings.TrimPrefix(strings.TrimSuffix(Quote(s), `"`), `"`)
}</span>

// 快速ASCII检测辅助函数
func isASCII(s string) bool <span class="cov4" title="24">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov10" title="10108">{
                if s[i] &gt;= 128 </span><span class="cov3" title="8">{
                        return false
                }</span>
        }
        <span class="cov3" title="16">return true</span>
}

// 纯ASCII优化的Camel2Snake版本
func optimizedASCIICamel2Snake(s string) string <span class="cov3" title="10">{
        capacity := len(s) + len(s)/3
        result := make([]byte, 0, capacity)
        
        for i := 0; i &lt; len(s); i++ </span><span class="cov5" title="71">{
                c := s[i]
                if c &gt;= 'A' &amp;&amp; c &lt;= 'Z' </span><span class="cov4" title="23">{
                        if i &gt; 0 </span><span class="cov3" title="17">{
                                result = append(result, '_')
                        }</span>
                        <span class="cov4" title="23">result = append(result, c+32)</span> // 快速转小写
                } else<span class="cov4" title="48"> {
                        result = append(result, c)
                }</span>
        }
        
        <span class="cov3" title="10">return *(*string)(unsafe.Pointer(&amp;result))</span>
}

// 纯ASCII反转，最高性能
func reverseASCII(s string) string <span class="cov2" title="6">{
        if len(s) &lt;= 1 </span><span class="cov1" title="1">{
                return s
        }</span>
        
        <span class="cov2" title="5">bytes := make([]byte, len(s))
        for i := 0; i &lt; len(s); i++ </span><span class="cov9" title="10026">{
                bytes[i] = s[len(s)-1-i]
        }</span>
        
        <span class="cov2" title="5">return *(*string)(unsafe.Pointer(&amp;bytes))</span>
}

</pre>
		
		<pre class="file" id="file132" style="display: none">package stringx

import (
        "strings"
)

// ContainsAny reports whether any of the UTF-8-encoded code points in chars are within s.
func ContainsAny(s, chars string) bool <span class="cov9" title="8">{
        return strings.ContainsAny(s, chars)
}</span>

// ContainsRune reports whether the Unicode code point r is within s.
func ContainsRune(s string, r rune) bool <span class="cov9" title="8">{
        return strings.ContainsRune(s, r)
}</span>

// Count counts the number of non-overlapping instances of substr in s.
func Count(s, substr string) int <span class="cov10" title="9">{
        if substr == "" </span><span class="cov3" title="2">{
                return len([]rune(s)) + 1
        }</span>
        <span class="cov8" title="7">return strings.Count(s, substr)</span>
}

// EqualFold reports whether s and t are equal under Unicode case-folding.
func EqualFold(s, t string) bool <span class="cov9" title="8">{
        return strings.EqualFold(s, t)
}</span>

// Fields splits the string s around each instance of one or more consecutive white space characters.
func Fields(s string) []string <span class="cov8" title="7">{
        return strings.Fields(s)
}</span>

// FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c).
func FieldsFunc(s string, f func(rune) bool) []string <span class="cov6" title="4">{
        if f == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov5" title="3">return strings.FieldsFunc(s, f)</span>
}

// HasPrefix tests whether the string s begins with prefix.
func HasPrefix(s, prefix string) bool <span class="cov8" title="7">{
        return strings.HasPrefix(s, prefix)
}</span>

// HasSuffix tests whether the string s ends with suffix.
func HasSuffix(s, suffix string) bool <span class="cov8" title="7">{
        return strings.HasSuffix(s, suffix)
}</span>

// Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.
func Index(s, substr string) int <span class="cov9" title="8">{
        return strings.Index(s, substr)
}</span>

// IndexAny returns the index of the first instance of any Unicode code point from chars in s,
// or -1 if no Unicode code point from chars is present in s.
func IndexAny(s, chars string) int <span class="cov8" title="7">{
        return strings.IndexAny(s, chars)
}</span>

// LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.
func LastIndex(s, substr string) int <span class="cov9" title="8">{
        return strings.LastIndex(s, substr)
}</span>

// LastIndexAny returns the index of the last instance of any Unicode code point from chars in s,
// or -1 if no Unicode code point from chars is present in s.
func LastIndexAny(s, chars string) int <span class="cov8" title="6">{
        return strings.LastIndexAny(s, chars)
}</span>

// Repeat returns a new string consisting of count copies of the string s.
func Repeat(s string, count int) string <span class="cov8" title="6">{
        if count &lt; 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov7" title="5">return strings.Repeat(s, count)</span>
}

// Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new.
func Replace(s, old, new string, n int) string <span class="cov8" title="7">{
        return strings.Replace(s, old, new, n)
}</span>

// ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new.
func ReplaceAll(s, old, new string) string <span class="cov7" title="5">{
        return strings.ReplaceAll(s, old, new)
}</span>

// Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.
func Split(s, sep string) []string <span class="cov8" title="6">{
        return strings.Split(s, sep)
}</span>

// SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings.
func SplitAfter(s, sep string) []string <span class="cov7" title="5">{
        return strings.SplitAfter(s, sep)
}</span>

// SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators.
func SplitN(s, sep string, n int) []string <span class="cov8" title="6">{
        return strings.SplitN(s, sep, n)
}</span>

// SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings.
func SplitAfterN(s, sep string, n int) []string <span class="cov8" title="6">{
        return strings.SplitAfterN(s, sep, n)
}</span>

// Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.
func Title(s string) string <span class="cov8" title="6">{
        return strings.Title(s)
}</span>

// ToLower returns s with all Unicode letters mapped to their lower case.
func ToLower(s string) string <span class="cov8" title="6">{
        return strings.ToLower(s)
}</span>

// ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.
func ToTitle(s string) string <span class="cov8" title="6">{
        return strings.ToTitle(s)
}</span>

// ToUpper returns s with all Unicode letters mapped to their upper case.
func ToUpper(s string) string <span class="cov8" title="6">{
        return strings.ToUpper(s)
}</span>

// Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.
func Trim(s, cutset string) string <span class="cov8" title="6">{
        return strings.Trim(s, cutset)
}</span>

// TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.
func TrimLeft(s, cutset string) string <span class="cov8" title="6">{
        return strings.TrimLeft(s, cutset)
}</span>

// TrimRight returns a slice of the string s with all trailing Unicode code points contained in cutset removed.
func TrimRight(s, cutset string) string <span class="cov8" title="6">{
        return strings.TrimRight(s, cutset)
}</span>

// TrimSpace returns a slice of the string s, with all leading and trailing white space removed.
func TrimSpace(s string) string <span class="cov8" title="6">{
        return strings.TrimSpace(s)
}</span>

// TrimPrefix returns s without the provided leading prefix string.
func TrimPrefix(s, prefix string) string <span class="cov7" title="5">{
        return strings.TrimPrefix(s, prefix)
}</span>

// TrimSuffix returns s without the provided trailing suffix string.
func TrimSuffix(s, suffix string) string <span class="cov7" title="5">{
        return strings.TrimSuffix(s, suffix)
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">package stringx

import "unicode"

func AllDigit(s string) bool <span class="cov7" title="13">{
        if s == "" </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov6" title="11">for _, c := range s </span><span class="cov8" title="24">{
                if !unicode.IsDigit(c) </span><span class="cov5" title="8">{
                        return false
                }</span>
        }
        <span class="cov3" title="3">return true</span>
}

func HasDigit(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov9" title="38">{
                if unicode.IsDigit(c) </span><span class="cov5" title="6">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func AllLetter(s string) bool <span class="cov7" title="13">{
        for _, c := range s </span><span class="cov9" title="35">{
                if !unicode.IsLetter(c) </span><span class="cov5" title="6">{
                        return false
                }</span>
        }
        <span class="cov5" title="7">return true</span>
}

func HasLetter(s string) bool <span class="cov7" title="13">{
        for _, c := range s </span><span class="cov8" title="24">{
                if unicode.IsLetter(c) </span><span class="cov5" title="8">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func AllSpace(s string) bool <span class="cov6" title="12">{
        for _, c := range s </span><span class="cov7" title="18">{
                if !unicode.IsSpace(c) </span><span class="cov3" title="3">{
                        return false
                }</span>
        }
        <span class="cov6" title="9">return true</span>
}

func HasSpace(s string) bool <span class="cov6" title="12">{
        for _, c := range s </span><span class="cov9" title="31">{
                if unicode.IsSpace(c) </span><span class="cov5" title="8">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllSymbol(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov7" title="17">{
                if !unicode.IsSymbol(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov5" title="7">return true</span>
}

func HasSymbol(s string) bool <span class="cov6" title="9">{
        for _, c := range s </span><span class="cov8" title="27">{
                if unicode.IsSymbol(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllMark(s string) bool <span class="cov5" title="7">{
        for _, c := range s </span><span class="cov5" title="8">{
                if !unicode.IsMark(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov3" title="3">return true</span>
}

func HasMark(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov8" title="30">{
                if unicode.IsMark(c) </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        <span class="cov6" title="9">return false</span>
}

func AllPunct(s string) bool <span class="cov6" title="10">{
        for _, c := range s </span><span class="cov8" title="24">{
                if !unicode.IsPunct(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov5" title="6">return true</span>
}

func HasPunct(s string) bool <span class="cov6" title="9">{
        for _, c := range s </span><span class="cov9" title="37">{
                if unicode.IsPunct(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllGraphic(s string) bool <span class="cov6" title="12">{
        for _, c := range s </span><span class="cov9" title="34">{
                if !unicode.IsGraphic(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov5" title="8">return true</span>
}

func HasGraphic(s string) bool <span class="cov6" title="9">{
        for _, c := range s </span><span class="cov6" title="10">{
                if unicode.IsGraphic(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllPrint(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov9" title="32">{
                if !unicode.IsPrint(c) </span><span class="cov3" title="3">{
                        return false
                }</span>
        }
        <span class="cov5" title="8">return true</span>
}

func HasPrint(s string) bool <span class="cov6" title="9">{
        for _, c := range s </span><span class="cov6" title="11">{
                if unicode.IsPrint(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllControl(s string) bool <span class="cov5" title="8">{
        for _, c := range s </span><span class="cov6" title="10">{
                if !unicode.IsControl(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov4" title="4">return true</span>
}

func HasControl(s string) bool <span class="cov5" title="8">{
        for _, c := range s </span><span class="cov8" title="23">{
                if unicode.IsControl(c) </span><span class="cov4" title="4">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllUpper(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov8" title="27">{
                if !unicode.IsUpper(c) </span><span class="cov5" title="6">{
                        return false
                }</span>
        }
        <span class="cov4" title="5">return true</span>
}

func HasUpper(s string) bool <span class="cov6" title="10">{
        for _, c := range s </span><span class="cov8" title="24">{
                if unicode.IsUpper(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func AllLower(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov8" title="26">{
                if !unicode.IsLower(c) </span><span class="cov5" title="6">{
                        return false
                }</span>
        }
        <span class="cov4" title="5">return true</span>
}

func HasLower(s string) bool <span class="cov6" title="10">{
        for _, c := range s </span><span class="cov8" title="26">{
                if unicode.IsLower(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func AllTitle(s string) bool <span class="cov5" title="7">{
        for _, c := range s </span><span class="cov5" title="7">{
                if !unicode.IsTitle(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov3" title="3">return true</span>
}

func HasTitle(s string) bool <span class="cov5" title="7">{
        for _, c := range s </span><span class="cov7" title="16">{
                if unicode.IsTitle(c) </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func AllLetterOrDigit(s string) bool <span class="cov6" title="11">{
        if s == "" </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov6" title="9">for _, c := range s </span><span class="cov10" title="46">{
                if !unicode.IsLetter(c) &amp;&amp; !unicode.IsDigit(c) </span><span class="cov3" title="3">{
                        return false
                }</span>
        }
        <span class="cov5" title="6">return true</span>
}

func HasLetterOrDigit(s string) bool <span class="cov6" title="10">{
        for _, c := range s </span><span class="cov7" title="19">{
                if unicode.IsLetter(c) || unicode.IsDigit(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package stringx

import "unicode/utf16"

func Utf16Len[M string | []rune | []byte](str M) int <span class="cov10" title="4135">{
        s := string(str)
        if s == "" </span><span class="cov3" title="9">{
                return 0
        }</span>
        <span class="cov9" title="4126">return len(utf16.Encode([]rune(s)))</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package unit

import (
        "fmt"
)

const (
        Byte = 1
        KB   = 1024 * Byte
        MB   = 1024 * KB
        GB   = 1024 * MB
        TB   = 1024 * GB
        PB   = 1024 * TB
        EB   = 1024 * PB
)

const (
        Bit = 8 * Byte
        Kb  = 1024 * Bit
        Mb  = 1024 * Kb
        Gb  = 1024 * Mb
        Tb  = 1024 * Gb
        Pb  = 1024 * Tb
        Eb  = 1024 * Pb
)

func FormatSpeed(speed float64) string <span class="cov0" title="0">{
        return Format2bps(speed)
}</span>

func Format2bps(speed float64) string <span class="cov0" title="0">{
        if speed &lt;= 0 </span><span class="cov0" title="0">{
                return "——"
        }</span> else<span class="cov0" title="0"> if speed &lt; Kb/8 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f bps", speed*8)
        }</span> else<span class="cov0" title="0"> if speed &lt; Mb/8 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f Kbps", speed*8/Kb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Gb/8 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f Mbps", speed*8/Mb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Tb/8 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f Gbps", speed*8/Gb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Pb/8 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f Tbps", speed*8/Tb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Eb/8 </span><span class="cov0" title="0">{ // 确保在 Eb 范围内正确处理
                return fmt.Sprintf("%.2f Pbps", speed*8/Pb)
        }</span> else<span class="cov0" title="0"> { // 超过 Eb 的值直接返回最大单位
                return fmt.Sprintf("%.2f Ebps", speed*8/Eb)
        }</span>
}

func Format2Bs(speed float64) string <span class="cov0" title="0">{
        if speed &lt;= 0 </span><span class="cov0" title="0">{
                return "——"
        }</span> else<span class="cov0" title="0"> if speed &lt; Kb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f B/s", speed)
        }</span> else<span class="cov0" title="0"> if speed &lt; Mb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f KB/s", speed/Kb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Gb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f MB/s", speed/Mb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Tb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f GB/s", speed/Gb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Pb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f TB/s", speed/Tb)
        }</span> else<span class="cov0" title="0"> { // if speed &lt; EB
                return fmt.Sprintf("%.2f PB/s", speed/Pb)
        }</span>
}

func FormatSize(fileSize int64) string <span class="cov0" title="0">{
        return Format2B(fileSize)
}</span>

func Format2b(fileSize int64) string <span class="cov0" title="0">{
        if fileSize &lt; 0 </span><span class="cov0" title="0">{
                return "——"
        }</span> else<span class="cov0" title="0"> if fileSize &lt; Kb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fb", float64(fileSize))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; Mb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fKb", float64(fileSize)/float64(Kb))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; Gb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fMb", float64(fileSize)/float64(Mb))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; Tb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fGb", float64(fileSize)/float64(Gb))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; Pb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fTb", float64(fileSize)/float64(Tb))
        }</span> else<span class="cov0" title="0"> { // if fileSize &lt; Eb
                return fmt.Sprintf("%.2fPb", float64(fileSize)/float64(Pb))
        }</span>
}

func Format2B(fileSize int64) string <span class="cov0" title="0">{
        if fileSize &lt; 0 </span><span class="cov0" title="0">{
                return "——"
        }</span> else<span class="cov0" title="0"> if fileSize &lt; KB </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f KB", float64(fileSize)) // 修改: 将 "%.2fB" 改为 "%.2f KB"
        }</span> else<span class="cov0" title="0"> if fileSize &lt; MB </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f KB", float64(fileSize)/float64(KB))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; GB </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f MB", float64(fileSize)/float64(MB))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; TB </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f GB", float64(fileSize)/float64(GB))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; PB </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f TB", float64(fileSize)/float64(TB))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; EB </span><span class="cov0" title="0">{ // 添加对 EB 单位的判断
                return fmt.Sprintf("%.2f PB", float64(fileSize)/float64(PB))
        }</span> else<span class="cov0" title="0"> { // 确保在 EB 范围内正确处理
                return fmt.Sprintf("%.2f EB", float64(fileSize)/float64(EB))
        }</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package unit

import (
        "bytes"
        "github.com/lazygophers/utils/xtime"
        "strconv"
        "time"
)

func DurationYearMonthDay(t time.Duration) string <span class="cov0" title="0">{
        years := int(t.Hours() / 24 / 365)
        t = t - time.Duration(years)*xtime.Year

        mouths := int(t.Hours() / 24 / 30)
        t = t - time.Duration(mouths)*xtime.Month

        days := int(t.Hours() / 24)
        t = t - time.Duration(days)*xtime.Day

        var b bytes.Buffer
        if years &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(years))
                b.WriteString("年")
        }</span>

        <span class="cov0" title="0">if mouths &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(mouths))
                b.WriteString("月")
        }</span>

        <span class="cov0" title="0">if days &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(days))
                b.WriteString("天")
        }</span>

        // 如果都为0
        <span class="cov0" title="0">if b.Len() == 0 </span><span class="cov0" title="0">{
                b.WriteString("0天")
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func DurationMonthDayHour(t time.Duration) string <span class="cov0" title="0">{
        mouths := int(t.Hours() / 24 / 30)
        t = t - time.Duration(mouths)*xtime.Month

        days := int(t.Hours() / 24)
        t = t - time.Duration(days)*xtime.Day

        hours := int(t.Hours())
        t = t - time.Duration(hours)*xtime.Hour

        var b bytes.Buffer
        if mouths &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(mouths))
                b.WriteString("月")
        }</span>

        <span class="cov0" title="0">if days &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(days))
                b.WriteString("天")
        }</span>

        <span class="cov0" title="0">if hours &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(hours))
                b.WriteString("小时")
        }</span>

        // 如果都为0
        <span class="cov0" title="0">if b.Len() == 0 </span><span class="cov0" title="0">{
                b.WriteString("0小时")
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func DurationMinuteSecond(t time.Duration) string <span class="cov0" title="0">{
        minutes := int(t.Minutes())
        t = t - time.Duration(minutes)*xtime.Minute

        seconds := t.Seconds()

        var b bytes.Buffer
        if minutes &gt; 1 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(minutes))
                b.WriteString("分")
        }</span>

        <span class="cov0" title="0">if seconds &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(int(seconds)))
                b.WriteString("秒")
        }</span>

        // 如果都为0
        <span class="cov0" title="0">if b.Len() == 0 </span><span class="cov0" title="0">{
                b.WriteString("0秒")
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func DurationYearMonthDayHourMinuteSecond(t time.Duration) string <span class="cov0" title="0">{
        years := int(t.Hours() / 24 / 365)
        t = t - time.Duration(years)*xtime.Year

        mouths := int(t.Hours() / 24 / 30)
        t = t - time.Duration(mouths)*xtime.Month

        days := int(t.Hours() / 24)
        t = t - time.Duration(days)*xtime.Day

        hours := int(t.Hours())
        t = t - time.Duration(hours)*xtime.Hour

        minutes := int(t.Minutes())
        t = t - time.Duration(minutes)*xtime.Minute

        seconds := t.Seconds()

        var b bytes.Buffer
        if years &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(years))
                b.WriteString("年")
        }</span>

        <span class="cov0" title="0">if mouths &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(mouths))
                b.WriteString("月")
        }</span>

        <span class="cov0" title="0">if days &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(days))
                b.WriteString("天")
        }</span>

        <span class="cov0" title="0">if hours &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(hours))
                b.WriteString("小时")
        }</span>

        <span class="cov0" title="0">if minutes &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(minutes))
                b.WriteString("分")
        }</span>

        <span class="cov0" title="0">if seconds &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(int(seconds)))
                b.WriteString("秒")
        }</span>

        // 如果都为0
        <span class="cov0" title="0">if b.Len() == 0 </span><span class="cov0" title="0">{
                b.WriteString("0秒")
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func TimeYearMonthDayHourMinute(t time.Time) string <span class="cov0" title="0">{
        return t.Format("2006年01月02日15点04")
}</span>

func TimeYearMonthDayHourMinuteSecond(t time.Time) string <span class="cov0" title="0">{
        return t.Format("2006年01月02日15点04分05")
}</span>
</pre>
		
		<pre class="file" id="file137" style="display: none">package urlx

import (
        "github.com/lazygophers/utils/candy"
        "net/url"
)

// SortQuery 对URL参数进行排序
func SortQuery(query url.Values) url.Values <span class="cov0" title="0">{
        if len(query) == 0 </span><span class="cov0" title="0">{
                return query
        }</span>

        <span class="cov0" title="0">keys := make([]string, 0, len(query))
        for key := range query </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>

        <span class="cov0" title="0">nq := url.Values{}
        for _, key := range candy.Sort(keys) </span><span class="cov0" title="0">{
                nq.Set(key, query.Get(key))
        }</span>

        <span class="cov0" title="0">return nq</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">// validate 包提供了结构体校验功能，基于go-playground/validator库实现
package utils

import (
        "github.com/go-playground/validator/v10"
        "github.com/lazygophers/log"
)

// Validate函数用于校验结构体对象
//
// 参数:
//   - m: 需要校验的结构体对象
//
// 返回:
//   - error: 校验失败时返回错误信息
//
// 错误处理会自动记录到日志系统
var validate = validator.New()

func Validate(m interface{}) (err error) <span class="cov0" title="0">{
        err = validate.Struct(m)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
