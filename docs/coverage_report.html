
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>anyx: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lazygophers/utils/anyx/map.go (98.6%)</option>
				
				<option value="file1">github.com/lazygophers/utils/anyx/map_any.go (99.3%)</option>
				
				<option value="file2">github.com/lazygophers/utils/app/info.go (0.0%)</option>
				
				<option value="file3">github.com/lazygophers/utils/atexit/atexit_darwin.go (100.0%)</option>
				
				<option value="file4">github.com/lazygophers/utils/bufiox/scan.go (100.0%)</option>
				
				<option value="file5">github.com/lazygophers/utils/candy/abs.go (100.0%)</option>
				
				<option value="file6">github.com/lazygophers/utils/candy/all.go (100.0%)</option>
				
				<option value="file7">github.com/lazygophers/utils/candy/any.go (100.0%)</option>
				
				<option value="file8">github.com/lazygophers/utils/candy/average.go (100.0%)</option>
				
				<option value="file9">github.com/lazygophers/utils/candy/bottom.go (100.0%)</option>
				
				<option value="file10">github.com/lazygophers/utils/candy/cbrt.go (100.0%)</option>
				
				<option value="file11">github.com/lazygophers/utils/candy/chunk.go (100.0%)</option>
				
				<option value="file12">github.com/lazygophers/utils/candy/contains.go (100.0%)</option>
				
				<option value="file13">github.com/lazygophers/utils/candy/contains_using.go (100.0%)</option>
				
				<option value="file14">github.com/lazygophers/utils/candy/deep_copy.go (92.9%)</option>
				
				<option value="file15">github.com/lazygophers/utils/candy/deep_equal.go (98.1%)</option>
				
				<option value="file16">github.com/lazygophers/utils/candy/diff.go (100.0%)</option>
				
				<option value="file17">github.com/lazygophers/utils/candy/diff_slice.go (100.0%)</option>
				
				<option value="file18">github.com/lazygophers/utils/candy/drop.go (100.0%)</option>
				
				<option value="file19">github.com/lazygophers/utils/candy/each.go (100.0%)</option>
				
				<option value="file20">github.com/lazygophers/utils/candy/each_reverse.go (100.0%)</option>
				
				<option value="file21">github.com/lazygophers/utils/candy/each_stop_with_error.go (100.0%)</option>
				
				<option value="file22">github.com/lazygophers/utils/candy/filter.go (100.0%)</option>
				
				<option value="file23">github.com/lazygophers/utils/candy/filter_not.go (100.0%)</option>
				
				<option value="file24">github.com/lazygophers/utils/candy/first.go (100.0%)</option>
				
				<option value="file25">github.com/lazygophers/utils/candy/first_or.go (100.0%)</option>
				
				<option value="file26">github.com/lazygophers/utils/candy/index.go (100.0%)</option>
				
				<option value="file27">github.com/lazygophers/utils/candy/join.go (100.0%)</option>
				
				<option value="file28">github.com/lazygophers/utils/candy/last.go (100.0%)</option>
				
				<option value="file29">github.com/lazygophers/utils/candy/last_or.go (100.0%)</option>
				
				<option value="file30">github.com/lazygophers/utils/candy/map.go (100.0%)</option>
				
				<option value="file31">github.com/lazygophers/utils/candy/max.go (100.0%)</option>
				
				<option value="file32">github.com/lazygophers/utils/candy/min.go (100.0%)</option>
				
				<option value="file33">github.com/lazygophers/utils/candy/pluck_int.go (97.5%)</option>
				
				<option value="file34">github.com/lazygophers/utils/candy/pluck_int32.go (100.0%)</option>
				
				<option value="file35">github.com/lazygophers/utils/candy/pluck_int64.go (100.0%)</option>
				
				<option value="file36">github.com/lazygophers/utils/candy/pluck_string.go (100.0%)</option>
				
				<option value="file37">github.com/lazygophers/utils/candy/pluck_string_slice.go (100.0%)</option>
				
				<option value="file38">github.com/lazygophers/utils/candy/pluck_uint32.go (100.0%)</option>
				
				<option value="file39">github.com/lazygophers/utils/candy/pluck_uint64.go (100.0%)</option>
				
				<option value="file40">github.com/lazygophers/utils/candy/pow.go (100.0%)</option>
				
				<option value="file41">github.com/lazygophers/utils/candy/random.go (100.0%)</option>
				
				<option value="file42">github.com/lazygophers/utils/candy/reduce.go (100.0%)</option>
				
				<option value="file43">github.com/lazygophers/utils/candy/remove.go (100.0%)</option>
				
				<option value="file44">github.com/lazygophers/utils/candy/remove_index.go (100.0%)</option>
				
				<option value="file45">github.com/lazygophers/utils/candy/remove_slice.go (100.0%)</option>
				
				<option value="file46">github.com/lazygophers/utils/candy/reverse.go (100.0%)</option>
				
				<option value="file47">github.com/lazygophers/utils/candy/same.go (100.0%)</option>
				
				<option value="file48">github.com/lazygophers/utils/candy/shuffle.go (100.0%)</option>
				
				<option value="file49">github.com/lazygophers/utils/candy/slice_equal.go (94.1%)</option>
				
				<option value="file50">github.com/lazygophers/utils/candy/sort.go (100.0%)</option>
				
				<option value="file51">github.com/lazygophers/utils/candy/sort_using.go (100.0%)</option>
				
				<option value="file52">github.com/lazygophers/utils/candy/spare.go (100.0%)</option>
				
				<option value="file53">github.com/lazygophers/utils/candy/sqrt.go (100.0%)</option>
				
				<option value="file54">github.com/lazygophers/utils/candy/string.go (100.0%)</option>
				
				<option value="file55">github.com/lazygophers/utils/candy/sum.go (100.0%)</option>
				
				<option value="file56">github.com/lazygophers/utils/candy/to_array_string.go (100.0%)</option>
				
				<option value="file57">github.com/lazygophers/utils/candy/to_bool.go (100.0%)</option>
				
				<option value="file58">github.com/lazygophers/utils/candy/to_bytes.go (100.0%)</option>
				
				<option value="file59">github.com/lazygophers/utils/candy/to_float32.go (100.0%)</option>
				
				<option value="file60">github.com/lazygophers/utils/candy/to_float64.go (100.0%)</option>
				
				<option value="file61">github.com/lazygophers/utils/candy/to_float64_slice.go (100.0%)</option>
				
				<option value="file62">github.com/lazygophers/utils/candy/to_int.go (100.0%)</option>
				
				<option value="file63">github.com/lazygophers/utils/candy/to_int16.go (100.0%)</option>
				
				<option value="file64">github.com/lazygophers/utils/candy/to_int32.go (100.0%)</option>
				
				<option value="file65">github.com/lazygophers/utils/candy/to_int64.go (100.0%)</option>
				
				<option value="file66">github.com/lazygophers/utils/candy/to_int64_slice.go (100.0%)</option>
				
				<option value="file67">github.com/lazygophers/utils/candy/to_int8.go (100.0%)</option>
				
				<option value="file68">github.com/lazygophers/utils/candy/to_map.go (100.0%)</option>
				
				<option value="file69">github.com/lazygophers/utils/candy/to_map_int32_string.go (100.0%)</option>
				
				<option value="file70">github.com/lazygophers/utils/candy/to_map_int64_string.go (100.0%)</option>
				
				<option value="file71">github.com/lazygophers/utils/candy/to_map_string_any.go (100.0%)</option>
				
				<option value="file72">github.com/lazygophers/utils/candy/to_map_string_array_string.go (100.0%)</option>
				
				<option value="file73">github.com/lazygophers/utils/candy/to_map_string_int64.go (100.0%)</option>
				
				<option value="file74">github.com/lazygophers/utils/candy/to_map_string_string.go (100.0%)</option>
				
				<option value="file75">github.com/lazygophers/utils/candy/to_ptr.go (100.0%)</option>
				
				<option value="file76">github.com/lazygophers/utils/candy/to_string.go (100.0%)</option>
				
				<option value="file77">github.com/lazygophers/utils/candy/to_string_slice.go (98.8%)</option>
				
				<option value="file78">github.com/lazygophers/utils/candy/to_uint.go (100.0%)</option>
				
				<option value="file79">github.com/lazygophers/utils/candy/to_uint16.go (100.0%)</option>
				
				<option value="file80">github.com/lazygophers/utils/candy/to_uint32.go (100.0%)</option>
				
				<option value="file81">github.com/lazygophers/utils/candy/to_uint64.go (100.0%)</option>
				
				<option value="file82">github.com/lazygophers/utils/candy/to_uint8.go (100.0%)</option>
				
				<option value="file83">github.com/lazygophers/utils/candy/top.go (100.0%)</option>
				
				<option value="file84">github.com/lazygophers/utils/candy/unique.go (100.0%)</option>
				
				<option value="file85">github.com/lazygophers/utils/candy/unique_using.go (100.0%)</option>
				
				<option value="file86">github.com/lazygophers/utils/config/load.go (95.7%)</option>
				
				<option value="file87">github.com/lazygophers/utils/cryptox/aes.go (100.0%)</option>
				
				<option value="file88">github.com/lazygophers/utils/cryptox/blowfish.go (100.0%)</option>
				
				<option value="file89">github.com/lazygophers/utils/cryptox/chacha20.go (100.0%)</option>
				
				<option value="file90">github.com/lazygophers/utils/cryptox/des.go (100.0%)</option>
				
				<option value="file91">github.com/lazygophers/utils/cryptox/ecdh.go (100.0%)</option>
				
				<option value="file92">github.com/lazygophers/utils/cryptox/ecdsa.go (100.0%)</option>
				
				<option value="file93">github.com/lazygophers/utils/cryptox/hash_basic.go (100.0%)</option>
				
				<option value="file94">github.com/lazygophers/utils/cryptox/hash_blake2.go (100.0%)</option>
				
				<option value="file95">github.com/lazygophers/utils/cryptox/hash_crc.go (100.0%)</option>
				
				<option value="file96">github.com/lazygophers/utils/cryptox/hash_fnv.go (100.0%)</option>
				
				<option value="file97">github.com/lazygophers/utils/cryptox/hash_hmac.go (100.0%)</option>
				
				<option value="file98">github.com/lazygophers/utils/cryptox/hash_sha3.go (100.0%)</option>
				
				<option value="file99">github.com/lazygophers/utils/cryptox/hmac.go (100.0%)</option>
				
				<option value="file100">github.com/lazygophers/utils/cryptox/kdf.go (100.0%)</option>
				
				<option value="file101">github.com/lazygophers/utils/cryptox/rsa.go (100.0%)</option>
				
				<option value="file102">github.com/lazygophers/utils/cryptox/uuid.go (100.0%)</option>
				
				<option value="file103">github.com/lazygophers/utils/defaults/default.go (100.0%)</option>
				
				<option value="file104">github.com/lazygophers/utils/event/event.go (0.0%)</option>
				
				<option value="file105">github.com/lazygophers/utils/fake/user_agent.go (0.0%)</option>
				
				<option value="file106">github.com/lazygophers/utils/hystrix/hystrix.go (66.8%)</option>
				
				<option value="file107">github.com/lazygophers/utils/hystrix/tools.go (50.0%)</option>
				
				<option value="file108">github.com/lazygophers/utils/json/file.go (0.0%)</option>
				
				<option value="file109">github.com/lazygophers/utils/json/must.go (0.0%)</option>
				
				<option value="file110">github.com/lazygophers/utils/json/other.go (0.0%)</option>
				
				<option value="file111">github.com/lazygophers/utils/json/sonic.go (0.0%)</option>
				
				<option value="file112">github.com/lazygophers/utils/must.go (0.0%)</option>
				
				<option value="file113">github.com/lazygophers/utils/network/fiber.go (100.0%)</option>
				
				<option value="file114">github.com/lazygophers/utils/network/interface.go (67.6%)</option>
				
				<option value="file115">github.com/lazygophers/utils/network/ip.go (100.0%)</option>
				
				<option value="file116">github.com/lazygophers/utils/orm.go (0.0%)</option>
				
				<option value="file117">github.com/lazygophers/utils/osx/file.go (97.7%)</option>
				
				<option value="file118">github.com/lazygophers/utils/pyroscope/open.go (0.0%)</option>
				
				<option value="file119">github.com/lazygophers/utils/pyroscope/other.go (0.0%)</option>
				
				<option value="file120">github.com/lazygophers/utils/randx/any.go (7.2%)</option>
				
				<option value="file121">github.com/lazygophers/utils/randx/bool.go (15.8%)</option>
				
				<option value="file122">github.com/lazygophers/utils/randx/number.go (74.6%)</option>
				
				<option value="file123">github.com/lazygophers/utils/randx/time.go (13.8%)</option>
				
				<option value="file124">github.com/lazygophers/utils/routine/routine.go (0.0%)</option>
				
				<option value="file125">github.com/lazygophers/utils/runtime/exit.go (35.7%)</option>
				
				<option value="file126">github.com/lazygophers/utils/runtime/runtime.go (87.2%)</option>
				
				<option value="file127">github.com/lazygophers/utils/runtime/system_darwin.go (100.0%)</option>
				
				<option value="file128">github.com/lazygophers/utils/singledo/group.go (0.0%)</option>
				
				<option value="file129">github.com/lazygophers/utils/singledo/singledo.go (0.0%)</option>
				
				<option value="file130">github.com/lazygophers/utils/stringx/rand.go (100.0%)</option>
				
				<option value="file131">github.com/lazygophers/utils/stringx/string.go (93.7%)</option>
				
				<option value="file132">github.com/lazygophers/utils/stringx/strings.go (100.0%)</option>
				
				<option value="file133">github.com/lazygophers/utils/stringx/unicode.go (100.0%)</option>
				
				<option value="file134">github.com/lazygophers/utils/stringx/utf16.go (100.0%)</option>
				
				<option value="file135">github.com/lazygophers/utils/unit/network.go (0.0%)</option>
				
				<option value="file136">github.com/lazygophers/utils/unit/time.go (0.0%)</option>
				
				<option value="file137">github.com/lazygophers/utils/urlx/query.go (0.0%)</option>
				
				<option value="file138">github.com/lazygophers/utils/validate.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package anyx

import (
        "fmt"
        "maps"
        "reflect"

        "golang.org/x/exp/constraints"
)

type ValueType int

const (
        ValueUnknown ValueType = iota
        ValueNumber
        ValueString
        ValueBool
)

func CheckValueType(val interface{}) ValueType <span class="cov10" title="19">{
        switch val.(type) </span>{
        case bool:<span class="cov3" title="2">
                return ValueBool</span>
        case int, int8, int16, int32, int64,
                uint, uint8, uint16, uint32, uint64,
                float32, float64:<span class="cov8" title="12">
                return ValueNumber</span>
        case string, []byte:<span class="cov3" title="2">
                return ValueString</span>
        default:<span class="cov4" title="3">
                return ValueUnknown</span>
        }
}

func MapKeysString(m interface{}) []string <span class="cov5" title="5">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov5" title="4">if t.IsNil() </span><span class="cov1" title="1">{
                panic("nil map")</span>
        }

        <span class="cov4" title="3">keyType := t.Type().Key()
        if keyType.Kind() != reflect.String </span><span class="cov1" title="1">{
                panic("map key type required string")</span>
        }

        <span class="cov3" title="2">result := make([]string, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.String())
        }</span>

        <span class="cov3" title="2">return result</span>
}

func MapKeysUint32(m interface{}) []uint32 <span class="cov5" title="5">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov5" title="4">if t.IsNil() </span><span class="cov1" title="1">{
                panic("nil map")</span>
        }

        <span class="cov4" title="3">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint32 </span><span class="cov1" title="1">{
                panic("map key type required uint32")</span>
        }

        <span class="cov3" title="2">result := make([]uint32, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, uint32(v.Uint()))
        }</span>

        <span class="cov3" title="2">return result</span>
}

func MapKeysUint64(m interface{}) []uint64 <span class="cov5" title="5">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }

        <span class="cov5" title="4">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint64 </span><span class="cov1" title="1">{
                panic("map key type required uint64")</span>
        }

        <span class="cov4" title="3">result := make([]uint64, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.Uint())
        }</span>

        <span class="cov4" title="3">return result</span>
}

func MapKeysInt32(m interface{}) []int32 <span class="cov5" title="5">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov5" title="4">if t.IsNil() </span><span class="cov1" title="1">{
                return []int32{}
        }</span>

        <span class="cov4" title="3">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int32 </span><span class="cov1" title="1">{
                panic("map key type required int32")</span>
        }

        <span class="cov3" title="2">result := make([]int32, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, int32(v.Int()))
        }</span>

        <span class="cov3" title="2">return result</span>
}

func MapKeysInt64(m interface{}) []int64 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []int64{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int64 </span><span class="cov1" title="1">{
                panic("map key type required int64")</span>
        }

        <span class="cov1" title="1">result := make([]int64, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.Int())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysInt(m interface{}) []int <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []int{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int </span><span class="cov1" title="1">{
                panic("map key type required int")</span>
        }

        <span class="cov1" title="1">result := make([]int, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, int(v.Int()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysInt8(m interface{}) []int8 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []int8{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int8 </span><span class="cov1" title="1">{
                panic("map key type required int8")</span>
        }

        <span class="cov1" title="1">result := make([]int8, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, int8(v.Int()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysInt16(m interface{}) []int16 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []int16{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int16 </span><span class="cov1" title="1">{
                panic("map key type required int16")</span>
        }

        <span class="cov1" title="1">result := make([]int16, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, int16(v.Int()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysUint(m interface{}) []uint <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []uint{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint </span><span class="cov1" title="1">{
                panic("map key type required uint")</span>
        }

        <span class="cov1" title="1">result := make([]uint, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, uint(v.Uint()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysUint8(m interface{}) []uint8 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []uint8{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint8 </span><span class="cov1" title="1">{
                panic("map key type required uint8")</span>
        }

        <span class="cov1" title="1">result := make([]uint8, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, uint8(v.Uint()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysUint16(m interface{}) []uint16 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []uint16{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint16 </span><span class="cov1" title="1">{
                panic("map key type required uint16")</span>
        }

        <span class="cov1" title="1">result := make([]uint16, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, uint16(v.Uint()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysFloat32(m interface{}) []float32 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []float32{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Float32 </span><span class="cov1" title="1">{
                panic("map key type required float32")</span>
        }

        <span class="cov1" title="1">result := make([]float32, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, float32(v.Float()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysFloat64(m interface{}) []float64 <span class="cov5" title="4">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov4" title="3">if t.IsNil() </span><span class="cov1" title="1">{
                return []float64{}
        }</span>

        <span class="cov3" title="2">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Float64 </span><span class="cov1" title="1">{
                panic("map key type required float64")</span>
        }

        <span class="cov1" title="1">result := make([]float64, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.Float())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysInterface(m interface{}) []interface{} <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov1" title="1">result := make([]interface{}, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.Interface())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysAny(m interface{}) []interface{} <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov1" title="1">result := make([]interface{}, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov4" title="3">{
                result = append(result, v.Interface())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapKeysNumber(m interface{}) []interface{} <span class="cov5" title="5">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov5" title="4">if t.IsNil() </span><span class="cov1" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov4" title="3">keyType := t.Type().Key()
        switch keyType.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
                reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
                reflect.Float32, reflect.Float64:<span class="cov3" title="2"></span>
                // valid number types
        default:<span class="cov1" title="1">
                panic("map key type required number")</span>
        }

        <span class="cov3" title="2">result := make([]interface{}, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov5" title="5">{
                result = append(result, v.Interface())
        }</span>

        <span class="cov3" title="2">return result</span>
}

func MapValues[K constraints.Ordered, V any](m map[K]V) []V <span class="cov4" title="3">{
        res := make([]V, 0, len(m))
        for _, v := range m </span><span class="cov6" title="6">{
                res = append(res, v)
        }</span>
        <span class="cov4" title="3">return res</span>
}

func MapValuesAny(m interface{}) []interface{} <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov1" title="1">result := make([]interface{}, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov4" title="3">{
                result = append(result, iter.Value().Interface())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapValuesString(m interface{}) []string <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []string{}
        }</span>

        <span class="cov1" title="1">result := make([]string, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov3" title="2">{
                result = append(result, iter.Value().String())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapValuesInt(m interface{}) []int <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []int{}
        }</span>

        <span class="cov1" title="1">result := make([]int, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov3" title="2">{
                result = append(result, int(iter.Value().Int()))
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MapValuesFloat64(m interface{}) []float64 <span class="cov4" title="3">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }
        <span class="cov3" title="2">if t.IsNil() </span><span class="cov1" title="1">{
                return []float64{}
        }</span>

        <span class="cov1" title="1">result := make([]float64, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov3" title="2">{
                result = append(result, iter.Value().Float())
        }</span>

        <span class="cov1" title="1">return result</span>
}

func MergeMap[K constraints.Ordered, V any](source, target map[K]V) map[K]V <span class="cov5" title="4">{
        res := maps.Clone(source)

        if len(target) &gt; 0 </span><span class="cov4" title="3">{
                for k, v := range target </span><span class="cov6" title="6">{
                        res[k] = v
                }</span>
        }

        <span class="cov5" title="4">return res</span>
}

func KeyBy(list interface{}, fieldName string) interface{} <span class="cov8" title="13">{
        if list == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov8" title="12">lv := reflect.ValueOf(list)

        switch lv.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov8" title="11"></span>
        default:<span class="cov1" title="1">
                panic("list required slice or array type")</span>
        }

        <span class="cov8" title="11">ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov6" title="6">{
                evs = evs.Elem()
        }</span>

        <span class="cov8" title="11">if evs.Kind() != reflect.Struct </span><span class="cov3" title="2">{
                panic("list element is not struct")</span>
        }

        <span class="cov7" title="9">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov7" title="8">m := reflect.MakeMapWithSize(reflect.MapOf(field.Type, ev), lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov9" title="18">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov9" title="14">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov9" title="18">if !elemStruct.IsValid() </span><span class="cov4" title="3">{
                        continue</span>
                }

                <span class="cov9" title="15">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov9" title="15">m.SetMapIndex(elemStruct.FieldByIndex(field.Index), elem)</span>
        }

        <span class="cov7" title="8">return m.Interface()</span>
}

func KeyByUint64[M any](list []*M, fieldName string) map[uint64]*M <span class="cov6" title="6">{
        if len(list) == 0 </span><span class="cov1" title="1">{
                return map[uint64]*M{}
        }</span>

        <span class="cov5" title="5">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov5" title="5">{
                evs = evs.Elem()
        }</span>

        <span class="cov5" title="5">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov5" title="4">m := make(map[uint64]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov6" title="6">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov6" title="6">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov6" title="6">if !elemStruct.IsValid() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov5" title="5">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov5" title="5">m[elemStruct.FieldByIndex(field.Index).Uint()] = elem.Interface().(*M)</span>
        }

        <span class="cov5" title="4">return m</span>
}

func KeyByInt64[M any](list []*M, fieldName string) map[int64]*M <span class="cov5" title="5">{
        if len(list) == 0 </span><span class="cov1" title="1">{
                return map[int64]*M{}
        }</span>

        <span class="cov5" title="4">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                evs = evs.Elem()
        }</span>

        <span class="cov5" title="4">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov3" title="2">m := make(map[int64]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov5" title="4">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov5" title="4">if !elemStruct.IsValid() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="3">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov4" title="3">m[elemStruct.FieldByIndex(field.Index).Int()] = elem.Interface().(*M)</span>
        }

        <span class="cov3" title="2">return m</span>
}

func KeyByString[M any](list []*M, fieldName string) map[string]*M <span class="cov5" title="5">{
        if len(list) == 0 </span><span class="cov1" title="1">{
                return map[string]*M{}
        }</span>

        <span class="cov5" title="4">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                evs = evs.Elem()
        }</span>

        <span class="cov5" title="4">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov3" title="2">m := make(map[string]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov5" title="4">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov5" title="4">if !elemStruct.IsValid() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="3">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov4" title="3">m[elemStruct.FieldByIndex(field.Index).String()] = elem.Interface().(*M)</span>
        }

        <span class="cov3" title="2">return m</span>
}

func KeyByInt32[M any](list []*M, fieldName string) map[int32]*M <span class="cov5" title="5">{
        if len(list) == 0 </span><span class="cov1" title="1">{
                return map[int32]*M{}
        }</span>

        <span class="cov5" title="4">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                evs = evs.Elem()
        }</span>

        <span class="cov5" title="4">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov3" title="2">m := make(map[int32]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov5" title="4">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov5" title="4">if !elemStruct.IsValid() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="3">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov4" title="3">m[int32(elemStruct.FieldByIndex(field.Index).Int())] = elem.Interface().(*M)</span>
        }

        <span class="cov3" title="2">return m</span>
}

func Slice2Map[M constraints.Ordered](list []M) map[M]bool <span class="cov5" title="4">{
        m := make(map[M]bool, len(list))

        for _, v := range list </span><span class="cov8" title="11">{
                m[v] = true
        }</span>

        <span class="cov5" title="4">return m</span>
}

</pre>
		
		<pre class="file" id="file1" style="display: none">package anyx

import (
        "errors"
        "fmt"
        "math"
        "strings"
        "sync"

        "github.com/lazygophers/utils/candy"
        "github.com/lazygophers/utils/json"
        "go.uber.org/atomic"
        "gopkg.in/yaml.v3"
)

type MapAny struct {
        data *sync.Map
        cut  *atomic.Bool
        seq  *atomic.String
}

var (
        ErrNotFound = errors.New("not found")
)

func NewMap(m map[string]interface{}) *MapAny <span class="cov5" title="83">{
        m2 := &amp;MapAny{
                data: &amp;sync.Map{},
                cut:  atomic.NewBool(false),
                seq:  atomic.NewString(""),
        }
        for k, v := range m </span><span class="cov5" title="178">{
                m2.data.Store(k, v)
        }</span>
        <span class="cov5" title="83">return m2</span>
}

func NewMapWithJson(s []byte) (*MapAny, error) <span class="cov1" title="3">{
        var m map[string]interface{}
        err := json.Unmarshal(s, &amp;m)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="2">return NewMap(m), nil</span>
}

func NewMapWithYaml(s []byte) (*MapAny, error) <span class="cov1" title="2">{
        var m map[string]interface{}
        err := yaml.Unmarshal(s, &amp;m)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return NewMap(m), nil</span>
}

func NewMapWithAny(s interface{}) (*MapAny, error) <span class="cov2" title="5">{
        buf, err := json.Marshal(s)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov2" title="4">var m map[string]interface{}
        err = yaml.Unmarshal(buf, &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="4">return NewMap(m), nil</span>
}

func (p *MapAny) EnableCut(seq string) *MapAny <span class="cov2" title="8">{
        p.cut.Store(true)
        p.seq.Store(seq)
        return p
}</span>

func (p *MapAny) DisableCut() *MapAny <span class="cov1" title="1">{
        p.cut.Store(false)
        return p
}</span>

func (p *MapAny) Set(key string, value interface{}) <span class="cov9" title="10007">{
        p.data.Store(key, value)
}</span>

func (p *MapAny) Get(key string) (interface{}, error) <span class="cov3" title="17">{
        val, ok := p.get(key)
        if !ok </span><span class="cov3" title="10">{
                return nil, ErrNotFound
        }</span>

        <span class="cov2" title="7">return val, nil</span>
}

func (p *MapAny) get(key string) (interface{}, bool) <span class="cov10" title="20202">{
        var val interface{}
        var ok bool

        if val, ok = p.data.Load(key); ok </span><span class="cov9" title="20152">{
                return val, true
        }</span>
        <span class="cov4" title="50">if !p.cut.Load() </span><span class="cov4" title="41">{
                return nil, false
        }</span>

        <span class="cov2" title="9">seq := p.seq.Load()
        keys := strings.Split(key, seq)

        data := p.data
        var m *MapAny
        for len(keys) &gt; 1 </span><span class="cov3" title="12">{
                k := keys[0]
                keys = keys[1:]

                val, ok = data.Load(k)
                if !ok </span><span class="cov1" title="1">{
                        return nil, false
                }</span>

                <span class="cov3" title="11">m = p.toMap(val)
                if m == nil </span><span class="cov0" title="0">{
                        return nil, false
                }</span>

                <span class="cov3" title="11">data = m.data</span>
        }

        <span class="cov2" title="8">if len(keys) &gt; 0 </span><span class="cov2" title="8">{
                if val, ok = data.Load(keys[0]); ok </span><span class="cov1" title="1">{
                        return val, true
                }</span>
                <span class="cov2" title="7">return nil, false</span>
        }

        <span class="cov0" title="0">return nil, false</span>
}

func (p *MapAny) Exists(key string) bool <span class="cov9" title="10027">{
        _, ok := p.get(key)
        if !ok </span><span class="cov3" title="23">{
                return false
        }</span>

        <span class="cov9" title="10004">return true</span>
}

func (p *MapAny) GetBool(key string) bool <span class="cov2" title="9">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov2" title="8">return candy.ToBool(val)</span>
}

func (p *MapAny) GetInt(key string) int <span class="cov9" title="10010">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov9" title="10009">return candy.ToInt(val)</span>
}

func (p *MapAny) GetInt32(key string) int32 <span class="cov1" title="3">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="2">return candy.ToInt32(val)</span>
}

func (p *MapAny) GetInt64(key string) int64 <span class="cov1" title="3">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="2">return candy.ToInt64(val)</span>
}

func (p *MapAny) GetUint16(key string) uint16 <span class="cov1" title="3">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="2">return candy.ToUint16(val)</span>
}

func (p *MapAny) GetUint32(key string) uint32 <span class="cov1" title="3">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="2">return candy.ToUint32(val)</span>
}

func (p *MapAny) GetUint64(key string) uint64 <span class="cov1" title="3">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="2">return candy.ToUint64(val)</span>
}

func (p *MapAny) GetFloat64(key string) float64 <span class="cov2" title="4">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov1" title="3">return candy.ToFloat64(val)</span>
}

func (p *MapAny) GetString(key string) string <span class="cov3" title="20">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov3" title="19">return candy.ToString(val)</span>
}

func (p *MapAny) GetBytes(key string) []byte <span class="cov3" title="18">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return []byte("")
        }</span>

        <span class="cov3" title="17">switch x := val.(type) </span>{
        case bool:<span class="cov1" title="2">
                if x </span><span class="cov1" title="1">{
                        return []byte("1")
                }</span>
                <span class="cov1" title="1">return []byte("0")</span>
        case int:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int8:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int16:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int32:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int64:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint8:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint16:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint32:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint64:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case float32:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%v", x))</span>
        case float64:<span class="cov1" title="1">
                return []byte(fmt.Sprintf("%v", x))</span>
        case string:<span class="cov1" title="1">
                return []byte(x)</span>
        case []byte:<span class="cov1" title="1">
                return x</span>
        default:<span class="cov1" title="1">
                return []byte("")</span>
        }
}

func (p *MapAny) GetMap(key string) *MapAny <span class="cov2" title="6">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return NewMap(nil)
        }</span>

        <span class="cov2" title="5">return p.toMap(val)</span>
}

func (p *MapAny) toMap(val interface{}) *MapAny <span class="cov4" title="39">{
        switch x := val.(type) </span>{
        case bool, int, int8, int16, int32, int64,
                uint, uint8, uint16, uint32, uint64,
                float32, float64:<span class="cov3" title="14">
                return NewMap(nil)</span>
        case string:<span class="cov2" title="8">
                var m map[string]interface{}
                err := json.Unmarshal([]byte(x), &amp;m)
                if err != nil </span><span class="cov2" title="6">{
                        return NewMap(nil)
                }</span>
                <span class="cov1" title="2">return NewMap(m)</span>
        case []byte:<span class="cov1" title="2">
                var m map[string]interface{}
                err := json.Unmarshal(x, &amp;m)
                if err != nil </span><span class="cov1" title="1">{
                        return NewMap(nil)
                }</span>
                <span class="cov1" title="1">return NewMap(m)</span>
        case map[string]interface{}:<span class="cov3" title="10">
                return NewMap(x)</span>
        case map[interface{}]interface{}:<span class="cov1" title="1">
                m := NewMap(nil)
                for k, v := range x </span><span class="cov1" title="2">{
                        m.Set(candy.ToString(k), v)
                }</span>
                <span class="cov1" title="1">return m</span>
        default:<span class="cov2" title="4">
                buf, err := json.Marshal(x)
                if err != nil </span><span class="cov1" title="2">{
                        return NewMap(nil)
                }</span>
                <span class="cov1" title="2">var m map[string]interface{}
                err = json.Unmarshal(buf, &amp;m)
                if err != nil </span><span class="cov1" title="1">{
                        return NewMap(nil)
                }</span>
                <span class="cov1" title="1">return NewMap(m)</span>
        }
}

func (p *MapAny) GetSlice(key string) []interface{} <span class="cov3" title="19">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="18">switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint64:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case [][]byte:<span class="cov1" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="2">
                return x</span>
        default:<span class="cov1" title="1">
                return []interface{}{}</span>
        }
}

func (p *MapAny) GetStringSlice(key string) []string <span class="cov3" title="18">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="17">switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint64:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="1">
                return x</span>
        case [][]byte:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, string(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="1">
                var v []string
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov1" title="1">
                return []string{}</span>
        }
}

func (p *MapAny) GetUint64Slice(key string) []uint64 <span class="cov3" title="19">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="18">switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint64:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="2">
                var v []uint64
                for _, val := range x </span><span class="cov2" title="4">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="2">return v</span>
        case [][]byte:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov1" title="1">
                return []uint64{}</span>
        }
}

func (p *MapAny) GetInt64Slice(key string) []int64 <span class="cov1" title="2">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov1" title="1">return candy.ToInt64Slice(val)</span>
}

func (p *MapAny) GetUint32Slice(key string) []uint32 <span class="cov3" title="18">{
        val, ok := p.get(key)
        if !ok </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="17">switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                return x</span>
        case []uint64:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case [][]byte:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="2">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov1" title="3">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov1" title="1">
                return []uint32{}</span>
        }
}

func (p *MapAny) ToSyncMap() *sync.Map <span class="cov1" title="2">{
        var m sync.Map
        p.data.Range(func(key, value interface{}) bool </span><span class="cov2" title="5">{
                m.Store(key, value)
                return true
        }</span>)
        <span class="cov1" title="2">return &amp;m</span>
}

func (p *MapAny) ToMap() map[string]interface{} <span class="cov1" title="2">{
        m := map[string]interface{}{}
        p.data.Range(func(key, value interface{}) bool </span><span class="cov3" title="11">{
                k := candy.ToString(key)

                switch x := value.(type) </span>{
                case float32:<span class="cov1" title="2">
                        if math.Floor(float64(x)) == float64(x) </span><span class="cov1" title="1">{
                                m[k] = int32(x)
                        }</span> else<span class="cov1" title="1"> {
                                m[k] = x
                        }</span>
                case float64:<span class="cov1" title="2">
                        if math.Floor(x) == x </span><span class="cov1" title="1">{
                                m[k] = int64(x)
                        }</span> else<span class="cov1" title="1"> {
                                m[k] = x
                        }</span>
                case *MapAny:<span class="cov1" title="1">
                        m[k] = x.ToMap()</span>
                case bool,
                        int, int8, int16, int32, int64,
                        uint, uint8, uint16, uint32, uint64,
                        string, []byte:<span class="cov2" title="5">
                        m[k] = x</span>
                default:<span class="cov1" title="1">
                        m[k] = x</span>
                }

                <span class="cov3" title="11">return true</span>
        })
        <span class="cov1" title="2">return m</span>
}

func (p *MapAny) Clone() *MapAny <span class="cov1" title="1">{
        return &amp;MapAny{
                data: p.ToSyncMap(),
                cut:  atomic.NewBool(p.cut.Load()),
                seq:  atomic.NewString(p.seq.Load()),
        }
}</span>

func (p *MapAny) Range(f func(key, value interface{}) bool) <span class="cov1" title="3">{
        p.data.Range(func(key, value interface{}) bool </span><span class="cov9" title="10006">{
                return f(key, value)
        }</span>)
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

var Organization = "lazygophers"

var Name string

var Version string

type ReleaseType uint8

const (
        Debug ReleaseType = iota
        Test
        Alpha
        Beta
        Release
)

func (p ReleaseType) String() string <span class="cov0" title="0">{
        switch p </span>{
        case Release:<span class="cov0" title="0">
                return "release"</span>
        case Beta:<span class="cov0" title="0">
                return "beta"</span>
        case Alpha:<span class="cov0" title="0">
                return "alpha"</span>
        case Test:<span class="cov0" title="0">
                return "test"</span>
        case Debug:<span class="cov0" title="0">
                fallthrough</span>
        default:<span class="cov0" title="0">
                return "debug"</span>
        }
}

func (p ReleaseType) () string <span class="cov0" title="0">{
        return p.String()
}</span>

var PackageType ReleaseType
</pre>
		
		<pre class="file" id="file3" style="display: none">//go:build darwin

package atexit

import (
        "os"
        "os/signal"
        "sync"
        "syscall"
)

var (
        callbacks   []func()
        callbacksMu sync.RWMutex
        signalOnce  sync.Once
)

//  - macOS
func initSignalHandler() <span class="cov9" title="253">{
        signalOnce.Do(func() </span><span class="cov3" title="4">{
                c := make(chan os.Signal, 1)
                // macOS  Unix 
                signal.Notify(c, 
                        syscall.SIGINT, 
                        syscall.SIGTERM, 
                        syscall.SIGHUP,  // 
                        syscall.SIGQUIT, // 
                )
                
                go func() </span><span class="cov3" title="4">{
                        &lt;-c
                        executeCallbacks()
                        os.Exit(0)
                }</span>()
        })
}

// 
func executeCallbacks() <span class="cov2" title="3">{
        callbacksMu.RLock()
        cbList := make([]func(), len(callbacks))
        copy(cbList, callbacks)
        callbacksMu.RUnlock()
        
        // 
        for _, cb := range cbList </span><span class="cov4" title="8">{
                if cb != nil </span><span class="cov4" title="7">{
                        func() </span><span class="cov4" title="7">{
                                defer func() </span><span class="cov4" title="7">{
                                        // panic
                                        if r := recover(); r != nil </span>{<span class="cov1" title="1">
                                                // macOS 
                                        }</span>
                                }()
                                <span class="cov4" title="7">cb()</span>
                        }()
                }
        }
}

// Register 
func Register(callback func()) <span class="cov10" title="254">{
        if callback == nil </span><span class="cov1" title="1">{
                return
        }</span>
        
        // 
        <span class="cov9" title="253">initSignalHandler()
        
        callbacksMu.Lock()
        callbacks = append(callbacks, callback)
        callbacksMu.Unlock()</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package bufiox

import "bytes"

// ScanBy 
//  seq:  []byte("\n") 
// : EOF
//
//        advance: 
//        token: 
//        err: nil
//
// 
//  1. atEOFtruenil
//  2. EOF
//  3. bufio.Scanner
//
// ScanBy 
//  seq 
//  bufio.SplitFunc 
func ScanBy(seq []byte) func(data []byte, atEOF bool) (advance int, token []byte, err error) <span class="cov4" title="3">{
        return func(data []byte, atEOF bool) (advance int, token []byte, err error) </span><span class="cov7" title="9">{
                if atEOF &amp;&amp; len(data) == 0 </span><span class="cov1" title="1">{
                        return 0, nil, nil
                }</span>

                <span class="cov7" title="8">if i := bytes.Index(data, seq); i &gt;= 0 </span><span class="cov6" title="6">{
                        // We have a full newline-terminated line.
                        return i + len(seq), data[0:i], nil
                }</span>

                <span class="cov3" title="2">if atEOF </span><span class="cov1" title="1">{
                        return len(data), data, nil
                }</span>

                <span class="cov1" title="1">return 0, nil, err</span>
        }
}

// ScanLines bufio.Scanner
//  data: 
//  atEOF: 
// : (advance, token, err)
// 
//  1. CRLFWindowsLFUnix
//  2. EOF
//  3. dropCRWindowsCR
//  4. bufio.Scanner
//
// ScanLines 
// (\n)Windows(\r\n)
// :
//   - data: 
//   - atEOF: 
//
// :
//   - advance: 
//   - token: CRLF
//   - err: 
func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error) <span class="cov10" title="19">{
        if atEOF &amp;&amp; len(data) == 0 </span><span class="cov4" title="3">{
                return 0, nil, nil
        }</span>
        <span class="cov9" title="16">if i := bytes.IndexByte(data, '\n'); i &gt;= 0 </span><span class="cov7" title="9">{
                // We have a full newline-terminated line.
                return i + 1, dropCR(data[0:i]), nil
        }</span>
        // If we're at EOF, we have a final, non-terminated line. Return it.
        <span class="cov6" title="7">if atEOF </span><span class="cov4" title="3">{
                return len(data), dropCR(data), nil
        }</span>
        // Request more data.
        <span class="cov5" title="4">return 0, nil, nil</span>
}

// dropCR 
// CR\r
// WindowsCRLF\r\n
// : CR
// dropCR (\r)
// WindowsCRLFLF
//  data: 
// : \r
func dropCR(data []byte) []byte <span class="cov10" title="19">{
        if len(data) &gt; 0 &amp;&amp; data[len(data)-1] == '\r' </span><span class="cov6" title="7">{
                return data[0 : len(data)-1]
        }</span>
        <span class="cov8" title="12">return data</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package candy 
//
//  Abs 
package candy

import (
        "golang.org/x/exp/constraints"
)

// Abs 
//
// 
// 
//
// :
//   - T:  Integer  Float 
//
// :
//   - s: 
//
// :
//   - T: 
//
// :
//
//        result := Abs(-42)     //  42
//        result := Abs(3.14)   //  3.14
//        result := Abs(0)      //  0
func Abs[T constraints.Integer | constraints.Float](s T) T <span class="cov10" title="26">{
        if s &lt; 0 </span><span class="cov6" title="8">{
                return -s
        }</span>

        <span class="cov8" title="18">return s</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package candy  Go 
package candy

// All 
//
// :
//   - ss: 
//   - f: 
//
// :
//   - bool:  true false
//
// :
//   -  nil  true
//   - 
//   - 
//
// :
//
//        numbers := []int{1, 2, 3, 4, 5}
//        result := All(numbers, func(n int) bool {
//            return n &gt; 0
//        }) //  true
//
//        result := All(numbers, func(n int) bool {
//            return n &gt; 5
//        }) //  false
func All[T any](ss []T, f func(T) bool) bool <span class="cov8" title="16">{
        //  nil 
        if len(ss) == 0 </span><span class="cov2" title="2">{
                return true
        }</span>

        // 
        <span class="cov8" title="14">for _, s := range ss </span><span class="cov10" title="29">{
                if !f(s) </span><span class="cov6" title="7">{
                        //  false
                        return false
                }</span>
        }

        //  true
        <span class="cov6" title="7">return true</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package candy  Go 
package candy

// Any 
//
// :
//   - ss: 
//   - f: 
//
// :
//   - bool:  true false
//
// :
//   -  nil  false
//   - 
//   - 
//
// :
//
//        numbers := []int{1, 2, 3, 4, 5}
//        result := Any(numbers, func(n int) bool {
//            return n &gt; 3
//        }) //  true
//
//        result := Any(numbers, func(n int) bool {
//            return n &gt; 10
//        }) //  false
func Any[T any](ss []T, f func(T) bool) bool <span class="cov8" title="11">{
        for _, s := range ss </span><span class="cov10" title="20">{
                if f(s) </span><span class="cov6" title="6">{
                        return true
                }</span>
        }

        <span class="cov5" title="5">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package candy 
package candy

import "golang.org/x/exp/constraints"

// Average 
//  float64 
// 
func Average[T constraints.Integer | constraints.Float](ss []T) (ret T) <span class="cov8" title="13">{
        if len(ss) == 0 </span><span class="cov4" title="4">{
                return
        }</span>

        //  float64 
        <span class="cov7" title="9">var sum float64
        for _, s := range ss </span><span class="cov10" title="25">{
                sum += float64(s)
        }</span>
        <span class="cov7" title="9">return T(sum / float64(len(ss)))</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package candy 
package candy

// Bottom  n 
//  n 
// 
func Bottom[T any](ss []T, n int) (ret []T) <span class="cov10" title="8">{
        if n &lt;= 0 </span><span class="cov4" title="2">{
                return []T{}
        }</span>
        <span class="cov8" title="6">if n &gt; len(ss) </span><span class="cov4" title="2">{
                n = len(ss)
        }</span>

        <span class="cov8" title="6">ret = make([]T, n)
        copy(ret, ss[len(ss)-n:])
        return ret</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package candy  Go 
package candy

import (
        "math"

        "golang.org/x/exp/constraints"
)

// Cbrt 
//
// :
//   - s: 
//
// :
//   - T: 
//
// :
//   - 
//   - 
//   - 
//
// :
//
//        result := Cbrt(8.0)      //  2.0
//        result := Cbrt(27)       //  3
//        result := Cbrt(-8.0)     //  -2.0
func Cbrt[T constraints.Integer | constraints.Float](s T) T <span class="cov10" title="14">{
        return T(math.Cbrt(float64(s)))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package candy

// Chunk 
//
// :
//   - ss: 
//   - size: 
//
// :
//   - [][]T: 
//
// :
//   -  size &lt;= 0
//   - 
func Chunk[T any](ss []T, size int) (ret [][]T) <span class="cov8" title="9">{
        if len(ss) == 0 || size &lt;= 0 </span><span class="cov4" title="3">{
                return [][]T{}
        }</span>

        <span class="cov7" title="6">for i := 0; i &lt; len(ss); i += size </span><span class="cov10" title="13">{
                end := i + size
                if end &gt; len(ss) </span><span class="cov4" title="3">{
                        end = len(ss)
                }</span>

                <span class="cov10" title="13">ret = append(ret, ss[i:end])</span>
        }

        <span class="cov7" title="6">return</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package candy  Go 
package candy

import (
        "golang.org/x/exp/constraints"
)

// Contains 
//
// T  constraints.Ordered 
// 
//   - ss: 
//   - s: 
//
// 
//   - bool:  true false
//
// 
//
//        numbers := []int{1, 2, 3, 4, 5}
//        found := Contains(numbers, 3) //  true
//        found = Contains(numbers, 6)  //  false
func Contains[T constraints.Ordered](ss []T, s T) bool <span class="cov8" title="25">{
        return ContainsUsing(ss, func(v T) bool </span><span class="cov10" title="58">{
                return s == v
        }</span>)
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package candy  Go 
package candy

// ContainsUsing 
//
// T 
// 
//   - ss: 
//   - f:  true
//
// 
//   - bool:  true false
//
// 
//
//        numbers := []int{1, 2, 3, 4, 5}
//        found := ContainsUsing(numbers, func(v int) bool {
//            return v &gt; 3
//        }) //  true
func ContainsUsing[T any](ss []T, f func(v T) bool) bool <span class="cov8" title="25">{
        // 
        for _, v := range ss </span><span class="cov10" title="58">{
                // 
                if f(v) </span><span class="cov7" title="17">{
                        return true
                }</span>
        }

        //  false
        <span class="cov5" title="8">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package candy

import (
        "reflect"

        "github.com/lazygophers/log"
)

// deepCopyValue  DeepCopy 
//  reflect.Value (v1 , v2 ) v1  v2
//
//  unexported
func deepCopyValue(v1, v2 reflect.Value) <span class="cov10" title="69">{
        if !v1.IsValid() || !v2.IsValid() </span><span class="cov3" title="4">{
                return
        }</span>

        // 
        <span class="cov9" title="65">for v1.Kind() == reflect.Ptr </span><span class="cov3" title="4">{
                //  nil
                if v1.IsNil() </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov3" title="3">v1 = v1.Elem()</span>
        }
        <span class="cov9" title="64">for v2.Kind() == reflect.Ptr </span><span class="cov3" title="4">{
                //  nil
                if v2.IsNil() </span><span class="cov3" title="3">{
                        v2.Set(reflect.New(v2.Type().Elem()))
                }</span>
                <span class="cov3" title="4">v2 = v2.Elem()</span>
        }

        // 
        <span class="cov9" title="64">if v1.Kind() == reflect.Invalid || v2.Kind() == reflect.Invalid </span><span class="cov0" title="0">{
                return
        }</span>

        // 
        <span class="cov9" title="64">if v1.Type() != v2.Type() </span><span class="cov1" title="1">{
                log.Panicf(" %s  %s ", v1.Type(), v2.Type())
        }</span>

        <span class="cov9" title="63">switch v1.Kind() </span>{
        //  Map
        case reflect.Map:<span class="cov3" title="4">
                if v1.IsNil() </span><span class="cov1" title="1">{
                        v2.Set(reflect.Zero(v2.Type()))
                        return
                }</span>
                //  Map 
                <span class="cov3" title="3">v2.Set(reflect.MakeMap(v1.Type()))
                //  Map 
                for _, k := range v1.MapKeys() </span><span class="cov4" title="5">{
                        val1 := v1.MapIndex(k)
                        val2 := reflect.New(val1.Type()).Elem()
                        deepCopyValue(val1, val2)
                        v2.SetMapIndex(k, val2)
                }</span>

        //  Slice
        case reflect.Slice:<span class="cov4" title="6">
                if v1.IsNil() </span><span class="cov1" title="1">{
                        v2.Set(reflect.Zero(v2.Type()))
                        return
                }</span>
                //  Slice 
                <span class="cov4" title="5">v2.Set(reflect.MakeSlice(v1.Type(), v1.Len(), v1.Cap()))
                //  Slice 
                for i := 0; i &lt; v1.Len(); i++ </span><span class="cov6" title="12">{
                        deepCopyValue(v1.Index(i), v2.Index(i))
                }</span>

        //  Array
        case reflect.Array:<span class="cov1" title="1">
                //  Array 
                for i := 0; i &lt; v1.Len(); i++ </span><span class="cov3" title="3">{
                        deepCopyValue(v1.Index(i), v2.Index(i))
                }</span>

        //  Struct
        case reflect.Struct:<span class="cov3" title="3">
                //  Struct 
                for i := 0; i &lt; v1.NumField(); i++ </span><span class="cov3" title="4">{
                        deepCopyValue(v1.Field(i), v2.Field(i))
                }</span>

        //  Interface
        case reflect.Interface:<span class="cov4" title="5">
                if v1.IsNil() </span><span class="cov2" title="2">{
                        return
                }</span>
                // 
                <span class="cov3" title="3">srcElem := v1.Elem()
                // 
                dstElem := reflect.New(srcElem.Type()).Elem()
                // 
                deepCopyValue(srcElem, dstElem)
                // 
                v2.Set(dstElem)</span>

        // 
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="29">
                if v2.CanSet() </span><span class="cov7" title="24">{
                        v2.SetInt(v1.Int())
                }</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov4" title="5">
                if v2.CanSet() </span><span class="cov0" title="0">{
                        v2.SetUint(v1.Uint())
                }</span>
        case reflect.Float32, reflect.Float64:<span class="cov2" title="2">
                if v2.CanSet() </span><span class="cov0" title="0">{
                        v2.SetFloat(v1.Float())
                }</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov2" title="2">
                if v2.CanSet() </span><span class="cov0" title="0">{
                        v2.SetComplex(v1.Complex())
                }</span>
        case reflect.String:<span class="cov3" title="3">
                if v2.CanSet() </span><span class="cov2" title="2">{
                        v2.SetString(v1.String())
                }</span>
        case reflect.Bool:<span class="cov2" title="2">
                if v2.CanSet() </span><span class="cov1" title="1">{
                        v2.SetBool(v1.Bool())
                }</span>

        case reflect.Invalid:<span class="cov0" title="0"></span>
                // 

        default:<span class="cov1" title="1">
                //  panic
                log.Panicf(": %s", v1.Kind())</span>
        }
}

// DeepCopy  `src`  `dst`
//
// 
//  MapsSlicesPointersStructs 
//
// ****:
//  `dst` **** `new`  `&amp;`
//  `dst`  nil  `panic`
//
// 
//
//        var src = map[string]int{"a": 1}
//        var dst map[string]int
//        DeepCopy(src, &amp;dst) // 
//
// @param src 
// @param dst 
func DeepCopy[M any](src, dst M) <span class="cov7" title="20">{
        v1 := reflect.ValueOf(src)
        v2 := reflect.ValueOf(dst)
        deepCopyValue(v1, v2)
}</pre>
		
		<pre class="file" id="file15" style="display: none">package candy

import "reflect"

// deepValueEqual  DeepEqual 
//  reflect.Value
//
//  unexported
func deepValueEqual(v1, v2 reflect.Value) bool <span class="cov10" title="11181">{
        // 
        if !v1.IsValid() || !v2.IsValid() </span><span class="cov2" title="6">{
                return v1.IsValid() == v2.IsValid()
        }</span>

        // 
        <span class="cov9" title="11175">if v1.Type() != v2.Type() </span><span class="cov2" title="3">{
                return false
        }</span>

        // 
        <span class="cov9" title="11172">switch v1.Kind() </span>{
        //  Map
        case reflect.Map:<span class="cov4" title="32">
                //  nil
                if v1.IsNil() || v2.IsNil() </span><span class="cov1" title="2">{
                        return v1.IsNil() == v2.IsNil()
                }</span>
                // 
                <span class="cov4" title="30">if v1.Len() != v2.Len() </span><span class="cov2" title="5">{
                        return false
                }</span>
                // 
                <span class="cov4" title="25">if v1.UnsafePointer() == v2.UnsafePointer() </span><span class="cov1" title="1">{
                        return true
                }</span>
                // 
                <span class="cov4" title="24">for _, k := range v1.MapKeys() </span><span class="cov7" title="1030">{
                        val1 := v1.MapIndex(k)
                        val2 := v2.MapIndex(k)
                        if !val1.IsValid() || !val2.IsValid() || !deepValueEqual(val1, val2) </span><span class="cov3" title="10">{
                                return false
                        }</span>
                }
                <span class="cov3" title="14">return true</span>

        //  Slice
        case reflect.Slice:<span class="cov3" title="21">
                //  nil 
                if v1.IsNil() != v2.IsNil() </span><span class="cov1" title="1">{
                        return false
                }</span>
                // 
                <span class="cov3" title="20">if v1.Len() != v2.Len() </span><span class="cov1" title="1">{
                        return false
                }</span>
                // 
                <span class="cov3" title="19">if v1.UnsafePointer() == v2.UnsafePointer() </span><span class="cov2" title="3">{
                        return true
                }</span>
                // 
                <span class="cov3" title="16">for i := 0; i &lt; v1.Len(); i++ </span><span class="cov9" title="10029">{
                        if !deepValueEqual(v1.Index(i), v2.Index(i)) </span><span class="cov2" title="6">{
                                return false
                        }</span>
                }
                <span class="cov3" title="10">return true</span>

        // 
        case reflect.Ptr:<span class="cov2" title="7">
                //  nil
                if v1.IsNil() || v2.IsNil() </span><span class="cov1" title="2">{
                        return v1.IsNil() == v2.IsNil()
                }</span>
                // 
                <span class="cov2" title="5">return deepValueEqual(v1.Elem(), v2.Elem())</span>

        // 
        case reflect.Array:<span class="cov3" title="8">
                // 
                //  reflect.Value  UnsafePointer
                for i := 0; i &lt; v1.Len(); i++ </span><span class="cov3" title="18">{
                        if !deepValueEqual(v1.Index(i), v2.Index(i)) </span><span class="cov2" title="3">{
                                return false
                        }</span>
                }
                <span class="cov2" title="5">return true</span>

        // 
        case reflect.Struct:<span class="cov3" title="9">
                // 
                for i := 0; i &lt; v1.NumField(); i++ </span><span class="cov3" title="10">{
                        if !deepValueEqual(v1.Field(i), v2.Field(i)) </span><span class="cov2" title="4">{
                                return false
                        }</span>
                }
                <span class="cov2" title="5">return true</span>

        // 
        case reflect.Interface:<span class="cov3" title="14">
                //  nil
                if v1.IsNil() || v2.IsNil() </span><span class="cov0" title="0">{
                        return v1.IsNil() == v2.IsNil()
                }</span>
                // 
                <span class="cov3" title="14">return deepValueEqual(v1.Elem(), v2.Elem())</span>

        // 
        default:<span class="cov9" title="11081">
                // panic
                var result bool
                var panicked bool
                
                func() </span><span class="cov9" title="11081">{
                        defer func() </span><span class="cov9" title="11081">{
                                if recover() != nil </span><span class="cov2" title="7">{
                                        panicked = true
                                }</span>
                        }()
                        
                        // panic
                        <span class="cov9" title="11081">result = v1.Interface() == v2.Interface()</span>
                }()
                
                // panicfalse
                <span class="cov9" title="11081">if panicked </span><span class="cov2" title="7">{
                        return false
                }</span>
                
                <span class="cov9" title="11074">return result</span>
        }
}

// DeepEqual  x  y 
//
//  `==` `DeepEqual` 
//  MapsSlicesPointersStructs 
//
// 
//  nil 
//
// 
//   - `DeepEqual(map[string]int{"a": 1}, map[string]int{"a": 1})`  `true`
//   - `DeepEqual([]int{1, 2}, []int{1, 2})`  `true`
//   - `DeepEqual(1, 1)`  `true`
//   - `DeepEqual(1, 2)`  `false`
//
// @param x 
// @param y 
// @return  true false
func DeepEqual[M any](x, y M) bool <span class="cov5" title="78">{
        v1 := reflect.ValueOf(x)
        v2 := reflect.ValueOf(y)
        return deepValueEqual(v1, v2)
}</pre>
		
		<pre class="file" id="file16" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Package candy 
// /

// Diff 
//
// :
//   - ss: 
//   - against: 
//
// :
//   - added:  against  ss 
//   - removed:  ss  against 
//
// :
//
//        ss := []int{1, 2, 3}
//        against := []int{2, 3, 4}
//        added, removed := Diff(ss, against)
//        // added = [4]
//        // removed = [1]
func Diff[T constraints.Ordered](ss []T, against []T) (added, removed []T) <span class="cov10" title="8">{
        removed = Remove(ss, against)
        added = Remove(against, ss)

        return
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package candy

import (
        "reflect"
)

// DiffSlice 
// 
func DiffSlice(a interface{}, b interface{}) (interface{}, interface{}) <span class="cov4" title="17">{
        at := reflect.TypeOf(a)
        if at.Kind() != reflect.Slice </span><span class="cov1" title="1">{
                panic("a is not slice")</span>
        }

        <span class="cov4" title="16">bt := reflect.TypeOf(b)
        if bt.Kind() != reflect.Slice </span><span class="cov1" title="1">{
                panic("b is not slice")</span>
        }

        <span class="cov4" title="15">atm := at.Elem()
        btm := bt.Elem()

        if atm.Kind() != btm.Kind() </span><span class="cov1" title="1">{
                panic("a and b are not same type")</span>
        }

        <span class="cov4" title="14">m := map[interface{}]reflect.Value{}

        bv := reflect.ValueOf(b)
        for i := 0; i &lt; bv.Len(); i++ </span><span class="cov9" title="1027">{
                m[bv.Index(i).Interface()] = bv.Index(i)
        }</span>

        <span class="cov4" title="14">c := reflect.MakeSlice(at, 0, 0)
        d := reflect.MakeSlice(bt, 0, 0)
        av := reflect.ValueOf(a)
        for i := 0; i &lt; av.Len(); i++ </span><span class="cov10" title="1028">{
                if !m[av.Index(i).Interface()].IsValid() </span><span class="cov9" title="517">{
                        c = reflect.Append(c, av.Index(i))
                }</span> else<span class="cov9" title="511"> {
                        delete(m, av.Index(i).Interface())
                }</span>
        }

        <span class="cov4" title="14">for _, value := range m </span><span class="cov9" title="514">{
                d = reflect.Append(d, value)
        }</span>

        <span class="cov4" title="14">return c.Interface(), d.Interface()</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">// Package candy  Go 
package candy

// Drop  n 
//
// :
//   - ss: 
//   - n: 
//
// :
//   - []T:  n 
//
// :
//   - 
//   -  n  0 
//   -  n 
//   - 
//
// :
//
//        result := Drop([]int{1, 2, 3, 4, 5}, 2)      //  [3, 4, 5]
//        result := Drop([]string{"a", "b", "c"}, 0)  //  ["a", "b", "c"]
//        result := Drop([]int{1, 2, 3}, 5)      //  []
//        result := Drop([]int{1, 2, 3}, -1)     //  [1, 2, 3]
func Drop[T any](ss []T, n int) []T <span class="cov10" title="12">{
        if n &lt; 0 </span><span class="cov1" title="1">{
                n = 0
        }</span>

        <span class="cov10" title="12">if n &gt; len(ss) </span><span class="cov4" title="3">{
                n = len(ss)
        }</span>

        <span class="cov10" title="12">return ss[n:]</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package candy 
package candy

import (
        "reflect"
)

// Each 
//
// :
//   - collection: 
//   - fn: 
//
// :
//
//        // 
//        Each([]int{1, 2, 3}, func(index int, value int) {
//            fmt.Printf(" %d:  %d\n", index, value)
//        })
//
//        // 
//        Each(map[string]int{"a": 1, "b": 2}, func(index int, value int) {
//            fmt.Printf(" %d:  %d\n", index, value)
//        })
//
// :
//   -  collection  panic
//   - index  0 
//   -  for 
func Each(collection interface{}, fn func(index int, value interface{})) <span class="cov8" title="18">{
        val := reflect.ValueOf(collection)

        switch val.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov7" title="13">
                for i := 0; i &lt; val.Len(); i++ </span><span class="cov10" title="34">{
                        fn(i, val.Index(i).Interface())
                }</span>
        case reflect.Map:<span class="cov2" title="2">
                keys := val.MapKeys()
                for i, key := range keys </span><span class="cov3" title="3">{
                        fn(i, val.MapIndex(key).Interface())
                }</span>
        default:<span class="cov3" title="3">
                panic("Each: collection must be a slice, array, or map")</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package candy

// EachReverse 
// 
//  f 
//
// :
//   - ss: 
//   - f:  T 
//
// :
//   - T: 
//
// :
//
//        numbers := []int{1, 2, 3, 4, 5}
//        EachReverse(numbers, func(n int) {
//            fmt.Println(n) // : 5, 4, 3, 2, 1
//        })
func EachReverse[T any](ss []T, f func(T)) <span class="cov3" title="17">{
        for i := len(ss) - 1; i &gt;= 0; i-- </span><span class="cov10" title="10048">{
                f(ss[i])
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package candy 
package candy

// EachStopWithError 
//
// 
//   - ss: 
//   - f: 
//
// 
//   - error:  nil
//
// 
//
//        numbers := []int{1, 2, 3, 4, 5}
//        err := EachStopWithError(numbers, func(n int) error {
//            if n == 3 {
//                return fmt.Errorf(" 3 ")
//            }
//            fmt.Println(n)
//            return nil
//        })
func EachStopWithError[T any](ss []T, f func(T) (err error)) (err error) <span class="cov7" title="12">{
        for _, s := range ss </span><span class="cov10" title="25">{
                err = f(s)
                if err != nil </span><span class="cov6" title="7">{
                        return err
                }</span>
        }
        <span class="cov5" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package candy  Go 
package candy

// Filter 
//
// 
//   - ss: 
//   - f: true 
//
// 
//   - []T: 
//
// 
//
//        numbers := []int{1, 2, 3, 4, 5}
//        evenNumbers := Filter(numbers, func(n int) bool {
//            return n%2 == 0
//        })
//        // evenNumbers = [2, 4]
//
// 
//   -  make  nil
//   - 
//   -  O(n) n 
func Filter[T any](ss []T, f func(T) bool) []T <span class="cov3" title="30">{
        if len(ss) == 0 </span><span class="cov2" title="4">{
                return []T{}
        }</span>
        
        // 1/4
        <span class="cov3" title="26">ret := make([]T, 0, len(ss)/4+1)
        for _, s := range ss </span><span class="cov10" title="60086">{
                if f(s) </span><span class="cov9" title="30044">{
                        ret = append(ret, s)
                }</span>
        }

        <span class="cov3" title="26">return ret</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package candy  Go 
package candy

// FilterNot 
//
// :
//   - ss: 
//   - f: 
//
// :
//   - []T: 
//
// :
//   - 
//   -  Filter 
//   - 
//   - 
//
// :
//
//        // 
//        numbers := []int{1, 2, 3, 4, 5, 6}
//        result := FilterNot(numbers, func(n int) bool {
//            return n % 2 == 0
//        })
//        // result = [1, 3, 5]
//
//        // 
//        strings := []string{"hello", "", "world", ""}
//        result := FilterNot(strings, func(s string) bool {
//            return s == ""
//        })
//        // result = ["hello", "world"]
//
//        // 
//        nums := []int{-1, 0, 1, -2, 2}
//        result := FilterNot(nums, func(n int) bool {
//            return n &lt; 0
//        })
//        // result = [0, 1, 2]
func FilterNot[T any](ss []T, f func(T) bool) []T <span class="cov6" title="6">{
        //  make  nil
        us := make([]T, 0)
        for _, s := range ss </span><span class="cov10" title="23">{
                if !f(s) </span><span class="cov8" title="12">{
                        us = append(us, s)
                }</span>
        }
        <span class="cov6" title="6">return us</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package candy 
package candy

// First 
// 
//
//  T 
//
// 
//
//        nums := []int{1, 2, 3}
//        first := First(nums) //  1
//
//        empty := []string{}
//        first := First(empty) //  "" (string )
func First[T any](ss []T) (ret T) <span class="cov10" title="7">{
        if len(ss) == 0 </span><span class="cov6" title="3">{
                return
        }</span>

        <span class="cov7" title="4">return ss[0]</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package candy 
package candy

// FirstOr 
//
// 
//  panic
//
// :
//   - ss: 
//   - or: 
//
// :
//   - 
//
// :
//
//        numbers := []int{1, 2, 3}
//        first := FirstOr(numbers, 0)     //  1
//
//        empty := []int{}
//        defaultVal := FirstOr(empty, 0) //  0
func FirstOr[T any](ss []T, or T) (ret T) <span class="cov10" title="8">{
        if len(ss) == 0 </span><span class="cov7" title="4">{
                return or
        }</span>

        <span class="cov7" title="4">return ss[0]</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Index  sub  ss 
//  -1
// 
func Index[T constraints.Ordered](ss []T, sub T) int <span class="cov7" title="11">{
        if len(ss) == 0 </span><span class="cov1" title="1">{
                return -1
        }</span>

        <span class="cov7" title="10">for i, s := range ss </span><span class="cov10" title="25">{
                if s == sub </span><span class="cov6" title="7">{
                        return i
                }</span>
        }

        <span class="cov4" title="3">return -1</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package candy

import (
        "strings"

        "golang.org/x/exp/constraints"
)

// Join 
//  constraints.Ordered 
// 
//
// :
//   - ss:  []T T  constraints.Ordered 
//   - glue:  ","
//
// :
//   - string: 
//
// :
//
//        numbers := []int{1, 2, 3, 4, 5}
//        result := Join(numbers, "-")
//        // result  "1-2-3-4-5"
//
//        words := []string{"Hello", "World", "Go"}
//        result := Join(words, " ")
//        // result  "Hello World Go"
func Join[T constraints.Ordered](ss []T, glue ...string) string <span class="cov8" title="12">{
        // 
        seq := ","
        if len(glue) &gt; 0 </span><span class="cov7" title="9">{
                seq = glue[0]
        }</span>

        //  Map  strings.Join 
        <span class="cov8" title="12">return strings.Join(Map(ss, func(s T) string </span><span class="cov10" title="20">{
                return String(s)
        }</span>), seq)
}</pre>
		
		<pre class="file" id="file28" style="display: none">// Package candy 
package candy

// Last 
// 
// 
//
// :
//   - ss: 
//
// :
//   - T: 
//
// :
//
//        numbers := []int{1, 2, 3, 4, 5}
//        last := Last(numbers) //  5
//
//        empty := []string{}
//        result := Last(empty) //  ""
func Last[T any](ss []T) (ret T) <span class="cov10" title="7">{
        if len(ss) == 0 </span><span class="cov6" title="3">{
                return
        }</span>

        <span class="cov7" title="4">return ss[len(ss)-1]</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package candy 
package candy

// LastOr 
// 
// 
//
// :
//   - ss: 
//   - or: 
//
// :
//   - T: 
//
// :
//
//        numbers := []int{1, 2, 3, 4, 5}
//        last := LastOr(numbers, 0) //  5
//
//        empty := []string{}
//        result := LastOr(empty, "default") //  "default"
func LastOr[T any](ss []T, or T) (ret T) <span class="cov10" title="8">{
        if len(ss) == 0 </span><span class="cov7" title="4">{
                return or
        }</span>

        <span class="cov7" title="4">return ss[len(ss)-1]</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package candy

// Map 
// 
//
// :
//   - ss:  []T
//   - f:  T  U 
//
// :
//   - []U: 
//
// :
//
//        numbers := []int{1, 2, 3, 4, 5}
//        doubled := Map(numbers, func(n int) int {
//            return n * 2
//        })
//        // doubled  []int{2, 4, 6, 8, 10}
func Map[T, U any](ss []T, f func(T) U) []U <span class="cov8" title="12">{
        if len(ss) == 0 </span><span class="cov5" title="4">{
                return []U{}
        }</span>
        
        //  append 
        <span class="cov7" title="8">ret := make([]U, len(ss))
        for i, s := range ss </span><span class="cov10" title="20">{
                ret[i] = f(s)
        }</span>

        <span class="cov7" title="8">return ret</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package candy  Go 
package candy

import "golang.org/x/exp/constraints"

// Max 
//
// :
//   - ss: 
//
// :
//   - T: 
//
// :
//   - 
//   - 
//   -  O(n)
//   - 
//
// :
//
//        // 
//        numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}
//        result := Max(numbers)
//        // result = 9
//
//        // 
//        strings := []string{"apple", "banana", "cherry", "date"}
//        result := Max(strings)
//        // result = "date"
//
//        // 
//        floats := []float64{3.14, 1.618, 2.718, 1.414}
//        result := Max(floats)
//        // result = 3.14
//
//        // 
//        empty := []int{}
//        result := Max(empty)
//        // result = 0 (int)
func Max[T constraints.Ordered](ss []T) (max T) <span class="cov8" title="28">{
        if len(ss) == 0 </span><span class="cov4" title="6">{
                return
        }</span>
        <span class="cov7" title="22">max = ss[0]
        for _, s := range ss </span><span class="cov10" title="58">{
                if s &gt; max </span><span class="cov6" title="14">{
                        max = s
                }</span>
        }
        <span class="cov7" title="22">return</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package candy  Go 
package candy

import "golang.org/x/exp/constraints"

// Min 
//
// :
//   - ss: 
//
// :
//   - T: 
//
// :
//   - 
//   - 
//   -  O(n)
//   - 
//
// :
//
//        // 
//        numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}
//        result := Min(numbers)
//        // result = 1
//
//        // 
//        strings := []string{"apple", "banana", "cherry", "date"}
//        result := Min(strings)
//        // result = "apple"
//
//        // 
//        floats := []float64{3.14, 1.618, 2.718, 1.414}
//        result := Min(floats)
//        // result = 1.414
//
//        // 
//        empty := []int{}
//        result := Min(empty)
//        // result = 0 (int)
func Min[T constraints.Ordered](ss []T) (min T) <span class="cov8" title="57">{
        if len(ss) == 0 </span><span class="cov4" title="6">{
                return
        }</span>
        <span class="cov7" title="51">min = ss[0]
        for _, s := range ss </span><span class="cov10" title="174">{
                if s &lt; min </span><span class="cov6" title="18">{
                        min = s
                }</span>
        }
        <span class="cov7" title="51">return</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package candy

import (
        "fmt"
        "reflect"
)

func pluck(list interface{}, fieldName string, deferVal interface{}) interface{} <span class="cov10" title="39">{
        v := reflect.ValueOf(list)
        switch v.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov9" title="33">
                if v.Len() == 0 </span><span class="cov6" title="10">{
                        return deferVal
                }</span>

                <span class="cov8" title="23">ev := v.Type().Elem()
                evs := ev
                for evs.Kind() == reflect.Ptr </span><span class="cov7" title="13">{
                        evs = evs.Elem()
                }</span>

                <span class="cov8" title="23">switch evs.Kind() </span>{
                case reflect.Struct:<span class="cov7" title="17">
                        field, ok := evs.FieldByName(fieldName)
                        if !ok </span><span class="cov4" title="4">{
                                panic(fmt.Sprintf("field %s not found", fieldName))</span>
                        }

                        <span class="cov7" title="13">result := reflect.MakeSlice(reflect.SliceOf(field.Type), v.Len(), v.Len())

                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov9" title="26">{
                                ev := v.Index(i)
                                for ev.Kind() == reflect.Ptr </span><span class="cov7" title="16">{
                                        ev = ev.Elem()
                                }</span>
                                <span class="cov9" title="26">if ev.Kind() != reflect.Struct </span><span class="cov1" title="1">{
                                        panic("element is not a struct")</span>
                                }
                                <span class="cov8" title="25">if !ev.IsValid() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="25">result.Index(i).Set(ev.FieldByIndex(field.Index))</span>
                        }

                        <span class="cov7" title="12">return result.Interface()</span>
                case reflect.Slice, reflect.Array:<span class="cov2" title="2">
                        var ev reflect.Value
                        var c int
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov3" title="3">{
                                ev = v.Index(i)
                                for i := 0; i &lt; ev.Len(); i++ </span><span class="cov4" title="4">{
                                        c += ev.Index(i).Len()
                                }</span>
                        }

                        <span class="cov2" title="2">result := reflect.MakeSlice(ev.Type(), c, c)
                        var idx int
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov3" title="3">{
                                ev := v.Index(i)
                                for i := 0; i &lt; ev.Len(); i++ </span><span class="cov4" title="4">{
                                        result.Index(idx).Set(ev.Index(i))
                                        idx++
                                }</span>
                        }

                        <span class="cov2" title="2">return result.Interface()</span>
                default:<span class="cov4" title="4">
                        panic("list element type is not supported")</span>
                }

        default:<span class="cov5" title="6">
                panic("list must be an array or slice")</span>
        }
}

// PluckInt  int 
func PluckInt(list interface{}, fieldName string) []int <span class="cov6" title="11">{
        return pluck(list, fieldName, []int{}).([]int)
}</pre>
		
		<pre class="file" id="file34" style="display: none">package candy

// PluckInt32  int32 
func PluckInt32(list interface{}, fieldName string) []int32 <span class="cov10" title="6">{
        return pluck(list, fieldName, []int32{}).([]int32)
}</pre>
		
		<pre class="file" id="file35" style="display: none">package candy

// PluckInt64  int64 
func PluckInt64(list interface{}, fieldName string) []int64 <span class="cov10" title="4">{
        return pluck(list, fieldName, []int64{}).([]int64)
}</pre>
		
		<pre class="file" id="file36" style="display: none">package candy

// PluckString  string 
func PluckString(list interface{}, fieldName string) []string <span class="cov10" title="3">{
        return pluck(list, fieldName, []string{}).([]string)
}</pre>
		
		<pre class="file" id="file37" style="display: none">package candy

// PluckStringSlice  []string 
func PluckStringSlice(list interface{}, fieldName string) [][]string <span class="cov10" title="3">{
        return pluck(list, fieldName, [][]string{}).([][]string)
}</pre>
		
		<pre class="file" id="file38" style="display: none">package candy

// PluckUint32  uint32 
func PluckUint32(list interface{}, fileName string) []uint32 <span class="cov10" title="4">{
        return pluck(list, fileName, []uint32{}).([]uint32)
}</pre>
		
		<pre class="file" id="file39" style="display: none">package candy

// PluckUint64  uint64 
func PluckUint64(list interface{}, fieldName string) []uint64 <span class="cov10" title="4">{
        return pluck(list, fieldName, []uint64{}).([]uint64)
}</pre>
		
		<pre class="file" id="file40" style="display: none">// Package candy  Go 
package candy

import (
        "math"

        "golang.org/x/exp/constraints"
)

// Pow  x  y 
//
// :
//   - x: 
//   - y: 
//
// :
//   - T: x  y 
//
// :
//   - 
//   -  math.Pow 
//   - 
//   - 
//
// :
//
//        // 
//        result := Pow(2, 3)
//        // result = 8
//
//        // 
//        result := Pow(2.5, 2.0)
//        // result = 6.25
//
//        // 
//        result := Pow(2.0, -2.0)
//        // result = 0.25
//
//        // 
//        result := Pow(4.0, 0.5)
//        // result = 2.0 ()
//
//        // 
//        result := Pow(10, 6)
//        // result = 1000000
func Pow[T constraints.Integer | constraints.Float](x, y T) T <span class="cov10" title="16">{
        return T(math.Pow(float64(x), float64(y)))
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package candy  Go 
package candy

import (
        "math/rand"
)

// Random 
//
// 
//   - T: 
//
// 
//   - ss: 
//
// 
//   - ret: 
//
// 
//   - 
//   - 
//   -  math/rand 
//
// 
//
//        numbers := []int{1, 2, 3, 4, 5}
//        randomNum := Random(numbers)
//        // randomNum  1, 2, 3, 4, 5 
//
//        strings := []string{"apple", "banana", "cherry"}
//        randomStr := Random(strings)
//        // randomStr  "apple", "banana", "cherry" 
func Random[T any](ss []T) (ret T) <span class="cov10" title="2061">{
        if len(ss) == 0 </span><span class="cov2" title="5">{
                return
        }</span>

        <span class="cov9" title="2056">return ss[rand.Intn(len(ss))]</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package candy  Go 
package candy

// Reduce 
//
// 
//   - T: 
//
// 
//   - ss: 
//   - f: 
//
// 
//   - 
//
// 
//   - 
//   - 
//   - 
//
// 
//
//        // 
//        sum := Reduce([]int{1, 2, 3, 4, 5}, func(a, b int) int { return a + b })
//        // sum  15
//
//        // 
//        product := Reduce([]int{1, 2, 3, 4}, func(a, b int) int { return a * b })
//        // product  24
//
//        // 
//        max := Reduce([]int{3, 1, 4, 1, 5}, func(a, b int) int {
//            if b &gt; a { return b }
//            return a
//        })
//        // max  5
func Reduce[T any](ss []T, f func(T, T) T) T <span class="cov3" title="15">{
        if len(ss) == 0 </span><span class="cov1" title="2">{
                return *new(T)
        }</span>

        <span class="cov3" title="13">result := ss[0]
        for _, s := range ss[1:] </span><span class="cov10" title="10040">{
                result = f(result, s)
        }</span>
        <span class="cov3" title="12">return result</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Remove  ss  against 
//  against  ss 
func Remove[T constraints.Ordered](ss []T, against []T) (result []T) <span class="cov8" title="24">{
        //  make  nil
        result = make([]T, 0)
        set := make(map[T]struct{}, len(ss))

        for _, s := range ss </span><span class="cov9" title="55">{
                set[s] = struct{}{}
        }</span>

        <span class="cov8" title="24">for _, s := range against </span><span class="cov10" title="57">{
                if _, ok := set[s]; !ok </span><span class="cov8" title="29">{
                        result = append(result, s)
                }</span>
        }
        <span class="cov8" title="24">return</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package candy

// RemoveIndex 
// 
// 
func RemoveIndex[T any](ss []T, index int) []T <span class="cov10" title="12">{
        // 
        if len(ss) == 0 || index &lt; 0 || index &gt;= len(ss) </span><span class="cov6" title="5">{
                return make([]T, 0)
        }</span>

        // 
        <span class="cov8" title="7">if index == 0 </span><span class="cov4" title="3">{
                return ss[1:]
        }</span>

        // 
        <span class="cov6" title="4">if index == len(ss)-1 </span><span class="cov3" title="2">{
                return ss[:len(ss)-1]
        }</span>

        //  append 
        <span class="cov3" title="2">return append(ss[:index], ss[index+1:]...)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package candy

import (
        "reflect"
)

// RemoveSlice 
// src rm 
// 
func RemoveSlice(src interface{}, rm interface{}) interface{} <span class="cov5" title="13">{
        at := reflect.TypeOf(src)
        if at.Kind() != reflect.Slice </span><span class="cov1" title="1">{
                panic("a is not slice")</span>
        }

        <span class="cov5" title="12">bt := reflect.TypeOf(rm)
        if bt.Kind() != reflect.Slice </span><span class="cov1" title="1">{
                panic("b is not slice")</span>
        }

        <span class="cov5" title="11">atm := at.Elem()
        btm := bt.Elem()

        if atm.Kind() != btm.Kind() </span><span class="cov1" title="1">{
                panic("a and b are not same type")</span>
        }

        <span class="cov5" title="10">m := map[interface{}]bool{}

        bv := reflect.ValueOf(rm)
        for i := 0; i &lt; bv.Len(); i++ </span><span class="cov6" title="22">{
                m[bv.Index(i).Interface()] = true
        }</span>

        <span class="cov5" title="10">c := reflect.MakeSlice(at, 0, 0)
        av := reflect.ValueOf(src)
        for i := 0; i &lt; av.Len(); i++ </span><span class="cov10" title="133">{
                if !m[av.Index(i).Interface()] </span><span class="cov9" title="116">{
                        c = reflect.Append(c, av.Index(i))
                        delete(m, av.Index(i).Interface())
                }</span>
        }

        <span class="cov5" title="10">return c.Interface()</span>
}</pre>
		
		<pre class="file" id="file46" style="display: none">// Package reverse 
package candy

// Reverse 
// 
//  make 
func Reverse[T any](ss []T) (ret []T) <span class="cov7" title="8">{
        //  make  nil
        ret = make([]T, 0, len(ss))
        for i := len(ss) - 1; i &gt;= 0; i-- </span><span class="cov10" title="22">{
                ret = append(ret, ss[i])
        }</span>

        <span class="cov7" title="8">return</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package candy

import (
        "golang.org/x/exp/constraints"
)

// Same  against  ss 
// 
func Same[T constraints.Ordered](against []T, ss []T) (result []T) <span class="cov7" title="11">{
        //  make  nil
        result = make([]T, 0)
        set := make(map[T]struct{}, len(ss))

        for _, s := range ss </span><span class="cov10" title="25">{
                set[s] = struct{}{}
        }</span>

        <span class="cov7" title="11">for _, s := range against </span><span class="cov10" title="25">{
                if _, ok := set[s]; ok </span><span class="cov8" title="13">{
                        result = append(result, s)
                }</span>
        }
        <span class="cov7" title="11">return</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package candy  Go 
package candy

import "github.com/lazygophers/utils/randx"

// Shuffle 
//
// 
//   - T: 
//
// 
//   - ss: 
//
// 
//   - []T: 
//
// 
//   -  Fisher-Yates 
//   - 
//   - 
//   - 
//   -  randx 
//
// 
//
//        // 
//        data := []int{1, 2, 3, 4, 5}
//        result := Shuffle(data)
//        // result  data 
//
//        // 
//        names := []string{"Alice", "Bob", "Charlie", "David"}
//        shuffled := Shuffle(names)
//        // shuffled 
func Shuffle[T any](ss []T) []T <span class="cov5" title="32">{
        if len(ss) &lt;= 1 </span><span class="cov3" title="9">{
                return ss
        }</span>
        
        <span class="cov5" title="23">for i := len(ss) - 1; i &gt; 0; i-- </span><span class="cov10" title="1133">{
                j := randx.FastIntn(i + 1)
                ss[i], ss[j] = ss[j], ss[i]
        }</span>

        <span class="cov5" title="23">return ss</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package candy

// SliceEqual 
//  map 
//  nil nil 
func SliceEqual[T any](a, b []T) bool <span class="cov5" title="59">{
        //  nil nil 
        if a == nil &amp;&amp; b == nil </span><span class="cov1" title="2">{
                return true
        }</span>
        <span class="cov5" title="57">if a == nil || b == nil </span><span class="cov2" title="5">{
                return false
        }</span>

        <span class="cov5" title="52">if len(a) != len(b) </span><span class="cov3" title="9">{
                return false
        }</span>

        //  map 
        <span class="cov5" title="43">am := make(map[any]int, len(a))
        for _, v := range a </span><span class="cov10" title="2133">{
                am[v]++
        }</span>

        <span class="cov5" title="43">for _, v := range b </span><span class="cov9" title="2125">{
                if count, ok := am[v]; !ok || count == 0 </span><span class="cov4" title="15">{
                        return false
                }</span>
                <span class="cov9" title="2110">am[v]--</span>
        }

        // 0
        <span class="cov4" title="28">for _, count := range am </span><span class="cov9" title="1064">{
                if count != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov4" title="28">return true</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package candy

import (
        "sort"

        "golang.org/x/exp/constraints"
)

// Sort 
//  constraints.Ordered 
// 
func Sort[T constraints.Ordered](ss []T) []T <span class="cov4" title="21">{
        // 2
        if len(ss) &lt; 2 </span><span class="cov2" title="3">{
                return ss
        }</span>

        // 
        <span class="cov4" title="18">sorted := make([]T, len(ss))
        copy(sorted, ss)

        //  sort.Slice 
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov10" title="1139">{
                return sorted[i] &lt; sorted[j]
        }</span>)

        <span class="cov4" title="18">return sorted</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Package candy  Go 
package candy

import (
        "sort"
)

// SortUsing 
//
// T 
// 
//   - slice: 
//   - less:  true a  b 
//
// 
//   - []T: 
//
// 
//
//        // 
//        numbers := []int{1, 2, 3, 4, 5}
//        sorted := SortUsing(numbers, func(a, b int) bool {
//            return a &gt; b
//        }) //  []int{5, 4, 3, 2, 1}
//
//        // 
//        words := []string{"apple", "banana", "cherry", "date"}
//        sorted := SortUsing(words, func(a, b string) bool {
//            return len(a) &lt; len(b)
//        }) //  []string{"date", "apple", "banana", "cherry"}
func SortUsing[T any](slice []T, less func(T, T) bool) []T <span class="cov6" title="22">{
        // 2
        if len(slice) &lt; 2 </span><span class="cov2" title="3">{
                return slice
        }</span>

        // 
        <span class="cov6" title="19">sorted := make([]T, len(slice))
        copy(sorted, slice)

        //  sort.Slice 
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov10" title="169">{
                return less(sorted[i], sorted[j])
        }</span>)

        <span class="cov6" title="19">return sorted</span>
}</pre>
		
		<pre class="file" id="file52" style="display: none">package candy

import "golang.org/x/exp/constraints"

// Spare  against  ss 
//  against  ss 
//  Remove 
//
// 
//   - ss: 
//   - against: 
//
// 
//   - []T:  against  ss 
//
// 
//
//        ss := []int{1, 2, 3}
//        against := []int{2, 3, 4, 5}
//        result := Spare(ss, against) //  [4, 5]
func Spare[T constraints.Ordered](ss []T, against []T) (result []T) <span class="cov7" title="11">{
        //  make  nil
        result = make([]T, 0)
        set := make(map[T]struct{}, len(ss))

        //  ss  map 
        for _, s := range ss </span><span class="cov9" title="25">{
                set[s] = struct{}{}
        }</span>

        //  against  ss 
        <span class="cov7" title="11">for _, s := range against </span><span class="cov10" title="27">{
                if _, ok := set[s]; !ok </span><span class="cov8" title="16">{
                        result = append(result, s)
                }</span>
        }
        <span class="cov7" title="11">return</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Package candy  Go 
package candy

import (
        "math"

        "golang.org/x/exp/constraints"
)

// Sqrt 
//
// 
//   - T: 
//
// 
//   - s: 
//
// 
//   - T: 
//
// 
//   - 
//   -  math.Sqrt 
//   - math.Sqrt  NaN
//
// 
//
//        // 
//        result := Sqrt(16.0)
//        // result  4.0
//
//        // 
//        result := Sqrt(int(16))
//        // result  4
//
//        // 
//        result := Sqrt(25.5)
//        // result  5.04975246918104
func Sqrt[T constraints.Integer | constraints.Float](s T) T <span class="cov10" title="14">{
        return T(math.Sqrt(float64(s)))
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package candy

import (
        "fmt"

        "golang.org/x/exp/constraints"
)

// String 
//  constraints.Ordered 
// 
func String[T constraints.Ordered](s T) string <span class="cov10" title="25">{
        return fmt.Sprintf("%v", s)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">// Package candy 
package candy

import "golang.org/x/exp/constraints"

// Sum 
// 
//
// 
//   - ss: 
//
// 
//   - T: 
//
// 
//
//        sum := Sum([]int{1, 2, 3})  //  6
//        sum := Sum([]float64{1.5, 2.5})  //  4.0
func Sum[T constraints.Integer | constraints.Float](ss []T) (ret T) <span class="cov7" title="12">{
        for _, s := range ss </span><span class="cov10" title="34">{
                ret += s
        }</span>

        <span class="cov7" title="12">return</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package candy

import (
        "reflect"
        "strings"
)

// ToArrayString 
// 
// 
// 
func ToArrayString(v interface{}) []string <span class="cov10" title="29">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Slice </span><span class="cov8" title="15">{
                // 
                switch x := v.(type) </span>{
                case string:<span class="cov6" title="9">
                        if strings.Contains(x, ",") </span><span class="cov4" title="4">{
                                // 
                                return strings.Split(x, ",")
                        }</span>
                        // 
                        <span class="cov5" title="5">return []string{x}</span>
                case nil:<span class="cov1" title="1">
                        return nil</span>
                default:<span class="cov5" title="5">
                        // 
                        return []string{ToString(x)}</span>
                }
        }

        //  nil 
        <span class="cov8" title="14">if vv.IsNil() </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="13">ss := make([]string, 0, vv.Len())
        for i := 0; i &lt; vv.Len(); i++ </span><span class="cov9" title="25">{
                ss = append(ss, ToString(vv.Index(i).Interface()))
        }</span>

        <span class="cov7" title="13">return ss</span>
}</pre>
		
		<pre class="file" id="file57" style="display: none">package candy

import (
        "bytes"
        "math"
        "strings"
)

// ToBool  (interface{})  (bool)
//
// :
//
//   - **bool**:
//     
//
//   - **** (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64):
//      0 false true
//
//   - **** (float32, float64):
//      0.0  NaN (Not-a-Number) false true
//
//   - ** (string)  ([]byte)**:
//     
//
//   - "true", "1", "t", "y", "yes", "on"  true
//
//   - "false", "0", "f", "n", "no", "off"  false
//
//   -  true
//
//   -  false
//
//   - **nil**:
//      false
//
//   - ****:
//      false (: struct, map, slice )
//
// :
//
//        candy.ToBool(true)    // true
//        candy.ToBool(0)       // false
//        candy.ToBool("yes")   // true
//        candy.ToBool("off")   // false
//        candy.ToBool("hello") // true
//        candy.ToBool(nil)     // false
func ToBool(val interface{}) bool <span class="cov10" title="102">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                return x</span>
        case int:<span class="cov3" title="3">
                return x != 0</span>
        case int8:<span class="cov1" title="1">
                return x != 0</span>
        case int16:<span class="cov1" title="1">
                return x != 0</span>
        case int32:<span class="cov1" title="1">
                return x != 0</span>
        case int64:<span class="cov1" title="1">
                return x != 0</span>
        case uint:<span class="cov2" title="2">
                return x != 0</span>
        case uint8:<span class="cov1" title="1">
                return x != 0</span>
        case uint16:<span class="cov1" title="1">
                return x != 0</span>
        case uint32:<span class="cov1" title="1">
                return x != 0</span>
        case uint64:<span class="cov1" title="1">
                return x != 0</span>
        case float32:<span class="cov4" title="7">
                return !math.IsNaN(float64(x)) &amp;&amp; x != 0.0</span>
        case float64:<span class="cov4" title="7">
                return !math.IsNaN(x) &amp;&amp; x != 0.0</span>
        case string:<span class="cov8" title="39">
                switch strings.ToLower(x) </span>{
                case "true", "1", "t", "y", "yes", "on":<span class="cov6" title="17">
                        return true</span>
                case "false", "0", "f", "n", "no", "off":<span class="cov6" title="17">
                        return false</span>
                default:<span class="cov4" title="5">
                        return strings.TrimSpace(x) != ""</span>
                }
        case []byte:<span class="cov7" title="30">
                switch string(bytes.ToLower(x)) </span>{
                case "true", "1", "t", "y", "yes", "on":<span class="cov5" title="12">
                        return true</span>
                case "false", "0", "f", "n", "no", "off":<span class="cov5" title="12">
                        return false</span>
                default:<span class="cov4" title="6">
                        return len(bytes.TrimSpace(x)) != 0</span>
                }
        default:<span class="cov3" title="4">
                return false</span>
        }
}</pre>
		
		<pre class="file" id="file58" style="display: none">package candy

import (
        "fmt"
        "math"
        "strconv"
        "time"
        "unsafe"

        "github.com/lazygophers/utils/json"
)

// ToBytes 
// 
// - true -&gt; []byte("1"), false -&gt; []byte("0")
// - int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64
// - float32, float64
// - time.Duration
// - 
// - 
// - nilnil
// - error
// -  JSON 
func ToBytes(val interface{}) []byte <span class="cov10" title="67">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return []byte("1")
                }</span>
                <span class="cov1" title="1">return []byte("0")</span>
        case int:<span class="cov3" title="3">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int8:<span class="cov3" title="3">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int16:<span class="cov3" title="3">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int32:<span class="cov3" title="3">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int64:<span class="cov3" title="3">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint:<span class="cov2" title="2">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint8:<span class="cov2" title="2">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint16:<span class="cov2" title="2">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint32:<span class="cov2" title="2">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint64:<span class="cov2" title="2">
                return []byte(fmt.Sprintf("%d", x))</span>
        case float32:<span class="cov5" title="10">
                if math.Floor(float64(x)) == float64(x) </span><span class="cov4" title="5">{
                        return []byte(strconv.FormatFloat(float64(x), 'f', 0, 32))
                }</span>

                <span class="cov4" title="5">return []byte(strconv.FormatFloat(float64(x), 'f', 15, 32))</span>
        case float64:<span class="cov5" title="10">
                if math.Floor(x) == x </span><span class="cov4" title="5">{
                        return []byte(fmt.Sprintf("%.0f", x))
                }</span>

                <span class="cov4" title="5">return []byte(strconv.FormatFloat(x, 'f', 6, 64))</span>
        case time.Duration:<span class="cov3" title="4">
                return []byte(x.String())</span>
        case string:<span class="cov3" title="3">
                return []byte(x)</span>
        case []byte:<span class="cov2" title="2">
                return x</span>
        case nil:<span class="cov2" title="2">
                return nil</span>
        case error:<span class="cov2" title="2">
                return []byte(x.Error())</span>

        default:<span class="cov5" title="7">
                buf, err := json.Marshal(x)
                if err != nil </span><span class="cov1" title="1">{
                        return nil
                }</span>

                <span class="cov4" title="6">return buf</span>
        }
}

func toString(b []byte) string <span class="cov5" title="9">{
        return *(*string)(unsafe.Pointer(&amp;b))
}</span>

func toBytes(s string) []byte <span class="cov4" title="5">{
        return *(*[]byte)(unsafe.Pointer(&amp;s))
}</pre>
		
		<pre class="file" id="file59" style="display: none">package candy

import (
        "strconv"
        "strings"
)

// ToFloat32  float32
//
// 
//   - bool: true  1.0, false  0.0
//   -  (int, int8, ..., uint, uint8, ...): 
//   -  (float32, float64): 
//   - string, []byte:  0.0
//
// ( struct, map ) nil 0.0
func ToFloat32(val interface{}) float32 <span class="cov10" title="47">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov3" title="3">
                return float32(x)</span>
        case int8:<span class="cov2" title="2">
                return float32(x)</span>
        case int16:<span class="cov2" title="2">
                return float32(x)</span>
        case int32:<span class="cov2" title="2">
                return float32(x)</span>
        case int64:<span class="cov2" title="2">
                return float32(x)</span>
        case uint:<span class="cov2" title="2">
                return float32(x)</span>
        case uint8:<span class="cov2" title="2">
                return float32(x)</span>
        case uint16:<span class="cov1" title="1">
                return float32(x)</span>
        case uint32:<span class="cov1" title="1">
                return float32(x)</span>
        case uint64:<span class="cov1" title="1">
                return float32(x)</span>
        case float32:<span class="cov3" title="3">
                return x</span>
        case float64:<span class="cov3" title="3">
                return float32(x)</span>
        case string:<span class="cov6" title="9">
                v := strings.TrimSpace(x)
                val, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov4" title="5">return float32(val)</span>
        case []byte:<span class="cov5" title="7">
                v := strings.TrimSpace(string(x))
                val, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov3" title="3">{
                        return 0
                }</span>
                <span class="cov4" title="4">return float32(val)</span>
        default:<span class="cov4" title="5">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file60" style="display: none">package candy

import (
        "strconv"
        "strings"
)

// ToFloat64  float64
//
// 
//   - bool: true  1.0, false  0.0
//   -  (int, int8, ..., uint, uint8, ...): 
//   -  (float32, float64): 
//   - string, []byte:  0.0
//
// ( struct, map ) nil 0.0
func ToFloat64(val interface{}) float64 <span class="cov10" title="97">{
        switch x := val.(type) </span>{
        case bool:<span class="cov4" title="6">
                if x </span><span class="cov3" title="4">{
                        return 1
                }</span>
                <span class="cov2" title="2">return 0</span>
        case int:<span class="cov4" title="7">
                return float64(x)</span>
        case int8:<span class="cov4" title="5">
                return float64(x)</span>
        case int16:<span class="cov4" title="5">
                return float64(x)</span>
        case int32:<span class="cov4" title="5">
                return float64(x)</span>
        case int64:<span class="cov4" title="5">
                return float64(x)</span>
        case uint:<span class="cov4" title="5">
                return float64(x)</span>
        case uint8:<span class="cov4" title="5">
                return float64(x)</span>
        case uint16:<span class="cov3" title="4">
                return float64(x)</span>
        case uint32:<span class="cov3" title="4">
                return float64(x)</span>
        case uint64:<span class="cov3" title="4">
                return float64(x)</span>
        case float32:<span class="cov4" title="6">
                return float64(x)</span>
        case float64:<span class="cov3" title="3">
                return x</span>
        case string:<span class="cov6" title="18">
                v := strings.TrimSpace(x)
                val, err := strconv.ParseFloat(v, 64)
                if err == nil </span><span class="cov5" title="10">{
                        return val
                }</span>

                <span class="cov5" title="8">intVal, intErr := strconv.ParseInt(v, 0, 64)
                if intErr == nil </span><span class="cov3" title="3">{
                        return float64(intVal)
                }</span>

                <span class="cov4" title="5">return 0</span>
        case []byte:<span class="cov5" title="10">
                v := strings.TrimSpace(string(x))
                val, err := strconv.ParseFloat(v, 64)
                if err == nil </span><span class="cov4" title="6">{
                        return val
                }</span>

                <span class="cov3" title="4">intVal, intErr := strconv.ParseInt(v, 0, 64)
                if intErr == nil </span><span class="cov1" title="1">{
                        return float64(intVal)
                }</span>

                <span class="cov3" title="3">return 0</span>
        default:<span class="cov4" title="5">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file61" style="display: none">package candy

// ToFloat64Slice  []float64
//
// 
//   - []bool, []int, []int8, ..., []uint64, []float32, []float64, []string, [][]byte, []interface{}
//
//  ToFloat64 
//  nil nil
//  []float64{}
func ToFloat64Slice(val interface{}) []float64 <span class="cov10" title="18">{
        if val == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov9" title="17">switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint64:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                v := make([]float64, len(x))
                for i, val := range x </span><span class="cov4" title="3">{
                        v[i] = ToFloat64(val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, val)
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case [][]byte:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov3" title="2">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="1">
                var v []float64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToFloat64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov1" title="1">
                return []float64{}</span>
        }
}</pre>
		
		<pre class="file" id="file62" style="display: none">package candy

import "strconv"

// ToInt  int
//
// 
//   - bool: true  1, false  0
//   -  (int, int8, ..., uint, uint8, ...): 
//   -  (float32, float64): 
//   - string, []byte:  0
//
// ( struct, map ) nil 0
func ToInt(val interface{}) int <span class="cov10" title="48">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov3" title="3">
                return x</span>
        case int8:<span class="cov2" title="2">
                return int(x)</span>
        case int16:<span class="cov2" title="2">
                return int(x)</span>
        case int32:<span class="cov2" title="2">
                return int(x)</span>
        case int64:<span class="cov2" title="2">
                return int(x)</span>
        case uint:<span class="cov2" title="2">
                return int(x)</span>
        case uint8:<span class="cov2" title="2">
                return int(x)</span>
        case uint16:<span class="cov1" title="1">
                return int(x)</span>
        case uint32:<span class="cov1" title="1">
                return int(x)</span>
        case uint64:<span class="cov1" title="1">
                return int(x)</span>
        case float32:<span class="cov4" title="4">
                return int(x)</span>
        case float64:<span class="cov4" title="4">
                return int(x)</span>
        case string:<span class="cov5" title="8">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov4" title="5">{
                        return 0
                }</span>
                <span class="cov3" title="3">return int(val)</span>
        case []byte:<span class="cov5" title="7">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov3" title="3">return int(val)</span>
        default:<span class="cov4" title="5">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file63" style="display: none">package candy

import "strconv"

// ToInt16  int16
//
// 
//   - bool: true  1, false  0
//   -  (int, int8, ..., uint, uint8, ...): 
//   -  (float32, float64): 
//   - string, []byte:  0
//
// ( struct, map ) nil 0
func ToInt16(val interface{}) int16 <span class="cov10" title="25">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov1" title="1">
                return int16(x)</span>
        case int8:<span class="cov1" title="1">
                return int16(x)</span>
        case int16:<span class="cov1" title="1">
                return x</span>
        case int32:<span class="cov1" title="1">
                return int16(x)</span>
        case int64:<span class="cov1" title="1">
                return int16(x)</span>
        case uint:<span class="cov1" title="1">
                return int16(x)</span>
        case uint8:<span class="cov1" title="1">
                return int16(x)</span>
        case uint16:<span class="cov1" title="1">
                return int16(x)</span>
        case uint32:<span class="cov1" title="1">
                return int16(x)</span>
        case uint64:<span class="cov1" title="1">
                return int16(x)</span>
        case float32:<span class="cov1" title="1">
                return int16(x)</span>
        case float64:<span class="cov1" title="1">
                return int16(x)</span>
        case string:<span class="cov5" title="5">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov1" title="1">return int16(val)</span>
        case []byte:<span class="cov4" title="4">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov4" title="3">{
                        return 0
                }</span>
                <span class="cov1" title="1">return int16(val)</span>
        default:<span class="cov2" title="2">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file64" style="display: none">package candy

import "strconv"

// ToInt32  int32
//
// 
//   - bool: true  1, false  0
//   -  (int, int8, ..., uint, uint8, ...): 
//   -  (float32, float64): 
//   - string, []byte:  0
//
// ( struct, map ) nil 0
func ToInt32(val interface{}) int32 <span class="cov10" title="28">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov1" title="1">
                return int32(x)</span>
        case int8:<span class="cov1" title="1">
                return int32(x)</span>
        case int16:<span class="cov1" title="1">
                return int32(x)</span>
        case int32:<span class="cov4" title="4">
                return x</span>
        case int64:<span class="cov1" title="1">
                return int32(x)</span>
        case uint:<span class="cov1" title="1">
                return int32(x)</span>
        case uint8:<span class="cov1" title="1">
                return int32(x)</span>
        case uint16:<span class="cov1" title="1">
                return int32(x)</span>
        case uint32:<span class="cov1" title="1">
                return int32(x)</span>
        case uint64:<span class="cov1" title="1">
                return int32(x)</span>
        case float32:<span class="cov1" title="1">
                return int32(x)</span>
        case float64:<span class="cov2" title="2">
                return int32(x)</span>
        case string:<span class="cov5" title="6">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov2" title="2">return int32(val)</span>
        case []byte:<span class="cov2" title="2">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov1" title="1">{
                        return 0
                }</span>
                <span class="cov1" title="1">return int32(val)</span>
        default:<span class="cov2" title="2">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file65" style="display: none">package candy

import (
        "strconv"
        "time"
)

// ToInt64  int64
//
// 
//   - bool: true  1, false  0
//   -  (int, int8, ..., uint, uint8, ...): 
//   - time.Duration: 
//   -  (float32, float64): 
//   - string, []byte:  0
//
// ( struct, map ) nil 0
func ToInt64(val interface{}) int64 <span class="cov10" title="45">{
        switch x := val.(type) </span>{
        case bool:<span class="cov5" title="6">
                if x </span><span class="cov4" title="4">{
                        return 1
                }</span>
                <span class="cov2" title="2">return 0</span>
        case int:<span class="cov2" title="2">
                return int64(x)</span>
        case int8:<span class="cov1" title="1">
                return int64(x)</span>
        case int16:<span class="cov1" title="1">
                return int64(x)</span>
        case int32:<span class="cov1" title="1">
                return int64(x)</span>
        case int64:<span class="cov4" title="5">
                return x</span>
        case uint:<span class="cov1" title="1">
                return int64(x)</span>
        case uint8:<span class="cov1" title="1">
                return int64(x)</span>
        case uint16:<span class="cov1" title="1">
                return int64(x)</span>
        case uint32:<span class="cov1" title="1">
                return int64(x)</span>
        case uint64:<span class="cov1" title="1">
                return int64(x)</span>
        case time.Duration:<span class="cov2" title="2">
                return int64(x)</span>
        case float32:<span class="cov1" title="1">
                return int64(x)</span>
        case float64:<span class="cov2" title="2">
                return int64(x)</span>
        case string:<span class="cov6" title="10">
                val, err := strconv.ParseInt(x, 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov5" title="6">return val</span>
        case []byte:<span class="cov5" title="7">
                val, err := strconv.ParseInt(string(x), 10, 64)
                if err != nil </span><span class="cov3" title="3">{
                        return 0
                }</span>
                <span class="cov4" title="4">return val</span>
        default:<span class="cov2" title="2">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file66" style="display: none">package candy

// ToInt64Slice  []int64
//
// 
//   - []bool, []int, []int8, ..., []uint64, []float32, []float64, []string, [][]byte, []interface{}
//
//  ToInt64 
//  nil nil
//  []int64{}
func ToInt64Slice(val interface{}) []int64 <span class="cov10" title="17">{
        switch x := val.(type) </span>{
        case []bool:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int8:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int16:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int32:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []int64:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint8:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint16:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint32:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []uint64:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float32:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []float64:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, int64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []string:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case [][]byte:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov3" title="2">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        case []interface{}:<span class="cov1" title="1">
                var v []int64
                for _, val := range x </span><span class="cov4" title="3">{
                        v = append(v, ToInt64(val))
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov1" title="1">
                return []int64{}</span>
        }
}</pre>
		
		<pre class="file" id="file67" style="display: none">package candy

import "strconv"

// ToInt8  int8
//
// 
//   - bool: true  1, false  0
//   -  (int, int8, ..., uint, uint8, ...): 
//   -  (float32, float64): 
//   - string, []byte:  0
//
// ( struct, map ) nil 0
func ToInt8(val interface{}) int8 <span class="cov10" title="25">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov1" title="1">
                return int8(x)</span>
        case int8:<span class="cov1" title="1">
                return x</span>
        case int16:<span class="cov1" title="1">
                return int8(x)</span>
        case int32:<span class="cov1" title="1">
                return int8(x)</span>
        case int64:<span class="cov1" title="1">
                return int8(x)</span>
        case uint:<span class="cov1" title="1">
                return int8(x)</span>
        case uint8:<span class="cov1" title="1">
                return int8(x)</span>
        case uint16:<span class="cov1" title="1">
                return int8(x)</span>
        case uint32:<span class="cov1" title="1">
                return int8(x)</span>
        case uint64:<span class="cov1" title="1">
                return int8(x)</span>
        case float32:<span class="cov1" title="1">
                return int8(x)</span>
        case float64:<span class="cov1" title="1">
                return int8(x)</span>
        case string:<span class="cov5" title="5">
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov1" title="1">return int8(val)</span>
        case []byte:<span class="cov4" title="4">
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov4" title="3">{
                        return 0
                }</span>
                <span class="cov1" title="1">return int8(val)</span>
        default:<span class="cov2" title="2">
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file68" style="display: none">package candy

import "github.com/lazygophers/utils/json"

// ToMap  map[string]interface{}
//
// 
//   - []byte: JSONmapToMapStringAny
//   - string: JSONmapToMapStringAny
//   - : ToMapStringAny
//
//  nil 
func ToMap(v interface{}) map[string]interface{} <span class="cov10" title="8">{
        switch x := v.(type) </span>{
        case []byte:<span class="cov4" title="2">
                var m map[string]interface{}
                err := json.Unmarshal(x, &amp;m)
                if err == nil </span><span class="cov1" title="1">{
                        return m
                }</span>

        case string:<span class="cov5" title="3">
                var m map[string]interface{}
                err := json.UnmarshalString(x, &amp;m)
                if err == nil </span><span class="cov4" title="2">{
                        return m
                }</span>

        }

        <span class="cov7" title="5">return ToMapStringAny(v)</span>
}</pre>
		
		<pre class="file" id="file69" style="display: none">package candy

import "reflect"

// ToMapInt32String  map  map[int32]string
//
//  map  map[int32]string{}
// map  key  ToInt32  int32value  ToString 
func ToMapInt32String(v interface{}) map[int32]string <span class="cov10" title="4">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov5" title="2">{
                return map[int32]string{}
        }</span>

        <span class="cov5" title="2">m := make(map[int32]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov8" title="3">{
                m[ToInt32(mg.Key().Interface())] = ToString(mg.Value().Interface())
        }</span>

        <span class="cov5" title="2">return m</span>
}</pre>
		
		<pre class="file" id="file70" style="display: none">package candy

import "reflect"

// ToMapInt64String  map  map[int64]string
//
//  map  map[int64]string{}
// map  key  ToInt64  int64value  ToString 
func ToMapInt64String(v interface{}) map[int64]string <span class="cov10" title="3">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov1" title="1">{
                return map[int64]string{}
        }</span>

        <span class="cov6" title="2">m := make(map[int64]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov6" title="2">{
                m[ToInt64(mg.Key().Interface())] = ToString(mg.Value().Interface())
        }</span>

        <span class="cov6" title="2">return m</span>
}</pre>
		
		<pre class="file" id="file71" style="display: none">package candy

import "reflect"

// ToMapStringAny  map  map[string]interface{}
//
//  nil nil
//  map  map[string]interface{}{}
// map  key  ToString value 
func ToMapStringAny(v interface{}) map[string]interface{} <span class="cov10" title="13">{
        if v == nil </span><span class="cov3" title="2">{
                return nil
        }</span>

        <span class="cov9" title="11">vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov7" title="6">{
                return map[string]interface{}{}
        }</span>

        <span class="cov6" title="5">m := make(map[string]interface{})

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov9" title="10">{
                m[ToString(mg.Key().Interface())] = mg.Value().Interface()
        }</span>

        <span class="cov6" title="5">return m</span>
}</pre>
		
		<pre class="file" id="file72" style="display: none">package candy

import "reflect"

// ToMapStringArrayString  map  map[string][]string
//
//  nil nil
//  map  panic
// map  key  ToString value  ToArrayString  []string
func ToMapStringArrayString(v interface{}) map[string][]string <span class="cov10" title="5">{
        if v == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov8" title="4">vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov1" title="1">{
                panic("required map type")</span>
        }

        <span class="cov7" title="3">m := make(map[string][]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov8" title="4">{
                m[ToString(mg.Key().Interface())] = ToArrayString(mg.Value().Interface())
        }</span>

        <span class="cov7" title="3">return m</span>
}</pre>
		
		<pre class="file" id="file73" style="display: none">package candy

import "reflect"

// ToMapStringInt64  map  map[string]int64
//
//  map  map[string]int64{}
// map  key  ToString value  ToInt64  int64
func ToMapStringInt64(v interface{}) map[string]int64 <span class="cov10" title="3">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov1" title="1">{
                return map[string]int64{}
        }</span>

        <span class="cov6" title="2">m := make(map[string]int64)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov6" title="2">{
                m[ToString(mg.Key().Interface())] = ToInt64(mg.Value().Interface())
        }</span>

        <span class="cov6" title="2">return m</span>
}</pre>
		
		<pre class="file" id="file74" style="display: none">package candy

import "reflect"

// ToMapStringString  map  map[string]string
//
//  map  map[string]string{}
// map  key  value  ToString 
func ToMapStringString(v interface{}) map[string]string <span class="cov10" title="3">{
        vv := reflect.ValueOf(v)
        if vv.Kind() != reflect.Map </span><span class="cov1" title="1">{
                return map[string]string{}
        }</span>

        <span class="cov6" title="2">m := make(map[string]string)

        mg := vv.MapRange()

        for mg.Next() </span><span class="cov6" title="2">{
                m[ToString(mg.Key().Interface())] = ToString(mg.Value().Interface())
        }</span>

        <span class="cov6" title="2">return m</span>
}</pre>
		
		<pre class="file" id="file75" style="display: none">package candy

// ToPtr 
// 
func ToPtr[T any](v T) *T <span class="cov10" title="6">{
        return &amp;v
}</pre>
		
		<pre class="file" id="file76" style="display: none">package candy

import (
        "math"
        "strconv"
        "time"

        "github.com/lazygophers/utils/json"
)

// ToString 
// 
// - true -&gt; "1", false -&gt; "0"
// - int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64
// - float32, float64
// - time.Duration
// - 
// - 
// - nil
// - error
// -  JSON 
func ToString(val interface{}) string <span class="cov10" title="123">{
        switch x := val.(type) </span>{
        case bool:<span class="cov5" title="9">
                if x </span><span class="cov4" title="7">{
                        return "1"
                }</span>
                <span class="cov2" title="2">return "0"</span>
        case int:<span class="cov6" title="18">
                return strconv.FormatInt(int64(x), 10)</span>
        case int8:<span class="cov1" title="1">
                return strconv.FormatInt(int64(x), 10)</span>
        case int16:<span class="cov1" title="1">
                return strconv.FormatInt(int64(x), 10)</span>
        case int32:<span class="cov1" title="1">
                return strconv.FormatInt(int64(x), 10)</span>
        case int64:<span class="cov1" title="1">
                return strconv.FormatInt(x, 10)</span>
        case uint:<span class="cov1" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint8:<span class="cov1" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint16:<span class="cov1" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint32:<span class="cov1" title="1">
                return strconv.FormatUint(uint64(x), 10)</span>
        case uint64:<span class="cov1" title="1">
                return strconv.FormatUint(x, 10)</span>
        case float32:<span class="cov2" title="2">
                if math.Floor(float64(x)) == float64(x) </span><span class="cov1" title="1">{
                        return strconv.FormatFloat(float64(x), 'f', 0, 32)
                }</span>

                <span class="cov1" title="1">return strconv.FormatFloat(float64(x), 'f', 15, 32)</span>
        case float64:<span class="cov7" title="27">
                if math.Floor(x) == x </span><span class="cov6" title="20">{
                        return strconv.FormatFloat(x, 'f', 0, 64)
                }</span>

                <span class="cov4" title="7">return strconv.FormatFloat(x, 'f', 6, 64)</span>
        case time.Duration:<span class="cov1" title="1">
                return x.String()</span>
        case string:<span class="cov7" title="41">
                return x</span>
        case []byte:<span class="cov1" title="1">
                return string(x)</span>
        case nil:<span class="cov3" title="4">
                return ""</span>
        case error:<span class="cov1" title="1">
                return x.Error()</span>

        default:<span class="cov5" title="10">
                buf, err := json.Marshal(x)
                if err != nil </span><span class="cov1" title="1">{
                        return ""
                }</span>

                <span class="cov5" title="9">return string(buf)</span>
        }
}</pre>
		
		<pre class="file" id="file77" style="display: none">package candy

import (
        "bytes"
        "math"
        "strconv"
        "strings"

        "github.com/lazygophers/utils/json"
)

// ToStringSlice 
// 
// seqs 
func ToStringSlice(val interface{}, seqs ...string) []string <span class="cov10" title="95">{
        var seq string
        if len(seqs) &gt; 0 </span><span class="cov9" title="68">{
                seq = seqs[0]
        }</span> else<span class="cov7" title="27"> {
                seq = ","
        }</span>

        <span class="cov10" title="95">switch x := val.(type) </span>{
        case []bool:<span class="cov3" title="4">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="6">{
                        if v </span><span class="cov3" title="4">{
                                ss = append(ss, "1")
                        }</span> else<span class="cov2" title="2"> {
                                ss = append(ss, "0")
                        }</span>
                }
                <span class="cov3" title="4">return ss</span>

        case []int:<span class="cov4" title="6">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov6" title="13">{
                        ss = append(ss, strconv.Itoa(v))
                }</span>
                <span class="cov4" title="6">return ss</span>

        case []int8:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="6">{
                        ss = append(ss, strconv.FormatInt(int64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []int16:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="6">{
                        ss = append(ss, strconv.FormatInt(int64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []int32:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="6">{
                        ss = append(ss, strconv.FormatInt(int64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []int64:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="6">{
                        ss = append(ss, strconv.FormatInt(v, 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []uint:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="5">{
                        ss = append(ss, strconv.FormatUint(uint64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>


        case []uint16:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="5">{
                        ss = append(ss, strconv.FormatUint(uint64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []uint32:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="5">{
                        ss = append(ss, strconv.FormatUint(uint64(v), 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []uint64:<span class="cov2" title="2">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov4" title="5">{
                        ss = append(ss, strconv.FormatUint(v, 10))
                }</span>
                <span class="cov2" title="2">return ss</span>

        case []float32:<span class="cov3" title="3">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov5" title="9">{
                        if math.Floor(float64(v)) == float64(v) </span><span class="cov4" title="7">{
                                ss = append(ss, strconv.FormatInt(int64(v), 10))
                        }</span> else<span class="cov2" title="2"> {
                                ss = append(ss, strconv.FormatFloat(float64(v), 'f', -1, 32))
                        }</span>
                }
                <span class="cov3" title="3">return ss</span>

        case []float64:<span class="cov3" title="3">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov5" title="9">{
                        if math.Floor(v) == (v) </span><span class="cov4" title="7">{
                                ss = append(ss, strconv.FormatInt(int64(v), 10))
                        }</span> else<span class="cov2" title="2"> {
                                ss = append(ss, strconv.FormatFloat(v, 'f', -1, 32))
                        }</span>
                }
                <span class="cov3" title="3">return ss</span>

        case []string:<span class="cov3" title="4">
                return x</span>

        case []byte:<span class="cov6" title="16">
                if bytes.HasPrefix(x, []byte("[")) &amp;&amp; bytes.HasSuffix(x, []byte("]")) </span><span class="cov5" title="8">{
                        var values []any
                        err := json.Unmarshal(x, &amp;values)
                        if err == nil </span><span class="cov4" title="7">{
                                return ToStringSlice(values)
                        }</span>
                }

                <span class="cov5" title="9">if seq == "" </span><span class="cov0" title="0">{
                        return []string{toString(x)}
                }</span>

                <span class="cov5" title="9">return strings.Split(toString(x), seq)</span>

        case string:<span class="cov7" title="23">
                if strings.HasPrefix(x, "[") &amp;&amp; strings.HasSuffix(x, "]") </span><span class="cov4" title="6">{
                        var values []any
                        err := json.UnmarshalString(x, &amp;values)
                        if err == nil </span><span class="cov4" title="5">{
                                return ToStringSlice(values)
                        }</span>
                }

                <span class="cov6" title="18">if seq == "" </span><span class="cov2" title="2">{
                        return []string{x}
                }</span>

                <span class="cov6" title="16">return strings.Split(x, seq)</span>

        case []interface{}:<span class="cov6" title="16">
                ss := make([]string, 0, len(x))
                for _, v := range x </span><span class="cov8" title="43">{
                        ss = append(ss, ToString(v))
                }</span>
                <span class="cov6" title="16">return ss</span>

        default:<span class="cov3" title="4">
                return nil</span>
        }
}</pre>
		
		<pre class="file" id="file78" style="display: none">package candy

import "strconv"

// ToUint  uint 
// bool
//  0
func ToUint(val interface{}) uint <span class="cov10" title="32">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                // true -&gt; 1false -&gt; 0
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov4" title="4">
                //  uint
                return uint(x)</span>
        case int8:<span class="cov1" title="1">
                return uint(x)</span>
        case int16:<span class="cov1" title="1">
                return uint(x)</span>
        case int32:<span class="cov1" title="1">
                return uint(x)</span>
        case int64:<span class="cov1" title="1">
                return uint(x)</span>
        case uint:<span class="cov2" title="2">
                // 
                return x</span>
        case uint8:<span class="cov1" title="1">
                return uint(x)</span>
        case uint16:<span class="cov1" title="1">
                return uint(x)</span>
        case uint32:<span class="cov1" title="1">
                return uint(x)</span>
        case uint64:<span class="cov1" title="1">
                return uint(x)</span>
        case float32:<span class="cov1" title="1">
                //  uint
                return uint(x)</span>
        case float64:<span class="cov2" title="2">
                return uint(x)</span>
        case string:<span class="cov5" title="5">
                //  uint
                //  0
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov3" title="3">{
                        return 0
                }</span>
                <span class="cov2" title="2">return uint(val)</span>
        case []byte:<span class="cov4" title="4">
                //  uint
                //  0
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov3" title="3">{
                        return 0
                }</span>
                <span class="cov1" title="1">return uint(val)</span>
        default:<span class="cov4" title="4">
                //  0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Package candy 
package candy

import "strconv"

// ToUint16  uint16 
//
// 
//   - bool: true  1false  0
//   -  (int, int8, int16, int32, int64): 
//   -  (uint, uint8, uint16, uint32, uint64): 
//   -  (float32, float64): 
//   - string:  strconv.ParseUint  0
//   - []byte:  0
//   - :  0
//
// :
//
//        val: 
//
// :
//
//        uint16:  uint16  0
//
// :
//
//        ToUint16(42)        //  42
//        ToUint16("100")     //  100
//        ToUint16(true)      //  1
//        ToUint16(3.14)      //  3
//        ToUint16("invalid") //  0
func ToUint16(val interface{}) uint16 <span class="cov10" title="28">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                // true -&gt; 1, false -&gt; 0
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov2" title="2">
                // 
                return uint16(x)</span>
        case int8:<span class="cov1" title="1">
                // 8
                return uint16(x)</span>
        case int16:<span class="cov1" title="1">
                // 16
                return uint16(x)</span>
        case int32:<span class="cov1" title="1">
                // 32
                return uint16(x)</span>
        case int64:<span class="cov1" title="1">
                // 64
                return uint16(x)</span>
        case uint:<span class="cov1" title="1">
                // 
                return uint16(x)</span>
        case uint8:<span class="cov1" title="1">
                // 8
                return uint16(x)</span>
        case uint16:<span class="cov1" title="1">
                //  uint16 
                return x</span>
        case uint32:<span class="cov1" title="1">
                // 32
                return uint16(x)</span>
        case uint64:<span class="cov1" title="1">
                // 64
                return uint16(x)</span>
        case float32:<span class="cov1" title="1">
                // 32
                return uint16(x)</span>
        case float64:<span class="cov2" title="2">
                // 64
                return uint16(x)</span>
        case string:<span class="cov6" title="7">
                // 
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov4" title="4">{
                        //  0
                        return 0
                }</span>
                <span class="cov3" title="3">return uint16(val)</span>
        case []byte:<span class="cov2" title="2">
                // 
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov1" title="1">{
                        //  0
                        return 0
                }</span>
                <span class="cov1" title="1">return uint16(val)</span>
        default:<span class="cov3" title="3">
                //  0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package candy

import "strconv"

// ToUint32  uint32 
// bool
//  0
func ToUint32(val interface{}) uint32 <span class="cov10" title="113">{
        switch x := val.(type) </span>{
        case bool:<span class="cov3" title="4">
                // true -&gt; 1false -&gt; 0
                if x </span><span class="cov2" title="2">{
                        return 1
                }</span>
                <span class="cov2" title="2">return 0</span>
        case int:<span class="cov4" title="6">
                //  uint32
                return uint32(x)</span>
        case int8:<span class="cov3" title="4">
                // 8 uint32
                return uint32(x)</span>
        case int16:<span class="cov3" title="4">
                // 16 uint32
                return uint32(x)</span>
        case int32:<span class="cov3" title="4">
                // 32 uint32
                return uint32(x)</span>
        case int64:<span class="cov5" title="10">
                // 64 uint32
                return uint32(x)</span>
        case uint:<span class="cov3" title="4">
                //  uint32
                return uint32(x)</span>
        case uint8:<span class="cov3" title="4">
                // 8 uint32
                return uint32(x)</span>
        case uint16:<span class="cov3" title="4">
                // 16 uint32
                return uint32(x)</span>
        case uint32:<span class="cov4" title="5">
                //  uint32 
                return x</span>
        case uint64:<span class="cov4" title="5">
                // 64 uint32
                return uint32(x)</span>
        case float32:<span class="cov3" title="3">
                // 32 uint32
                return uint32(x)</span>
        case float64:<span class="cov5" title="12">
                // 64 uint32
                return uint32(x)</span>
        case string:<span class="cov6" title="21">
                //  uint32
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov5" title="11">{
                        return 0
                }</span>
                <span class="cov5" title="10">return uint32(val)</span>
        case []byte:<span class="cov5" title="10">
                //  uint32
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov4" title="6">{
                        return 0
                }</span>
                <span class="cov3" title="4">return uint32(val)</span>
        default:<span class="cov5" title="13">
                //  0
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file81" style="display: none">// Package candy 
package candy

import "strconv"

// ToUint64  uint64 
//
// 
//   - bool: true  1false  0
//   -  (int, int8, int16, int32, int64): 
//   -  (uint, uint8, uint16, uint32, uint64): 
//   -  (float32, float64): 
//   - string:  strconv.ParseUint  0
//   - []byte:  0
//   - :  0
//
// :
//
//        val: 
//
// :
//
//        uint64:  uint64  0
//
// :
//
//        ToUint64(42)         //  42
//        ToUint64("100")      //  100
//        ToUint64(true)       //  1
//        ToUint64(3.14)       //  3
//        ToUint64("invalid")  //  0
func ToUint64(val interface{}) uint64 <span class="cov10" title="125">{
        switch x := val.(type) </span>{
        case bool:<span class="cov3" title="4">
                // true -&gt; 1, false -&gt; 0
                if x </span><span class="cov2" title="2">{
                        return 1
                }</span>
                <span class="cov2" title="2">return 0</span>
        case int:<span class="cov4" title="7">
                // 
                return uint64(x)</span>
        case int8:<span class="cov4" title="5">
                // 8
                return uint64(x)</span>
        case int16:<span class="cov4" title="5">
                // 16
                return uint64(x)</span>
        case int32:<span class="cov4" title="5">
                // 32
                return uint64(x)</span>
        case int64:<span class="cov5" title="9">
                // 64
                return uint64(x)</span>
        case uint:<span class="cov4" title="5">
                // 
                return uint64(x)</span>
        case uint8:<span class="cov4" title="6">
                // 8
                return uint64(x)</span>
        case uint16:<span class="cov4" title="6">
                // 16
                return uint64(x)</span>
        case uint32:<span class="cov4" title="6">
                // 32
                return uint64(x)</span>
        case uint64:<span class="cov4" title="6">
                //  uint64 
                return x</span>
        case float32:<span class="cov3" title="4">
                // 32
                return uint64(x)</span>
        case float64:<span class="cov5" title="13">
                // 64
                return uint64(x)</span>
        case string:<span class="cov6" title="21">
                // 
                val, err := strconv.ParseUint(x, 10, 64)
                if err != nil </span><span class="cov5" title="12">{
                        //  0
                        return 0
                }</span>
                <span class="cov5" title="9">return val</span>
        case []byte:<span class="cov5" title="11">
                // 
                val, err := strconv.ParseUint(string(x), 10, 64)
                if err != nil </span><span class="cov4" title="6">{
                        //  0
                        return 0
                }</span>
                <span class="cov4" title="5">return val</span>
        default:<span class="cov5" title="12">
                //  0
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file82" style="display: none">package candy

import "strconv"

// ToUint8  uint8 
// bool
//  0
func ToUint8(val interface{}) uint8 <span class="cov10" title="34">{
        switch x := val.(type) </span>{
        case bool:<span class="cov2" title="2">
                // true -&gt; 1false -&gt; 0
                if x </span><span class="cov1" title="1">{
                        return 1
                }</span>
                <span class="cov1" title="1">return 0</span>
        case int:<span class="cov3" title="3">
                //  uint8
                return uint8(x)</span>
        case int8:<span class="cov2" title="2">
                return uint8(x)</span>
        case int16:<span class="cov1" title="1">
                return uint8(x)</span>
        case int32:<span class="cov1" title="1">
                return uint8(x)</span>
        case int64:<span class="cov1" title="1">
                return uint8(x)</span>
        case uint:<span class="cov1" title="1">
                //  uint8
                return uint8(x)</span>
        case uint8:<span class="cov2" title="2">
                // uint8 
                return x</span>
        case uint16:<span class="cov1" title="1">
                // uint16  uint8
                return uint8(x)</span>
        case uint32:<span class="cov1" title="1">
                // uint32  uint8
                return uint8(x)</span>
        case uint64:<span class="cov1" title="1">
                // uint64  uint8
                return uint8(x)</span>
        case float32:<span class="cov1" title="1">
                //  uint8
                return uint8(x)</span>
        case float64:<span class="cov3" title="3">
                //  uint8
                return uint8(x)</span>
        case string:<span class="cov5" title="7">
                //  uint8
                //  0
                val, err := strconv.ParseUint(x, 10, 8)
                if err != nil </span><span class="cov4" title="4">{
                        return 0
                }</span>
                <span class="cov3" title="3">return uint8(val)</span>
        case []byte:<span class="cov4" title="4">
                //  uint8
                //  0
                val, err := strconv.ParseUint(string(x), 10, 8)
                if err != nil </span><span class="cov3" title="3">{
                        return 0
                }</span>
                <span class="cov1" title="1">return uint8(val)</span>
        default:<span class="cov3" title="3">
                //  0
                return 0</span>
        }
}</pre>
		
		<pre class="file" id="file83" style="display: none">package candy

// Top  n 
//  n 
//  copy 
func Top[T any](ss []T, n int) (ret []T) <span class="cov10" title="9">{
        if n &lt;= 0 </span><span class="cov3" title="2">{
                return []T{}
        }</span>
        <span class="cov8" title="7">if n &gt; len(ss) </span><span class="cov3" title="2">{
                n = len(ss)
        }</span>

        <span class="cov8" title="7">ret = make([]T, n)
        copy(ret, ss[:n])
        return ret</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">// Package candy  Go 
package candy

import (
        "golang.org/x/exp/constraints"
)

// Unique 
//
// 
//   - T: 
//
// 
//   - ss: 
//
// 
//   - []T: 
//
// 
//   - 
//   -  map  O(n)
//   -  nil
//   - 
//
// 
//
//        // 
//        numbers := []int{1, 2, 2, 3, 4, 4, 5}
//        unique := Unique(numbers)
//        // unique  []int{1, 2, 3, 4, 5}
//
//        // 
//        names := []string{"Alice", "Bob", "Alice", "Charlie", "Bob"}
//        uniqueNames := Unique(names)
//        // uniqueNames  []string{"Alice", "Bob", "Charlie"}
//
//        // 
//        floats := []float64{1.1, 2.2, 1.1, 3.3, 2.2}
//        uniqueFloats := Unique(floats)
//        // uniqueFloats  []float64{1.1, 2.2, 3.3}
func Unique[T constraints.Ordered](ss []T) (ret []T) <span class="cov7" title="20">{
        //  make  nil
        ret = make([]T, 0)
        m := make(map[T]struct{}, len(ss))
        for _, s := range ss </span><span class="cov10" title="89">{
                if _, ok := m[s]; !ok </span><span class="cov9" title="56">{
                        m[s] = struct{}{}
                        ret = append(ret, s)
                }</span>
        }

        <span class="cov7" title="20">return</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">// Package candy  Go 
package candy

// UniqueUsing 
//
// 
//   - T: 
//
// 
//   - ss: 
//   - f: 
//
// 
//   - []T: 
//
// 
//   - 
//   - 
//   -  nil
//   - 
//   -  O(n) O(n)
//
// 
//
//        //  ID
//        type User struct {
//            ID   int
//            Name string
//        }
//        users := []User{{1, "Alice"}, {2, "Bob"}, {1, "Alice2"}}
//        uniqueUsers := UniqueUsing(users, func(u User) any { return u.ID })
//        // uniqueUsers  []User{{1, "Alice"}, {2, "Bob"}}
//
//        // 
//        words := []string{"apple", "banana", "orange", "kiwi"}
//        uniqueLengths := UniqueUsing(words, func(s string) any { return len(s) })
//        // uniqueLengths  []string{"apple", "banana", "orange"}
//
//        // 
//        names := []string{"Alice", "Bob", "Anna", "Charlie", "Bob"}
//        uniqueFirstLetters := UniqueUsing(names, func(s string) any { return s[0] })
//        // uniqueFirstLetters  []string{"Alice", "Bob", "Charlie"}
func UniqueUsing[T any](ss []T, f func(T) any) (ret []T) <span class="cov4" title="22">{
        //  nil
        if len(ss) == 0 </span><span class="cov2" title="3">{
                return []T{}
        }</span>

        // 
        <span class="cov4" title="19">m := make(map[any]struct{})

        // 
        for _, s := range ss </span><span class="cov10" title="1068">{
                // 
                key := f(s)

                // 
                if _, ok := m[key]; !ok </span><span class="cov7" title="147">{
                        m[key] = struct{}{}
                        ret = append(ret, s)
                }</span>
        }

        <span class="cov4" title="19">return ret</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package config

import (
        "bufio"
        "encoding/xml"
        "fmt"
        "github.com/hashicorp/hcl/v2/hclsimple"
        "github.com/lazygophers/log"
        "github.com/lazygophers/utils"
        "github.com/lazygophers/utils/json"
        "github.com/lazygophers/utils/osx"
        "github.com/lazygophers/utils/runtime"
        "github.com/pelletier/go-toml/v2"
        "github.com/yosuke-furukawa/json5/encoding/json5"
        "gopkg.in/ini.v1"
        "gopkg.in/yaml.v3"
        "io"
        "os"
        "path/filepath"
        "reflect"
        "strconv"
        "strings"
)

type Unmarshaler func(reader io.Reader, v interface{}) error
type Marshaler func(writer io.Writer, v interface{}) error

type supportedExt struct {
        Marshaler   Marshaler
        Unmarshaler Unmarshaler
}

var supportedExtMap = map[string]supportedExt{
        ".json": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov4" title="11">{
                        return json.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov2" title="2">{
                        return json.NewEncoder(writer).Encode(v)
                }</span>,
        },
        ".toml": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov1" title="1">{
                        return toml.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov2" title="2">{
                        return toml.NewEncoder(writer).Encode(v)
                }</span>,
        },
        ".yaml": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov1" title="1">{
                        return yaml.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov2" title="2">{
                        return yaml.NewEncoder(writer).Encode(v)
                }</span>,
        },
        ".yml": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov1" title="1">{
                        return yaml.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov1" title="1">{
                        return yaml.NewEncoder(writer).Encode(v)
                }</span>,
        },
        ".ini": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov2" title="2">{
                        cfg, err := ini.Load(reader)
                        if err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                        <span class="cov1" title="1">return cfg.MapTo(v)</span>
                },
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov2" title="2">{
                        cfg := ini.Empty()
                        err := cfg.ReflectFrom(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov2" title="2">_, err = cfg.WriteTo(writer)
                        return err</span>
                },
        },
        ".xml": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov2" title="2">{
                        return xml.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov1" title="1">{
                        encoder := xml.NewEncoder(writer)
                        encoder.Indent("", "  ")
                        return encoder.Encode(v)
                }</span>,
        },
        ".properties": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov3" title="6">{
                        return parseProperties(reader, v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov1" title="1">{
                        return writeProperties(writer, v)
                }</span>,
        },
        ".env": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov3" title="5">{
                        return parseEnvFile(reader, v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov1" title="1">{
                        return writeEnvFile(writer, v)
                }</span>,
        },
        ".hcl": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov1" title="1">{
                        content, err := io.ReadAll(reader)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov1" title="1">return hclsimple.Decode("config.hcl", content, nil, v)</span>
                },
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov1" title="1">{
                        return writeHCLFile(writer, v)
                }</span>,
        },
        ".json5": {
                Unmarshaler: func(reader io.Reader, v interface{}) error <span class="cov0" title="0">{
                        return json5.NewDecoder(reader).Decode(v)
                }</span>,
                Marshaler: func(writer io.Writer, v interface{}) error <span class="cov0" title="0">{
                        return json5.NewEncoder(writer).Encode(v)
                }</span>,
        },
}

func RegisterParser(ext string, m Marshaler, u Unmarshaler) <span class="cov2" title="2">{
        supportedExtMap[ext] = supportedExt{
                Marshaler:   m,
                Unmarshaler: u,
        }
}</span>

func tryFindConfigPath(baseDir string) string <span class="cov5" title="15">{
        for ext := range supportedExtMap </span><span class="cov8" title="121">{
                path := filepath.Join(baseDir, "conf"+ext)
                if osx.IsFile(path) </span><span class="cov2" title="3">{
                        return path
                }</span>

                <span class="cov8" title="118">path = filepath.Join(baseDir, "config"+ext)
                if osx.IsFile(path) </span><span class="cov1" title="1">{
                        return path
                }</span>
        }

        <span class="cov4" title="11">return ""</span>
}

var configPath string

func LoadConfig(c any, paths ...string) (err error) <span class="cov4" title="8">{
        err = LoadConfigSkipValidate(c, paths...)
        if err != nil </span><span class="cov1" title="1">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov4" title="7">err = utils.Validate(c)
        if err != nil </span><span class="cov3" title="6">{
                log.Errorf("err:%v", err)
                return err
        }</span>

        <span class="cov1" title="1">log.Info("load config success")

        return nil</span>
}

func LoadConfigSkipValidate(c any, paths ...string) error <span class="cov6" title="39">{
        // 
        if len(paths) &gt; 0 </span><span class="cov6" title="35">{
                for _, path := range paths </span><span class="cov6" title="36">{
                        if osx.IsFile(path) </span><span class="cov6" title="31">{
                                configPath = path
                                break</span>
                        }
                }
        }

        // NOTE: 
        <span class="cov6" title="39">if configPath == ""</span><span class="cov4" title="7">{
                log.Warnf("Try to load config from environment variable(LAZYGOPHERS_CONFIG)")
                configPath = os.Getenv("LAZYGOPHERS_CONFIG")
                if configPath != "" &amp;&amp; !osx.IsFile(configPath) </span><span class="cov1" title="1">{
                        log.Debugf("config file not found:%v", configPath)
                        configPath = ""
                }</span>
        }

        // NOTE: 
        <span class="cov6" title="39">if configPath == "" </span><span class="cov3" title="6">{
                log.Warnf("Try to load config from %s", runtime.Pwd())
                configPath = tryFindConfigPath(runtime.Pwd())
        }</span>

        //// NOTE: 
        //if configPath == "" {
        //        log.Warnf("Try to load config from %s", runtime.UserHomeDir())
        //        configPath = tryFindConfigPath(filepath.Join(runtime.UserHomeDir(), app.Name))
        //}
        //
        //// NOTE: 
        //if configPath == "" {
        //        log.Warnf("Try to load config from %s", runtime.UserConfigDir())
        //        configPath = tryFindConfigPath(filepath.Join(runtime.UserConfigDir(), app.Name))
        //}

        // NOTE: 
        <span class="cov6" title="39">if configPath == "" </span><span class="cov3" title="5">{
                log.Warnf("Try to load config from %s", runtime.ExecDir())
                configPath = tryFindConfigPath(runtime.ExecDir())
        }</span>

        <span class="cov6" title="39">file, err := os.Open(configPath)
        if err != nil </span><span class="cov4" title="7">{
                if os.IsNotExist(err) </span><span class="cov3" title="6">{
                        log.Warnf("Config file not found, use default config")
                        log.Debugf("config file not found:%v", configPath)
                }</span> else<span class="cov1" title="1"> {
                        log.Warnf("Config file open failed, use default config")
                        log.Errorf("err:%v", err)
                }</span>
        } else<span class="cov6" title="32"> {
                defer file.Close()
                log.Infof("Config file found, use config from %s", configPath)

                ext := filepath.Ext(configPath)
                if supported, ok := supportedExtMap[ext]; ok </span><span class="cov6" title="30">{
                        err = supported.Unmarshaler(file, c)
                        if err != nil </span><span class="cov3" title="4">{
                                log.Errorf("err:%v", err)
                        }</span>
                } else<span class="cov2" title="2"> {
                        log.Errorf("unsupported config file format:%v", ext)
                        return fmt.Errorf("unsupported config file format:%v", ext)
                }</span>
        }

        <span class="cov6" title="37">log.Info("load config success")

        return nil</span>
}

func SetConfig(c any) error <span class="cov5" title="16">{
        ext := filepath.Ext(configPath)
        if supported, ok := supportedExtMap[ext]; ok </span><span class="cov5" title="14">{
                file, err := os.OpenFile(configPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
                if err != nil </span><span class="cov1" title="1">{
                        log.Errorf("err:%v", err)
                        return err
                }</span>
                <span class="cov5" title="13">defer file.Close()

                err = supported.Marshaler(file, c)
                if err != nil </span><span class="cov1" title="1">{
                        log.Errorf("err:%v", err)
                        return nil
                }</span>

        } else<span class="cov2" title="2"> {
                log.Errorf("unsupported config file format:%v", ext)
                return fmt.Errorf("unsupported config file format:%v", ext)
        }</span>

        <span class="cov4" title="11">return nil</span>
}

// parseProperties  .properties 
func parseProperties(reader io.Reader, v interface{}) error <span class="cov4" title="10">{
        props := make(map[string]string)
        scanner := bufio.NewScanner(reader)
        
        for scanner.Scan() </span><span class="cov6" title="38">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "!") </span><span class="cov3" title="5">{
                        continue</span>
                }
                
                //  =  : 
                <span class="cov6" title="33">sepIndex := -1
                for i, char := range line </span><span class="cov10" title="291">{
                        if char == '=' || char == ':' </span><span class="cov6" title="32">{
                                sepIndex = i
                                break</span>
                        }
                }
                
                <span class="cov6" title="33">if sepIndex == -1 </span><span class="cov1" title="1">{
                        continue</span>
                }
                
                <span class="cov6" title="32">key := strings.TrimSpace(line[:sepIndex])
                value := strings.TrimSpace(line[sepIndex+1:])
                
                // 
                value = strings.ReplaceAll(value, "\\\\", "\\")
                value = strings.ReplaceAll(value, "\\n", "\n")
                value = strings.ReplaceAll(value, "\\t", "\t")
                value = strings.ReplaceAll(value, "\\r", "\r")
                
                props[key] = value</span>
        }
        
        <span class="cov4" title="10">if err := scanner.Err(); err != nil </span><span class="cov2" title="2">{
                return err
        }</span>
        
        <span class="cov4" title="8">return mapToStruct(props, v)</span>
}

// writeProperties  .properties 
func writeProperties(writer io.Writer, v interface{}) error <span class="cov3" title="5">{
        props, err := structToMap(v)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        
        <span class="cov3" title="4">for key, value := range props </span><span class="cov4" title="9">{
                // 
                valueStr := fmt.Sprintf("%v", value)
                valueStr = strings.ReplaceAll(valueStr, "\n", "\\n")
                valueStr = strings.ReplaceAll(valueStr, "\t", "\\t")
                valueStr = strings.ReplaceAll(valueStr, "\r", "\\r")
                
                _, err := fmt.Fprintf(writer, "%s=%s\n", key, valueStr)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        
        <span class="cov2" title="3">return nil</span>
}

// parseEnvFile  .env 
func parseEnvFile(reader io.Reader, v interface{}) error <span class="cov4" title="9">{
        props := make(map[string]string)
        scanner := bufio.NewScanner(reader)
        
        for scanner.Scan() </span><span class="cov6" title="31">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov2" title="2">{
                        continue</span>
                }
                
                //  = 
                <span class="cov6" title="29">sepIndex := strings.Index(line, "=")
                if sepIndex == -1 </span><span class="cov1" title="1">{
                        continue</span>
                }
                
                <span class="cov6" title="28">key := strings.TrimSpace(line[:sepIndex])
                value := strings.TrimSpace(line[sepIndex+1:])
                
                // 
                if len(value) &gt;= 2 </span><span class="cov6" title="28">{
                        if (value[0] == '"' &amp;&amp; value[len(value)-1] == '"') ||
                                (value[0] == '\'' &amp;&amp; value[len(value)-1] == '\'') </span><span class="cov4" title="11">{
                                value = value[1 : len(value)-1]
                        }</span>
                }
                
                <span class="cov6" title="28">props[key] = value</span>
        }
        
        <span class="cov4" title="9">if err := scanner.Err(); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        
        <span class="cov4" title="8">return mapToStruct(props, v)</span>
}

// writeEnvFile  .env 
func writeEnvFile(writer io.Writer, v interface{}) error <span class="cov3" title="5">{
        props, err := structToMap(v)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        
        <span class="cov3" title="4">for key, value := range props </span><span class="cov4" title="9">{
                valueStr := fmt.Sprintf("%v", value)
                
                // 
                if strings.ContainsAny(valueStr, " \t\n\r\"'\\") </span><span class="cov3" title="4">{
                        valueStr = strconv.Quote(valueStr)
                }</span>
                
                <span class="cov4" title="9">_, err := fmt.Fprintf(writer, "%s=%s\n", key, valueStr)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        
        <span class="cov2" title="3">return nil</span>
}

// mapToStruct  map 
func mapToStruct(props map[string]string, v interface{}) error <span class="cov6" title="25">{
        rv := reflect.ValueOf(v)
        if rv.Kind() != reflect.Ptr || rv.Elem().Kind() != reflect.Struct </span><span class="cov2" title="2">{
                return fmt.Errorf("v must be a pointer to struct")
        }</span>
        
        <span class="cov5" title="23">rv = rv.Elem()
        rt := rv.Type()
        
        for i := 0; i &lt; rt.NumField(); i++ </span><span class="cov7" title="61">{
                field := rt.Field(i)
                fieldValue := rv.Field(i)
                
                if !fieldValue.CanSet() </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // 
                <span class="cov7" title="61">tagName := getFieldTagName(field)
                if tagName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // 
                <span class="cov7" title="61">if fieldValue.Kind() == reflect.Struct </span><span class="cov5" title="15">{
                        err := parseNestedStruct(props, fieldValue, tagName)
                        if err != nil </span><span class="cov2" title="2">{
                                return err
                        }</span>
                        <span class="cov5" title="13">continue</span>
                }
                
                //  map 
                <span class="cov7" title="46">if propValue, exists := props[tagName]; exists </span><span class="cov7" title="46">{
                        err := setFieldValue(fieldValue, propValue)
                        if err != nil </span><span class="cov2" title="3">{
                                return fmt.Errorf("failed to set field %s: %w", field.Name, err)
                        }</span>
                }
        }
        
        <span class="cov5" title="18">return nil</span>
}

// structToMap  map
func structToMap(v interface{}) (map[string]interface{}, error) <span class="cov5" title="15">{
        result := make(map[string]interface{})
        
        rv := reflect.ValueOf(v)
        if rv.Kind() == reflect.Ptr </span><span class="cov1" title="1">{
                rv = rv.Elem()
        }</span>
        
        <span class="cov5" title="15">if rv.Kind() != reflect.Struct </span><span class="cov3" title="4">{
                return nil, fmt.Errorf("v must be a struct or pointer to struct")
        }</span>
        
        <span class="cov4" title="11">rt := rv.Type()
        
        for i := 0; i &lt; rt.NumField(); i++ </span><span class="cov5" title="18">{
                field := rt.Field(i)
                fieldValue := rv.Field(i)
                
                tagName := getFieldTagName(field)
                if tagName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov5" title="18">if fieldValue.Kind() == reflect.Struct </span><span class="cov2" title="3">{
                        // 
                        structMapToFlat(result, fieldValue, tagName)
                        continue</span>
                }
                
                <span class="cov5" title="15">result[tagName] = fieldValue.Interface()</span>
        }
        
        <span class="cov4" title="11">return result, nil</span>
}

// getFieldTagName 
func getFieldTagName(field reflect.StructField) string <span class="cov8" title="140">{
        // : properties &gt; env &gt; json &gt; yaml &gt; toml &gt; ini
        tags := []string{"properties", "env", "json", "yaml", "toml", "ini"}
        
        for _, tag := range tags </span><span class="cov9" title="187">{
                if tagValue := field.Tag.Get(tag); tagValue != "" &amp;&amp; tagValue != "-" </span><span class="cov8" title="136">{
                        //  json:",omitempty" 
                        if commaIndex := strings.Index(tagValue, ","); commaIndex != -1 </span><span class="cov1" title="1">{
                                return tagValue[:commaIndex]
                        }</span>
                        <span class="cov8" title="135">return tagValue</span>
                }
        }
        
        <span class="cov3" title="4">return strings.ToLower(field.Name)</span>
}

// setFieldValue 
func setFieldValue(fieldValue reflect.Value, propValue string) error <span class="cov8" title="87">{
        switch fieldValue.Kind() </span>{
        case reflect.String:<span class="cov6" title="35">
                fieldValue.SetString(propValue)</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov6" title="25">
                val, err := strconv.ParseInt(propValue, 10, 64)
                if err != nil </span><span class="cov3" title="5">{
                        return err
                }</span>
                <span class="cov5" title="20">fieldValue.SetInt(val)</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov3" title="6">
                val, err := strconv.ParseUint(propValue, 10, 64)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov3" title="5">fieldValue.SetUint(val)</span>
        case reflect.Float32, reflect.Float64:<span class="cov2" title="3">
                val, err := strconv.ParseFloat(propValue, 64)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov2" title="2">fieldValue.SetFloat(val)</span>
        case reflect.Bool:<span class="cov5" title="14">
                val, err := strconv.ParseBool(propValue)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov5" title="13">fieldValue.SetBool(val)</span>
        default:<span class="cov3" title="4">
                return fmt.Errorf("unsupported field type: %s", fieldValue.Kind())</span>
        }
        
        <span class="cov7" title="75">return nil</span>
}

// parseNestedStruct 
func parseNestedStruct(props map[string]string, structValue reflect.Value, prefix string) error <span class="cov5" title="18">{
        structType := structValue.Type()
        
        for i := 0; i &lt; structType.NumField(); i++ </span><span class="cov6" title="38">{
                field := structType.Field(i)
                fieldValue := structValue.Field(i)
                
                if !fieldValue.CanSet() </span><span class="cov2" title="2">{
                        continue</span>
                }
                
                <span class="cov6" title="36">tagName := getFieldTagName(field)
                if tagName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov6" title="36">fullKey := prefix + "." + tagName
                
                if fieldValue.Kind() == reflect.Struct </span><span class="cov1" title="1">{
                        err := parseNestedStruct(props, fieldValue, fullKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov6" title="35"> if propValue, exists := props[fullKey]; exists </span><span class="cov5" title="21">{
                        err := setFieldValue(fieldValue, propValue)
                        if err != nil </span><span class="cov2" title="3">{
                                return fmt.Errorf("failed to set nested field %s: %w", field.Name, err)
                        }</span>
                }
        }
        
        <span class="cov5" title="15">return nil</span>
}

// structMapToFlat  map 
func structMapToFlat(result map[string]interface{}, structValue reflect.Value, prefix string) <span class="cov4" title="8">{
        structType := structValue.Type()
        
        for i := 0; i &lt; structType.NumField(); i++ </span><span class="cov5" title="16">{
                field := structType.Field(i)
                fieldValue := structValue.Field(i)
                
                tagName := getFieldTagName(field)
                if tagName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov5" title="16">fullKey := prefix + "." + tagName
                
                if fieldValue.Kind() == reflect.Struct </span><span class="cov2" title="2">{
                        structMapToFlat(result, fieldValue, fullKey)
                }</span> else<span class="cov5" title="14"> {
                        result[fullKey] = fieldValue.Interface()
                }</span>
        }
}

// writeHCLFile  HCL 
func writeHCLFile(writer io.Writer, v interface{}) error <span class="cov3" title="4">{
        hclContent, err := structToHCL(v, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov3" title="4">_, err = writer.Write([]byte(hclContent))
        return err</span>
}

// structToHCL  HCL 
func structToHCL(v interface{}, indent string) (string, error) <span class="cov4" title="7">{
        rv := reflect.ValueOf(v)
        if rv.Kind() == reflect.Ptr </span><span class="cov1" title="1">{
                rv = rv.Elem()
        }</span>
        
        <span class="cov4" title="7">if rv.Kind() != reflect.Struct </span><span class="cov2" title="3">{
                return fmt.Sprintf("%v", v), nil
        }</span>
        
        <span class="cov3" title="4">rt := rv.Type()
        var result strings.Builder
        
        for i := 0; i &lt; rt.NumField(); i++ </span><span class="cov4" title="9">{
                field := rt.Field(i)
                fieldValue := rv.Field(i)
                
                tagName := getHCLFieldTagName(field)
                if tagName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov4" title="9">if fieldValue.Kind() == reflect.Struct </span><span class="cov1" title="1">{
                        nestedContent, err := structToHCL(fieldValue.Interface(), indent+"  ")
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov1" title="1">result.WriteString(fmt.Sprintf("%s%s {\n%s%s}\n", indent, tagName, nestedContent, indent))</span>
                } else<span class="cov4" title="8"> {
                        value := formatHCLValue(fieldValue.Interface())
                        result.WriteString(fmt.Sprintf("%s%s = %s\n", indent, tagName, value))
                }</span>
        }
        
        <span class="cov3" title="4">return result.String(), nil</span>
}

// getHCLFieldTagName  HCL 
func getHCLFieldTagName(field reflect.StructField) string <span class="cov5" title="15">{
        // : hcl &gt; json &gt; yaml &gt; toml &gt; ini
        tags := []string{"hcl", "json", "yaml", "toml", "ini"}
        
        for _, tag := range tags </span><span class="cov6" title="33">{
                if tagValue := field.Tag.Get(tag); tagValue != "" &amp;&amp; tagValue != "-" </span><span class="cov5" title="13">{
                        if commaIndex := strings.Index(tagValue, ","); commaIndex != -1 </span><span class="cov1" title="1">{
                                return tagValue[:commaIndex]
                        }</span>
                        <span class="cov4" title="12">return tagValue</span>
                }
        }
        
        <span class="cov2" title="2">return strings.ToLower(field.Name)</span>
}

// formatHCLValue  HCL 
func formatHCLValue(value interface{}) string <span class="cov6" title="24">{
        switch v := value.(type) </span>{
        case string:<span class="cov3" title="6">
                return fmt.Sprintf(`"%s"`, v)</span>
        case bool:<span class="cov2" title="3">
                return fmt.Sprintf("%t", v)</span>
        case int, int8, int16, int32, int64:<span class="cov3" title="6">
                return fmt.Sprintf("%d", v)</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov3" title="5">
                return fmt.Sprintf("%d", v)</span>
        case float32, float64:<span class="cov2" title="2">
                return fmt.Sprintf("%g", v)</span>
        default:<span class="cov2" title="2">
                return fmt.Sprintf(`"%v"`, v)</span>
        }
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package cryptox

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "errors"
        "io"
)

// Global variables for dependency injection during testing
var (
        newCipherFunc = aes.NewCipher
        newGCMFunc    = cipher.NewGCM
        randReader    = rand.Reader
)

// Encrypt  AES-256  GCM 
func Encrypt(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1116">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1108">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1107">gcm, err := newGCMFunc(block)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1106">nonce := make([]byte, gcm.NonceSize())
        _, err = io.ReadFull(randReader, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1105">ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
        return ciphertext, nil</span>
}

// Decrypt  AES-256  GCM 
func Decrypt(key, ciphertext []byte) ([]byte, error) <span class="cov3" title="10">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov3" title="8">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="7">gcm, err := newGCMFunc(block)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="6">if len(ciphertext) &lt; gcm.NonceSize() </span><span class="cov1" title="2">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov2" title="4">nonce, ciphertext := ciphertext[:gcm.NonceSize()], ciphertext[gcm.NonceSize():]
        plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="3">return plaintext, nil</span>
}

// EncryptECB  AES-256  ECB 
// ECB
// GCMCBCCFB
func EncryptECB(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1014">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1006">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1005">plaintext = padPKCS7(plaintext, block.BlockSize())
        ciphertext := make([]byte, len(plaintext))
        for i := 0; i &lt; len(plaintext); i += block.BlockSize() </span><span class="cov9" title="2031">{
                block.Encrypt(ciphertext[i:i+block.BlockSize()], plaintext[i:i+block.BlockSize()])
        }</span>
        <span class="cov9" title="1005">return ciphertext, nil</span>
}

// DecryptECB  AES-256  ECB 
// ECB
// GCMCBCCFB
func DecryptECB(key, ciphertext []byte) ([]byte, error) <span class="cov3" title="7">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov2" title="5">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="4">plaintext := make([]byte, len(ciphertext))
        for i := 0; i &lt; len(ciphertext); i += block.BlockSize() </span><span class="cov9" title="1028">{
                block.Decrypt(plaintext[i:i+block.BlockSize()], ciphertext[i:i+block.BlockSize()])
        }</span>
        <span class="cov2" title="4">return unpadPKCS7(plaintext)</span>
}

// padPKCS7  PKCS#7 
func padPKCS7(data []byte, blockSize int) []byte <span class="cov10" title="2144">{
        padding := blockSize - len(data)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(data, padtext...)
}</span>

// unpadPKCS7  PKCS#7 
func unpadPKCS7(data []byte) ([]byte, error) <span class="cov5" title="42">{
        length := len(data)
        if length == 0 </span><span class="cov1" title="1">{
                return nil, errors.New("data is empty")
        }</span>
        <span class="cov5" title="41">unpadding := int(data[length-1])
        if unpadding &gt; length || unpadding == 0 </span><span class="cov3" title="9">{
                return nil, errors.New("invalid padding")
        }</span>
        <span class="cov5" title="32">paddingData := data[length-unpadding:]
        for _, b := range paddingData </span><span class="cov7" title="210">{
                if int(b) != unpadding </span><span class="cov1" title="2">{
                        return nil, errors.New("invalid padding data")
                }</span>
        }
        <span class="cov4" title="30">return data[:(length - unpadding)], nil</span>
}

// EncryptCBC  AES-256  CBC 
func EncryptCBC(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1113">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1105">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1104">plaintext = padPKCS7(plaintext, block.BlockSize())
        ciphertext := make([]byte, aes.BlockSize+len(plaintext))
        iv := ciphertext[:aes.BlockSize]
        _, err = io.ReadFull(randReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1103">mode := cipher.NewCBCEncrypter(block, iv)
        mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// DecryptCBC  AES-256  CBC 
func DecryptCBC(key, ciphertext []byte) ([]byte, error) <span class="cov3" title="8">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov3" title="6">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="5">if len(ciphertext) &lt; aes.BlockSize </span><span class="cov2" title="3">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov1" title="2">iv := ciphertext[:aes.BlockSize]
        ciphertext = ciphertext[aes.BlockSize:]

        mode := cipher.NewCBCDecrypter(block, iv)
        mode.CryptBlocks(ciphertext, ciphertext)

        plaintext, err := unpadPKCS7(ciphertext)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return plaintext, nil</span>
}

// EncryptCFB  AES-256  CFB 
func EncryptCFB(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1113">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1105">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1104">ciphertext := make([]byte, aes.BlockSize+len(plaintext))
        iv := ciphertext[:aes.BlockSize]
        _, err = io.ReadFull(randReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1103">stream := cipher.NewCFBEncrypter(block, iv)
        stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// DecryptCFB  AES-256  CFB 
func DecryptCFB(key, ciphertext []byte) ([]byte, error) <span class="cov3" title="7">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov2" title="5">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="4">if len(ciphertext) &lt; aes.BlockSize </span><span class="cov2" title="3">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov1" title="1">iv := ciphertext[:aes.BlockSize]
        ciphertext = ciphertext[aes.BlockSize:]

        stream := cipher.NewCFBDecrypter(block, iv)
        stream.XORKeyStream(ciphertext, ciphertext)
        return ciphertext, nil</span>
}

// EncryptCTR  AES-256  CTR 
func EncryptCTR(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1113">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1105">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1104">ciphertext := make([]byte, aes.BlockSize+len(plaintext))
        iv := ciphertext[:aes.BlockSize]
        _, err = io.ReadFull(randReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1103">stream := cipher.NewCTR(block, iv)
        stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// DecryptCTR  AES-256  CTR 
func DecryptCTR(key, ciphertext []byte) ([]byte, error) <span class="cov3" title="7">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov2" title="5">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="4">if len(ciphertext) &lt; aes.BlockSize </span><span class="cov2" title="3">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov1" title="1">iv := ciphertext[:aes.BlockSize]
        ciphertext = ciphertext[aes.BlockSize:]

        stream := cipher.NewCTR(block, iv)
        stream.XORKeyStream(ciphertext, ciphertext)
        return ciphertext, nil</span>
}

// EncryptOFB  AES-256  OFB 
func EncryptOFB(key, plaintext []byte) ([]byte, error) <span class="cov9" title="1120">{
        if len(key) != 32 </span><span class="cov3" title="8">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov9" title="1112">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1111">ciphertext := make([]byte, aes.BlockSize+len(plaintext))
        iv := ciphertext[:aes.BlockSize]
        _, err = io.ReadFull(randReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="1110">stream := cipher.NewOFB(block, iv)
        stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// DecryptOFB  AES-256  OFB 
func DecryptOFB(key, ciphertext []byte) ([]byte, error) <span class="cov4" title="14">{
        if len(key) != 32 </span><span class="cov1" title="2">{
                return nil, errors.New("invalid key length: must be 32 bytes")
        }</span>

        <span class="cov3" title="12">block, err := newCipherFunc(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="11">if len(ciphertext) &lt; aes.BlockSize </span><span class="cov1" title="2">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov3" title="9">iv := ciphertext[:aes.BlockSize]
        ciphertext = ciphertext[aes.BlockSize:]

        stream := cipher.NewOFB(block, iv)
        stream.XORKeyStream(ciphertext, ciphertext)
        return ciphertext, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package cryptox

import (
        "crypto/cipher"
        "crypto/rand"
        "errors"
        "io"

        "golang.org/x/crypto/blowfish"
)

// Global variables for dependency injection during testing
var (
        blowfishNewCipher  func([]byte) (*blowfish.Cipher, error) = blowfish.NewCipher
        blowfishRandReader = rand.Reader
)

// BlowfishEncryptECB  Blowfish  ECB 
// ECB 
func BlowfishEncryptECB(key, plaintext []byte) ([]byte, error) <span class="cov5" title="11">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov5" title="9">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="8">plaintext = padPKCS7(plaintext, blowfish.BlockSize)
        ciphertext := make([]byte, len(plaintext))
        for i := 0; i &lt; len(plaintext); i += blowfish.BlockSize </span><span class="cov10" title="130">{
                block.Encrypt(ciphertext[i:i+blowfish.BlockSize], plaintext[i:i+blowfish.BlockSize])
        }</span>
        <span class="cov4" title="8">return ciphertext, nil</span>
}

// BlowfishDecryptECB  Blowfish  ECB 
// ECB 
func BlowfishDecryptECB(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="12">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov5" title="10">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="9">if len(ciphertext)%blowfish.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov4" title="8">plaintext := make([]byte, len(ciphertext))
        for i := 0; i &lt; len(ciphertext); i += blowfish.BlockSize </span><span class="cov10" title="130">{
                block.Decrypt(plaintext[i:i+blowfish.BlockSize], ciphertext[i:i+blowfish.BlockSize])
        }</span>
        <span class="cov4" title="8">return unpadPKCS7(plaintext)</span>
}

// BlowfishEncryptCBC  Blowfish  CBC 
func BlowfishEncryptCBC(key, plaintext []byte) ([]byte, error) <span class="cov5" title="12">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov5" title="10">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="9">plaintext = padPKCS7(plaintext, blowfish.BlockSize)
        ciphertext := make([]byte, blowfish.BlockSize+len(plaintext))
        iv := ciphertext[:blowfish.BlockSize]
        _, err = io.ReadFull(blowfishRandReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="8">mode := cipher.NewCBCEncrypter(block, iv)
        mode.CryptBlocks(ciphertext[blowfish.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// BlowfishDecryptCBC  Blowfish  CBC 
func BlowfishDecryptCBC(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="13">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov5" title="11">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="10">if len(ciphertext) &lt; blowfish.BlockSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov5" title="9">iv := ciphertext[:blowfish.BlockSize]
        ciphertext = ciphertext[blowfish.BlockSize:]

        if len(ciphertext)%blowfish.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov4" title="8">mode := cipher.NewCBCDecrypter(block, iv)
        mode.CryptBlocks(ciphertext, ciphertext)

        return unpadPKCS7(ciphertext)</span>
}

// BlowfishEncryptCFB  Blowfish  CFB 
func BlowfishEncryptCFB(key, plaintext []byte) ([]byte, error) <span class="cov5" title="10">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov4" title="8">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="7">ciphertext := make([]byte, blowfish.BlockSize+len(plaintext))
        iv := ciphertext[:blowfish.BlockSize]
        _, err = io.ReadFull(blowfishRandReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="6">stream := cipher.NewCFBEncrypter(block, iv)
        stream.XORKeyStream(ciphertext[blowfish.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// BlowfishDecryptCFB  Blowfish  CFB 
func BlowfishDecryptCFB(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="10">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov4" title="8">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="7">if len(ciphertext) &lt; blowfish.BlockSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov4" title="6">iv := ciphertext[:blowfish.BlockSize]
        ciphertext = ciphertext[blowfish.BlockSize:]

        stream := cipher.NewCFBDecrypter(block, iv)
        stream.XORKeyStream(ciphertext, ciphertext)
        return ciphertext, nil</span>
}

// BlowfishEncryptOFB  Blowfish  OFB 
func BlowfishEncryptOFB(key, plaintext []byte) ([]byte, error) <span class="cov5" title="10">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov4" title="8">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="7">ciphertext := make([]byte, blowfish.BlockSize+len(plaintext))
        iv := ciphertext[:blowfish.BlockSize]
        _, err = io.ReadFull(blowfishRandReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="6">stream := cipher.NewOFB(block, iv)
        stream.XORKeyStream(ciphertext[blowfish.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// BlowfishDecryptOFB  Blowfish  OFB 
func BlowfishDecryptOFB(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="10">{
        if len(key) &lt; 1 || len(key) &gt; 56 </span><span class="cov2" title="2">{
                return nil, errors.New("invalid key length: must be between 1 and 56 bytes for Blowfish")
        }</span>

        <span class="cov4" title="8">block, err := blowfishNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="7">if len(ciphertext) &lt; blowfish.BlockSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov4" title="6">iv := ciphertext[:blowfish.BlockSize]
        ciphertext = ciphertext[blowfish.BlockSize:]

        stream := cipher.NewOFB(block, iv)
        stream.XORKeyStream(ciphertext, ciphertext)
        return ciphertext, nil</span>
}</pre>
		
		<pre class="file" id="file89" style="display: none">package cryptox

import (
        "crypto/rand"
        "errors"
        "io"

        "golang.org/x/crypto/chacha20"
        "golang.org/x/crypto/chacha20poly1305"
)

// Global variables for dependency injection during testing
var (
        chacha20NewUnauthenticatedCipher = chacha20.NewUnauthenticatedCipher
        chacha20poly1305New              = chacha20poly1305.New
        chacha20RandReader               = rand.Reader
)

// ChaCha20Encrypt  ChaCha20 
func ChaCha20Encrypt(key, plaintext []byte) ([]byte, error) <span class="cov8" title="6">{
        if len(key) != chacha20.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20")
        }</span>

        // Generate random nonce
        <span class="cov7" title="5">nonce := make([]byte, chacha20.NonceSize)
        _, err := io.ReadFull(chacha20RandReader, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="4">cipher, err := chacha20NewUnauthenticatedCipher(key, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="3">ciphertext := make([]byte, chacha20.NonceSize+len(plaintext))
        copy(ciphertext[:chacha20.NonceSize], nonce)
        
        cipher.XORKeyStream(ciphertext[chacha20.NonceSize:], plaintext)
        return ciphertext, nil</span>
}

// ChaCha20Decrypt  ChaCha20 
func ChaCha20Decrypt(key, ciphertext []byte) ([]byte, error) <span class="cov8" title="6">{
        if len(key) != chacha20.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20")
        }</span>

        <span class="cov7" title="5">if len(ciphertext) &lt; chacha20.NonceSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov6" title="4">nonce := ciphertext[:chacha20.NonceSize]
        ciphertext = ciphertext[chacha20.NonceSize:]

        cipher, err := chacha20NewUnauthenticatedCipher(key, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="3">plaintext := make([]byte, len(ciphertext))
        cipher.XORKeyStream(plaintext, ciphertext)
        return plaintext, nil</span>
}

// ChaCha20Poly1305Encrypt  ChaCha20-Poly1305 AEAD 
func ChaCha20Poly1305Encrypt(key, plaintext []byte) ([]byte, error) <span class="cov9" title="8">{
        if len(key) != chacha20poly1305.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20-Poly1305")
        }</span>

        <span class="cov8" title="7">aead, err := chacha20poly1305New(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Generate random nonce
        <span class="cov8" title="6">nonce := make([]byte, aead.NonceSize())
        _, err = io.ReadFull(chacha20RandReader, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Seal encrypts and authenticates plaintext
        <span class="cov7" title="5">ciphertext := aead.Seal(nonce, nonce, plaintext, nil)
        return ciphertext, nil</span>
}

// ChaCha20Poly1305Decrypt  ChaCha20-Poly1305 AEAD 
func ChaCha20Poly1305Decrypt(key, ciphertext []byte) ([]byte, error) <span class="cov9" title="8">{
        if len(key) != chacha20poly1305.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20-Poly1305")
        }</span>

        <span class="cov8" title="7">aead, err := chacha20poly1305New(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="6">if len(ciphertext) &lt; aead.NonceSize() </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov7" title="5">nonce := ciphertext[:aead.NonceSize()]
        ciphertext = ciphertext[aead.NonceSize():]

        // Open decrypts and verifies ciphertext
        plaintext, err := aead.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="3">return plaintext, nil</span>
}

// ChaCha20WithNonce  nonce  ChaCha20 
func ChaCha20WithNonce(key, nonce, plaintext []byte) ([]byte, error) <span class="cov10" title="10">{
        if len(key) != chacha20.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20")
        }</span>

        <span class="cov9" title="9">if len(nonce) != chacha20.NonceSize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid nonce length: must be 12 bytes for ChaCha20")
        }</span>

        <span class="cov9" title="8">cipher, err := chacha20NewUnauthenticatedCipher(key, nonce)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="7">ciphertext := make([]byte, len(plaintext))
        cipher.XORKeyStream(ciphertext, plaintext)
        return ciphertext, nil</span>
}

// ChaCha20Poly1305WithNonce  nonce  ChaCha20-Poly1305 
func ChaCha20Poly1305WithNonce(key, nonce, plaintext []byte) ([]byte, error) <span class="cov6" title="4">{
        if len(key) != chacha20poly1305.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20-Poly1305")
        }</span>

        <span class="cov5" title="3">aead, err := chacha20poly1305New(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">if len(nonce) != aead.NonceSize() </span><span class="cov1" title="1">{
                return nil, errors.New("invalid nonce length: must be 12 bytes for ChaCha20-Poly1305")
        }</span>

        // Seal encrypts and authenticates plaintext
        <span class="cov1" title="1">ciphertext := aead.Seal(nil, nonce, plaintext, nil)
        return ciphertext, nil</span>
}

// ChaCha20Poly1305WithNonceDecrypt  nonce  ChaCha20-Poly1305 
func ChaCha20Poly1305WithNonceDecrypt(key, nonce, ciphertext []byte) ([]byte, error) <span class="cov8" title="7">{
        if len(key) != chacha20poly1305.KeySize </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 32 bytes for ChaCha20-Poly1305")
        }</span>

        <span class="cov8" title="6">aead, err := chacha20poly1305New(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="5">if len(nonce) != aead.NonceSize() </span><span class="cov1" title="1">{
                return nil, errors.New("invalid nonce length: must be 12 bytes for ChaCha20-Poly1305")
        }</span>

        // Open decrypts and verifies ciphertext
        <span class="cov6" title="4">plaintext, err := aead.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov5" title="3">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return plaintext, nil</span>
}</pre>
		
		<pre class="file" id="file90" style="display: none">package cryptox

import (
        "crypto/cipher"
        "crypto/des"
        "crypto/rand"
        "errors"
        "io"
)

// Global variables for dependency injection during testing
var (
        desNewCipher    = des.NewCipher
        desNewTripleDES = des.NewTripleDESCipher
        desRandReader   = rand.Reader
)

// DESEncryptECB  DES  ECB 
// DES  AES
// ECB 
func DESEncryptECB(key, plaintext []byte) ([]byte, error) <span class="cov4" title="6">{
        if len(key) != 8 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 8 bytes for DES")
        }</span>

        <span class="cov4" title="5">block, err := desNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="4">plaintext = padPKCS7(plaintext, des.BlockSize)
        ciphertext := make([]byte, len(plaintext))
        for i := 0; i &lt; len(plaintext); i += des.BlockSize </span><span class="cov10" title="100">{
                block.Encrypt(ciphertext[i:i+des.BlockSize], plaintext[i:i+des.BlockSize])
        }</span>
        <span class="cov3" title="4">return ciphertext, nil</span>
}

// DESDecryptECB  DES  ECB 
// DES  AES
// ECB 
func DESDecryptECB(key, ciphertext []byte) ([]byte, error) <span class="cov4" title="7">{
        if len(key) != 8 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 8 bytes for DES")
        }</span>

        <span class="cov4" title="6">block, err := desNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="5">if len(ciphertext)%des.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov3" title="4">plaintext := make([]byte, len(ciphertext))
        for i := 0; i &lt; len(ciphertext); i += des.BlockSize </span><span class="cov10" title="100">{
                block.Decrypt(plaintext[i:i+des.BlockSize], ciphertext[i:i+des.BlockSize])
        }</span>
        <span class="cov3" title="4">return unpadPKCS7(plaintext)</span>
}

// DESEncryptCBC  DES  CBC 
// DES  AES
func DESEncryptCBC(key, plaintext []byte) ([]byte, error) <span class="cov4" title="7">{
        if len(key) != 8 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 8 bytes for DES")
        }</span>

        <span class="cov4" title="6">block, err := desNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="5">plaintext = padPKCS7(plaintext, des.BlockSize)
        ciphertext := make([]byte, des.BlockSize+len(plaintext))
        iv := ciphertext[:des.BlockSize]
        _, err = io.ReadFull(desRandReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="4">mode := cipher.NewCBCEncrypter(block, iv)
        mode.CryptBlocks(ciphertext[des.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// DESDecryptCBC  DES  CBC 
// DES  AES
func DESDecryptCBC(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="8">{
        if len(key) != 8 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 8 bytes for DES")
        }</span>

        <span class="cov4" title="7">block, err := desNewCipher(key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="6">if len(ciphertext) &lt; des.BlockSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov4" title="5">iv := ciphertext[:des.BlockSize]
        ciphertext = ciphertext[des.BlockSize:]

        if len(ciphertext)%des.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov3" title="4">mode := cipher.NewCBCDecrypter(block, iv)
        mode.CryptBlocks(ciphertext, ciphertext)

        return unpadPKCS7(ciphertext)</span>
}

// TripleDESEncryptECB  3DES  ECB 
// ECB 
func TripleDESEncryptECB(key, plaintext []byte) ([]byte, error) <span class="cov4" title="6">{
        if len(key) != 24 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 24 bytes for 3DES")
        }</span>

        <span class="cov4" title="5">block, err := desNewTripleDES(key)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov3" title="3">plaintext = padPKCS7(plaintext, des.BlockSize)
        ciphertext := make([]byte, len(plaintext))
        for i := 0; i &lt; len(plaintext); i += des.BlockSize </span><span class="cov5" title="8">{
                block.Encrypt(ciphertext[i:i+des.BlockSize], plaintext[i:i+des.BlockSize])
        }</span>
        <span class="cov3" title="3">return ciphertext, nil</span>
}

// TripleDESDecryptECB  3DES  ECB 
// ECB 
func TripleDESDecryptECB(key, ciphertext []byte) ([]byte, error) <span class="cov4" title="7">{
        if len(key) != 24 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 24 bytes for 3DES")
        }</span>

        <span class="cov4" title="6">block, err := desNewTripleDES(key)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov3" title="4">if len(ciphertext)%des.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov3" title="3">plaintext := make([]byte, len(ciphertext))
        for i := 0; i &lt; len(ciphertext); i += des.BlockSize </span><span class="cov5" title="8">{
                block.Decrypt(plaintext[i:i+des.BlockSize], ciphertext[i:i+des.BlockSize])
        }</span>
        <span class="cov3" title="3">return unpadPKCS7(plaintext)</span>
}

// TripleDESEncryptCBC  3DES  CBC 
func TripleDESEncryptCBC(key, plaintext []byte) ([]byte, error) <span class="cov4" title="7">{
        if len(key) != 24 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 24 bytes for 3DES")
        }</span>

        <span class="cov4" title="6">block, err := desNewTripleDES(key)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov3" title="4">plaintext = padPKCS7(plaintext, des.BlockSize)
        ciphertext := make([]byte, des.BlockSize+len(plaintext))
        iv := ciphertext[:des.BlockSize]
        _, err = io.ReadFull(desRandReader, iv)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="3">mode := cipher.NewCBCEncrypter(block, iv)
        mode.CryptBlocks(ciphertext[des.BlockSize:], plaintext)
        return ciphertext, nil</span>
}

// TripleDESDecryptCBC  3DES  CBC 
func TripleDESDecryptCBC(key, ciphertext []byte) ([]byte, error) <span class="cov5" title="8">{
        if len(key) != 24 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid key length: must be 24 bytes for 3DES")
        }</span>

        <span class="cov4" title="7">block, err := desNewTripleDES(key)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="5">if len(ciphertext) &lt; des.BlockSize </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov3" title="4">iv := ciphertext[:des.BlockSize]
        ciphertext = ciphertext[des.BlockSize:]

        if len(ciphertext)%des.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, errors.New("ciphertext is not a multiple of the block size")
        }</span>

        <span class="cov3" title="3">mode := cipher.NewCBCDecrypter(block, iv)
        mode.CryptBlocks(ciphertext, ciphertext)

        return unpadPKCS7(ciphertext)</span>
}</pre>
		
		<pre class="file" id="file91" style="display: none">package cryptox

import (
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/sha256"
        "errors"
        "fmt"
        "hash"
        "math/big"
)

// Global variables for dependency injection during testing
var (
        ecdhRandReader = rand.Reader
)

// ECDHKeyPair represents an ECDH key pair (same as ECDSA but used for key exchange)
type ECDHKeyPair struct {
        PrivateKey *ecdsa.PrivateKey
        PublicKey  *ecdsa.PublicKey
}

// GenerateECDHKey  ECDH 
func GenerateECDHKey(curve elliptic.Curve) (*ECDHKeyPair, error) <span class="cov10" title="636">{
        if curve == nil </span><span class="cov1" title="1">{
                return nil, errors.New("curve cannot be nil")
        }</span>

        <span class="cov9" title="635">privateKey, err := ecdsa.GenerateKey(curve, ecdhRandReader)
        if err != nil </span><span class="cov2" title="4">{
                return nil, fmt.Errorf("failed to generate ECDH key: %w", err)
        }</span>

        <span class="cov9" title="631">return &amp;ECDHKeyPair{
                PrivateKey: privateKey,
                PublicKey:  &amp;privateKey.PublicKey,
        }, nil</span>
}

// GenerateECDHP256Key  P-256 ECDH 
func GenerateECDHP256Key() (*ECDHKeyPair, error) <span class="cov9" title="559">{
        return GenerateECDHKey(elliptic.P256())
}</span>

// GenerateECDHP384Key  P-384 ECDH 
func GenerateECDHP384Key() (*ECDHKeyPair, error) <span class="cov6" title="60">{
        return GenerateECDHKey(elliptic.P384())
}</span>

// GenerateECDHP521Key  P-521 ECDH 
func GenerateECDHP521Key() (*ECDHKeyPair, error) <span class="cov2" title="3">{
        return GenerateECDHKey(elliptic.P521())
}</span>

// ECDHComputeShared  ECDH 
func ECDHComputeShared(privateKey *ecdsa.PrivateKey, publicKey *ecdsa.PublicKey) ([]byte, error) <span class="cov9" title="572">{
        if privateKey == nil </span><span class="cov1" title="2">{
                return nil, errors.New("private key cannot be nil")
        }</span>
        <span class="cov9" title="570">if publicKey == nil </span><span class="cov1" title="2">{
                return nil, errors.New("public key cannot be nil")
        }</span>

        // 
        <span class="cov9" title="568">if !privateKey.Curve.IsOnCurve(publicKey.X, publicKey.Y) </span><span class="cov4" title="14">{
                return nil, errors.New("public key is not on the curve")
        }</span>

        // 
        <span class="cov9" title="554">if privateKey.Curve != publicKey.Curve </span><span class="cov1" title="1">{
                return nil, errors.New("curve mismatch between private and public keys")
        }</span>

        // 
        <span class="cov9" title="553">x, _ := privateKey.Curve.ScalarMult(publicKey.X, publicKey.Y, privateKey.D.Bytes())

        //  x 
        return x.Bytes(), nil</span>
}

// ECDHComputeSharedWithKDF  ECDH  KDF 
func ECDHComputeSharedWithKDF(privateKey *ecdsa.PrivateKey, publicKey *ecdsa.PublicKey, keyLength int, kdf func() hash.Hash) ([]byte, error) <span class="cov6" title="43">{
        if keyLength &lt;= 0 </span><span class="cov2" title="3">{
                return nil, errors.New("key length must be greater than 0")
        }</span>
        <span class="cov6" title="40">if kdf == nil </span><span class="cov1" title="2">{
                return nil, errors.New("KDF function cannot be nil")
        }</span>

        <span class="cov6" title="38">sharedSecret, err := ECDHComputeShared(privateKey, publicKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        //  KDF (Hash-based)
        <span class="cov6" title="37">h := kdf()
        h.Write(sharedSecret)
        derivedKey := h.Sum(nil)

        // 
        if len(derivedKey) &gt;= keyLength </span><span class="cov5" title="22">{
                return derivedKey[:keyLength], nil
        }</span>

        // 
        <span class="cov4" title="15">result := make([]byte, 0, keyLength)
        counter := uint32(0)
        
        for len(result) &lt; keyLength </span><span class="cov6" title="56">{
                h := kdf()
                h.Write(sharedSecret)
                h.Write([]byte{byte(counter &gt;&gt; 24), byte(counter &gt;&gt; 16), byte(counter &gt;&gt; 8), byte(counter)})
                block := h.Sum(nil)
                result = append(result, block...)
                counter++
        }</span>

        <span class="cov4" title="15">return result[:keyLength], nil</span>
}

// ECDHComputeSharedSHA256  SHA256 KDF  ECDH 
func ECDHComputeSharedSHA256(privateKey *ecdsa.PrivateKey, publicKey *ecdsa.PublicKey, keyLength int) ([]byte, error) <span class="cov3" title="7">{
        return ECDHComputeSharedWithKDF(privateKey, publicKey, keyLength, sha256.New)
}</span>

// ECDHKeyExchange  ECDH 
func ECDHKeyExchange(alicePrivateKey *ecdsa.PrivateKey, bobPublicKey *ecdsa.PublicKey, keyLength int) ([]byte, error) <span class="cov3" title="5">{
        return ECDHComputeSharedSHA256(alicePrivateKey, bobPublicKey, keyLength)
}</span>

// ValidateECDHKeyPair  ECDH 
func ValidateECDHKeyPair(keyPair *ECDHKeyPair) error <span class="cov5" title="19">{
        if keyPair == nil </span><span class="cov1" title="2">{
                return errors.New("key pair cannot be nil")
        }</span>
        <span class="cov4" title="17">if keyPair.PrivateKey == nil </span><span class="cov1" title="2">{
                return errors.New("private key cannot be nil")
        }</span>
        <span class="cov4" title="15">if keyPair.PublicKey == nil </span><span class="cov1" title="2">{
                return errors.New("public key cannot be nil")
        }</span>

        // 
        <span class="cov4" title="13">if !keyPair.PrivateKey.Curve.IsOnCurve(keyPair.PublicKey.X, keyPair.PublicKey.Y) </span><span class="cov2" title="3">{
                return errors.New("public key is not on the curve")
        }</span>

        // 
        <span class="cov4" title="10">if keyPair.PrivateKey.Curve != keyPair.PublicKey.Curve </span><span class="cov1" title="1">{
                return errors.New("curve mismatch between private and public keys")
        }</span>

        // 
        <span class="cov4" title="9">expectedX, expectedY := keyPair.PrivateKey.Curve.ScalarBaseMult(keyPair.PrivateKey.D.Bytes())
        if keyPair.PublicKey.X.Cmp(expectedX) != 0 || keyPair.PublicKey.Y.Cmp(expectedY) != 0 </span><span class="cov2" title="3">{
                return errors.New("public key does not match private key")
        }</span>

        <span class="cov3" title="6">return nil</span>
}

// ECDHPublicKeyFromCoordinates  x, y  ECDH 
func ECDHPublicKeyFromCoordinates(curve elliptic.Curve, x, y *big.Int) (*ecdsa.PublicKey, error) <span class="cov3" title="6">{
        if curve == nil </span><span class="cov1" title="1">{
                return nil, errors.New("curve cannot be nil")
        }</span>
        <span class="cov3" title="5">if x == nil || y == nil </span><span class="cov1" title="2">{
                return nil, errors.New("coordinates cannot be nil")
        }</span>

        // 
        <span class="cov2" title="3">if !curve.IsOnCurve(x, y) </span><span class="cov1" title="1">{
                return nil, errors.New("point is not on the curve")
        }</span>

        <span class="cov1" title="2">return &amp;ecdsa.PublicKey{
                Curve: curve,
                X:     new(big.Int).Set(x),
                Y:     new(big.Int).Set(y),
        }, nil</span>
}

// ECDHPublicKeyToCoordinates  ECDH  x, y 
func ECDHPublicKeyToCoordinates(publicKey *ecdsa.PublicKey) (x, y *big.Int, err error) <span class="cov2" title="3">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return nil, nil, errors.New("public key cannot be nil")
        }</span>

        <span class="cov1" title="2">return new(big.Int).Set(publicKey.X), new(big.Int).Set(publicKey.Y), nil</span>
}

// ECDHSharedSecretTest 
func ECDHSharedSecretTest(keyPair1, keyPair2 *ECDHKeyPair) (bool, error) <span class="cov5" title="31">{
        if keyPair1 == nil || keyPair2 == nil </span><span class="cov2" title="4">{
                return false, errors.New("key pairs cannot be nil")
        }</span>

        // Alice  Bob 
        <span class="cov5" title="27">secret1, err := ECDHComputeShared(keyPair1.PrivateKey, keyPair2.PublicKey)
        if err != nil </span><span class="cov2" title="4">{
                return false, err
        }</span>

        // Bob  Alice 
        <span class="cov5" title="23">secret2, err := ECDHComputeShared(keyPair2.PrivateKey, keyPair1.PublicKey)
        if err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>

        // 
        <span class="cov5" title="22">if len(secret1) != len(secret2) </span><span class="cov1" title="1">{
                return false, nil
        }</span>

        <span class="cov5" title="21">for i := 0; i &lt; len(secret1); i++ </span><span class="cov9" title="610">{
                if secret1[i] != secret2[i] </span><span class="cov1" title="2">{
                        return false, nil
                }</span>
        }

        <span class="cov5" title="19">return true, nil</span>
}</pre>
		
		<pre class="file" id="file92" style="display: none">package cryptox

import (
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/sha256"
        "crypto/sha512"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "hash"
        "math/big"
)

// Global variables for dependency injection during testing
var (
        ecdsaRandReader = rand.Reader
)

// ECDSAKeyPair represents an ECDSA key pair
type ECDSAKeyPair struct {
        PrivateKey *ecdsa.PrivateKey
        PublicKey  *ecdsa.PublicKey
}

// GenerateECDSAKey  ECDSA 
func GenerateECDSAKey(curve elliptic.Curve) (*ECDSAKeyPair, error) <span class="cov10" title="31">{
        if curve == nil </span><span class="cov1" title="1">{
                return nil, errors.New("curve cannot be nil")
        }</span>

        <span class="cov9" title="30">privateKey, err := ecdsa.GenerateKey(curve, ecdsaRandReader)
        if err != nil </span><span class="cov4" title="4">{
                return nil, fmt.Errorf("failed to generate ECDSA key: %w", err)
        }</span>

        <span class="cov9" title="26">return &amp;ECDSAKeyPair{
                PrivateKey: privateKey,
                PublicKey:  &amp;privateKey.PublicKey,
        }, nil</span>
}

// GenerateECDSAP256Key  P-256 (secp256r1) ECDSA 
func GenerateECDSAP256Key() (*ECDSAKeyPair, error) <span class="cov8" title="20">{
        return GenerateECDSAKey(elliptic.P256())
}</span>

// GenerateECDSAP384Key  P-384 (secp384r1) ECDSA 
func GenerateECDSAP384Key() (*ECDSAKeyPair, error) <span class="cov3" title="3">{
        return GenerateECDSAKey(elliptic.P384())
}</span>

// GenerateECDSAP521Key  P-521 (secp521r1) ECDSA 
func GenerateECDSAP521Key() (*ECDSAKeyPair, error) <span class="cov2" title="2">{
        return GenerateECDSAKey(elliptic.P521())
}</span>

// ECDSASign  ECDSA 
func ECDSASign(privateKey *ecdsa.PrivateKey, data []byte, hashFunc func() hash.Hash) (r, s *big.Int, err error) <span class="cov8" title="21">{
        if privateKey == nil </span><span class="cov1" title="1">{
                return nil, nil, errors.New("private key cannot be nil")
        }</span>
        <span class="cov8" title="20">if hashFunc == nil </span><span class="cov1" title="1">{
                return nil, nil, errors.New("hash function cannot be nil")
        }</span>

        <span class="cov8" title="19">h := hashFunc()
        h.Write(data)
        hashed := h.Sum(nil)

        return ecdsa.Sign(ecdsaRandReader, privateKey, hashed)</span>
}

// ECDSASignSHA256  SHA256  ECDSA 
func ECDSASignSHA256(privateKey *ecdsa.PrivateKey, data []byte) (r, s *big.Int, err error) <span class="cov7" title="14">{
        return ECDSASign(privateKey, data, sha256.New)
}</span>

// ECDSASignSHA512  SHA512  ECDSA 
func ECDSASignSHA512(privateKey *ecdsa.PrivateKey, data []byte) (r, s *big.Int, err error) <span class="cov2" title="2">{
        return ECDSASign(privateKey, data, sha512.New)
}</span>

// ECDSAVerify  ECDSA 
func ECDSAVerify(publicKey *ecdsa.PublicKey, data []byte, r, s *big.Int, hashFunc func() hash.Hash) bool <span class="cov9" title="22">{
        if publicKey == nil || r == nil || s == nil || hashFunc == nil </span><span class="cov4" title="4">{
                return false
        }</span>

        <span class="cov8" title="18">h := hashFunc()
        h.Write(data)
        hashed := h.Sum(nil)

        return ecdsa.Verify(publicKey, hashed, r, s)</span>
}

// ECDSAVerifySHA256  SHA256  ECDSA 
func ECDSAVerifySHA256(publicKey *ecdsa.PublicKey, data []byte, r, s *big.Int) bool <span class="cov7" title="14">{
        return ECDSAVerify(publicKey, data, r, s, sha256.New)
}</span>

// ECDSAVerifySHA512  SHA512  ECDSA 
func ECDSAVerifySHA512(publicKey *ecdsa.PublicKey, data []byte, r, s *big.Int) bool <span class="cov1" title="1">{
        return ECDSAVerify(publicKey, data, r, s, sha512.New)
}</span>

// ECDSAPrivateKeyToPEM  ECDSA  PEM 
func ECDSAPrivateKeyToPEM(privateKey *ecdsa.PrivateKey) ([]byte, error) <span class="cov7" title="13">{
        if privateKey == nil </span><span class="cov2" title="2">{
                return nil, errors.New("private key cannot be nil")
        }</span>

        <span class="cov7" title="11">x509Encoded, err := x509.MarshalECPrivateKey(privateKey)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to marshal private key: %w", err)
        }</span>

        <span class="cov6" title="9">pemEncoded := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "EC PRIVATE KEY",
                Bytes: x509Encoded,
        })

        return pemEncoded, nil</span>
}

// ECDSAPrivateKeyFromPEM  PEM  ECDSA 
func ECDSAPrivateKeyFromPEM(pemData []byte) (*ecdsa.PrivateKey, error) <span class="cov8" title="15">{
        if len(pemData) == 0 </span><span class="cov2" title="2">{
                return nil, errors.New("PEM data cannot be empty")
        }</span>

        <span class="cov7" title="13">block, _ := pem.Decode(pemData)
        if block == nil </span><span class="cov3" title="3">{
                return nil, errors.New("failed to decode PEM block")
        }</span>

        <span class="cov7" title="10">if block.Type != "EC PRIVATE KEY" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid PEM block type: expected 'EC PRIVATE KEY', got '%s'", block.Type)
        }</span>

        <span class="cov6" title="9">privateKey, err := x509.ParseECPrivateKey(block.Bytes)
        if err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to parse EC private key: %w", err)
        }</span>

        <span class="cov5" title="6">return privateKey, nil</span>
}

// ECDSAPublicKeyToPEM  ECDSA  PEM 
func ECDSAPublicKeyToPEM(publicKey *ecdsa.PublicKey) ([]byte, error) <span class="cov7" title="11">{
        if publicKey == nil </span><span class="cov2" title="2">{
                return nil, errors.New("public key cannot be nil")
        }</span>

        <span class="cov6" title="9">x509Encoded, err := x509.MarshalPKIXPublicKey(publicKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to marshal public key: %w", err)
        }</span>

        <span class="cov6" title="8">pemEncoded := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: x509Encoded,
        })

        return pemEncoded, nil</span>
}

// ECDSAPublicKeyFromPEM  PEM  ECDSA 
func ECDSAPublicKeyFromPEM(pemData []byte) (*ecdsa.PublicKey, error) <span class="cov8" title="17">{
        if len(pemData) == 0 </span><span class="cov1" title="1">{
                return nil, errors.New("PEM data cannot be empty")
        }</span>

        <span class="cov8" title="16">block, _ := pem.Decode(pemData)
        if block == nil </span><span class="cov5" title="5">{
                return nil, errors.New("failed to decode PEM block")
        }</span>

        <span class="cov7" title="11">if block.Type != "PUBLIC KEY" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid PEM block type: expected 'PUBLIC KEY', got '%s'", block.Type)
        }</span>

        <span class="cov7" title="10">publicKeyInterface, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        <span class="cov6" title="7">publicKey, ok := publicKeyInterface.(*ecdsa.PublicKey)
        if !ok </span><span class="cov1" title="1">{
                return nil, errors.New("not an ECDSA public key")
        }</span>

        <span class="cov5" title="6">return publicKey, nil</span>
}

// ECDSASignature represents an ECDSA signature
type ECDSASignature struct {
        R *big.Int
        S *big.Int
}

// ECDSASignatureToBytes  ECDSA DER 
func ECDSASignatureToBytes(r, s *big.Int) ([]byte, error) <span class="cov6" title="9">{
        if r == nil || s == nil </span><span class="cov2" title="2">{
                return nil, errors.New("signature components cannot be nil")
        }</span>

        //  DER 
        <span class="cov6" title="7">rBytes := r.Bytes()
        sBytes := s.Bytes()

        // 10x00
        if len(rBytes) &gt; 0 &amp;&amp; rBytes[0]&amp;0x80 != 0 </span><span class="cov4" title="4">{
                rBytes = append([]byte{0x00}, rBytes...)
        }</span>
        <span class="cov6" title="7">if len(sBytes) &gt; 0 &amp;&amp; sBytes[0]&amp;0x80 != 0 </span><span class="cov5" title="6">{
                sBytes = append([]byte{0x00}, sBytes...)
        }</span>

        //  DER 
        <span class="cov6" title="7">rDER := append([]byte{0x02, byte(len(rBytes))}, rBytes...)
        sDER := append([]byte{0x02, byte(len(sBytes))}, sBytes...)
        
        signature := append(rDER, sDER...)
        derEncoded := append([]byte{0x30, byte(len(signature))}, signature...)

        return derEncoded, nil</span>
}

// ECDSASignatureFromBytes  ECDSA DER 
func ECDSASignatureFromBytes(data []byte) (r, s *big.Int, err error) <span class="cov9" title="29">{
        if len(data) &lt; 6 </span><span class="cov7" title="13">{
                return nil, nil, errors.New("signature data too short")
        }</span>

        //  DER 
        <span class="cov8" title="16">if data[0] != 0x30 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("invalid DER signature: missing SEQUENCE tag")
        }</span>

        <span class="cov8" title="15">seqLen := int(data[1])
        if len(data) &lt; seqLen+2 </span><span class="cov4" title="4">{
                return nil, nil, errors.New("invalid DER signature: incorrect sequence length")
        }</span>

        <span class="cov7" title="11">data = data[2:] //  SEQUENCE 

        //  r
        if len(data) &lt; 2 || data[0] != 0x02 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("invalid DER signature: missing INTEGER tag for r")
        }</span>

        <span class="cov7" title="10">rLen := int(data[1])
        if len(data) &lt; rLen+2 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("invalid DER signature: incorrect r length")
        }</span>

        <span class="cov6" title="9">rBytes := data[2 : 2+rLen]
        r = new(big.Int).SetBytes(rBytes)
        data = data[2+rLen:]

        //  s
        if len(data) &lt; 2 || data[0] != 0x02 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("invalid DER signature: missing INTEGER tag for s")
        }</span>

        <span class="cov6" title="8">sLen := int(data[1])
        if len(data) &lt; sLen+2 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("invalid DER signature: incorrect s length")
        }</span>

        <span class="cov6" title="7">sBytes := data[2 : 2+sLen]
        s = new(big.Int).SetBytes(sBytes)

        return r, s, nil</span>
}

// GetCurveName 
func GetCurveName(curve elliptic.Curve) string <span class="cov7" title="10">{
        switch curve </span>{
        case elliptic.P224():<span class="cov2" title="2">
                return "P-224"</span>
        case elliptic.P256():<span class="cov2" title="2">
                return "P-256"</span>
        case elliptic.P384():<span class="cov2" title="2">
                return "P-384"</span>
        case elliptic.P521():<span class="cov2" title="2">
                return "P-521"</span>
        default:<span class="cov2" title="2">
                return "Unknown"</span>
        }
}

// IsValidCurve 
func IsValidCurve(curve elliptic.Curve) bool <span class="cov7" title="10">{
        switch curve </span>{
        case elliptic.P224(), elliptic.P256(), elliptic.P384(), elliptic.P521():<span class="cov6" title="8">
                return true</span>
        default:<span class="cov2" title="2">
                return false</span>
        }
}</pre>
		
		<pre class="file" id="file93" style="display: none">package cryptox

import (
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "fmt"
        "golang.org/x/crypto/ripemd160"
)

// Md5  MD5 
func Md5[M string | []byte](s M) string <span class="cov10" title="6">{
        return fmt.Sprintf("%x", md5.Sum([]byte(s)))
}</span>

// SHA1  SHA1 
// SHA1 
func SHA1[M string | []byte](s M) string <span class="cov7" title="4">{
        return fmt.Sprintf("%x", sha1.Sum([]byte(s)))
}</span>

// Sha224  SHA-224 
func Sha224[M string | []byte](s M) string <span class="cov1" title="1">{
        return fmt.Sprintf("%x", sha256.Sum224([]byte(s)))
}</span>

// Sha256  SHA-256 
func Sha256[M string | []byte](s M) string <span class="cov9" title="5">{
        return fmt.Sprintf("%x", sha256.Sum256([]byte(s)))
}</span>

// Sha384  SHA-384 
func Sha384[M string | []byte](s M) string <span class="cov1" title="1">{
        return fmt.Sprintf("%x", sha512.Sum384([]byte(s)))
}</span>

// Sha512  SHA-512 
func Sha512[M string | []byte](s M) string <span class="cov1" title="1">{
        return fmt.Sprintf("%x", sha512.Sum512([]byte(s)))
}</span>

// Sha512_224  SHA-512/224 
func Sha512_224[M string | []byte](s M) string <span class="cov1" title="1">{
        return fmt.Sprintf("%x", sha512.Sum512_224([]byte(s)))
}</span>

// Sha512_256  SHA-512/256 
func Sha512_256[M string | []byte](s M) string <span class="cov1" title="1">{
        return fmt.Sprintf("%x", sha512.Sum512_256([]byte(s)))
}</span>

// RIPEMD160  RIPEMD-160 
func RIPEMD160[M string | []byte](s M) string <span class="cov7" title="4">{
        h := ripemd160.New()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</pre>
		
		<pre class="file" id="file94" style="display: none">package cryptox

import (
        "fmt"
        "golang.org/x/crypto/blake2b"
        "golang.org/x/crypto/blake2s"
)

// Global variables for dependency injection during testing
var (
        blake2bNew    = blake2b.New
        blake2sNew256 = blake2s.New256
)

// BLAKE2b  BLAKE2b 
func BLAKE2b[M string | []byte](s M, size int) (string, error) <span class="cov9" title="69">{
        if size &lt;= 0 </span><span class="cov2" title="2">{
                return "", fmt.Errorf("size must be greater than 0")
        }</span>
        <span class="cov9" title="67">var key []byte
        h, err := blake2b.New(size, key)
        if err != nil </span><span class="cov2" title="2">{
                return "", fmt.Errorf("failed to create BLAKE2b hash: %w", err)
        }</span>
        <span class="cov9" title="65">_, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil)), nil</span>
}

// BLAKE2s  BLAKE2s 256
// BLAKE2s 256size
func BLAKE2s[M string | []byte](s M, size int) (string, error) <span class="cov9" title="71">{
        if size &lt;= 0 </span><span class="cov3" title="4">{
                return "", fmt.Errorf("size must be greater than 0")
        }</span>
        <span class="cov9" title="67">var key []byte
        h, err := blake2sNew256(key)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to create BLAKE2s hash: %w", err)
        }</span>
        <span class="cov9" title="66">_, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil)), nil</span>
}

// BLAKE2b512  BLAKE2b-512 
func BLAKE2b512[M string | []byte](s M) string <span class="cov3" title="4">{
        h, _ := blake2b.New512(nil)
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// BLAKE2b256  BLAKE2b-256 
func BLAKE2b256[M string | []byte](s M) string <span class="cov3" title="4">{
        h, _ := blake2b.New256(nil)
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// BLAKE2s256  BLAKE2s-256 
func BLAKE2s256[M string | []byte](s M) string <span class="cov3" title="4">{
        h, _ := blake2s.New256(nil)
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// BLAKE2bWithKey  BLAKE2b 
func BLAKE2bWithKey[M string | []byte](s M, key []byte, size int) (string, error) <span class="cov10" title="72">{
        if size &lt;= 0 || size &gt; 64 </span><span class="cov4" title="5">{
                return "", fmt.Errorf("size must be between 1 and 64 bytes")
        }</span>
        <span class="cov9" title="67">h, err := blake2bNew(size, key)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to create BLAKE2b hash with key: %w", err)
        }</span>
        <span class="cov9" title="66">_, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil)), nil</span>
}

// BLAKE2sWithKey  BLAKE2s 256
func BLAKE2sWithKey[M string | []byte](s M, key []byte) (string, error) <span class="cov8" title="35">{
        h, err := blake2sNew256(key)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to create BLAKE2s hash with key: %w", err)
        }</span>
        <span class="cov8" title="34">_, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil)), nil</span>
}</pre>
		
		<pre class="file" id="file95" style="display: none">package cryptox

import (
        "hash/crc32"
        "hash/crc64"
)

// CRC32  CRC32 
func CRC32[M string | []byte](s M) uint32 <span class="cov10" title="4">{
        return crc32.ChecksumIEEE([]byte(s))
}</span>

// CRC64  CRC64 
func CRC64[M string | []byte](s M) uint64 <span class="cov10" title="4">{
        table := crc64.MakeTable(crc64.ECMA)
        return crc64.Checksum([]byte(s), table)
}</pre>
		
		<pre class="file" id="file96" style="display: none">package cryptox

import (
        "hash/fnv"
)

// Hash32  FNV-1  32 
func Hash32[M string | []byte](s M) uint32 <span class="cov10" title="4">{
        h := fnv.New32()
        _, _ = h.Write([]byte(s))
        return h.Sum32()
}</span>

// Hash32a  FNV-1a  32 
func Hash32a[M string | []byte](s M) uint32 <span class="cov10" title="4">{
        h := fnv.New32a()
        _, _ = h.Write([]byte(s))
        return h.Sum32()
}</span>

// Hash64  FNV-1  64 
func Hash64[M string | []byte](s M) uint64 <span class="cov10" title="4">{
        h := fnv.New64()
        _, _ = h.Write([]byte(s))
        return h.Sum64()
}</span>

// Hash64a  FNV-1a  64 
func Hash64a[M string | []byte](s M) uint64 <span class="cov10" title="4">{
        h := fnv.New64a()
        _, _ = h.Write([]byte(s))
        return h.Sum64()
}</pre>
		
		<pre class="file" id="file97" style="display: none">package cryptox

import (
        "crypto/hmac"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "fmt"
)

// HMACMd5  MD5  HMAC 
func HMACMd5[M string | []byte](key, message M) string <span class="cov10" title="4">{
        h := hmac.New(md5.New, []byte(key))
        _, _ = h.Write([]byte(message))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// HMACSHA1  SHA1  HMAC 
func HMACSHA1[M string | []byte](key, message M) string <span class="cov10" title="4">{
        h := hmac.New(sha1.New, []byte(key))
        _, _ = h.Write([]byte(message))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// HMACSHA256  SHA256  HMAC 
func HMACSHA256[M string | []byte](key, message M) string <span class="cov10" title="4">{
        h := hmac.New(sha256.New, []byte(key))
        _, _ = h.Write([]byte(message))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// HMACSHA384  SHA384  HMAC 
func HMACSHA384[M string | []byte](key, message M) string <span class="cov10" title="4">{
        h := hmac.New(sha512.New384, []byte(key))
        _, _ = h.Write([]byte(message))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// HMACSHA512  SHA512  HMAC 
func HMACSHA512[M string | []byte](key, message M) string <span class="cov10" title="4">{
        h := hmac.New(sha512.New, []byte(key))
        _, _ = h.Write([]byte(message))
        return fmt.Sprintf("%x", h.Sum(nil))
}</pre>
		
		<pre class="file" id="file98" style="display: none">package cryptox

import (
        "fmt"
        "golang.org/x/crypto/sha3"
)

// SHA3_224  SHA3-224 
func SHA3_224[M string | []byte](s M) string <span class="cov3" title="3">{
        h := sha3.New224()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// SHA3_256  SHA3-256 
func SHA3_256[M string | []byte](s M) string <span class="cov3" title="3">{
        h := sha3.New256()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// SHA3_384  SHA3-384 
func SHA3_384[M string | []byte](s M) string <span class="cov3" title="3">{
        h := sha3.New384()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// SHA3_512  SHA3-512 
func SHA3_512[M string | []byte](s M) string <span class="cov3" title="3">{
        h := sha3.New512()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// SHAKE128  SHAKE128 
func SHAKE128[M string | []byte](s M, size int) (string, error) <span class="cov10" title="107">{
        if size &lt;= 0 </span><span class="cov3" title="4">{
                return "", fmt.Errorf("size must be greater than 0")
        }</span>
        <span class="cov9" title="103">h := sha3.NewShake128()
        _, _ = h.Write([]byte(s))
        buf := make([]byte, size)
        _, _ = h.Read(buf)
        return fmt.Sprintf("%x", buf), nil</span>
}

// SHAKE256  SHAKE256 
func SHAKE256[M string | []byte](s M, size int) (string, error) <span class="cov10" title="107">{
        if size &lt;= 0 </span><span class="cov3" title="4">{
                return "", fmt.Errorf("size must be greater than 0")
        }</span>
        <span class="cov9" title="103">h := sha3.NewShake256()
        _, _ = h.Write([]byte(s))
        buf := make([]byte, size)
        _, _ = h.Read(buf)
        return fmt.Sprintf("%x", buf), nil</span>
}

// Keccak256  Keccak-256 
//  Keccak NIST  SHA3
func Keccak256[M string | []byte](s M) string <span class="cov3" title="4">{
        h := sha3.NewLegacyKeccak256()
        _, _ = h.Write([]byte(s))
        return fmt.Sprintf("%x", h.Sum(nil))
}</pre>
		
		<pre class="file" id="file99" style="display: none">package cryptox

import (
        "crypto/hmac"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "fmt"
        "golang.org/x/crypto/sha3"
        "hash"
)

// hmacEncode  HMAC 
func hmacEncode(key, data string, h func() hash.Hash) string <span class="cov10" title="10">{
        sha := hmac.New(h, []byte(key))
        sha.Write([]byte(data))
        return fmt.Sprintf("%x", sha.Sum(nil))
}</span>

// HmacMd5  MD5  HMAC 
func HmacMd5(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, md5.New)
}</span>

// HmacSha1  SHA-1  HMAC 
func HmacSha1(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha1.New)
}</span>

// HmacSha256  SHA-256  HMAC 
func HmacSha256(key, data string) string <span class="cov3" title="2">{
        return hmacEncode(key, data, sha256.New)
}</span>

// HmacSha224  SHA-224  HMAC 
func HmacSha224(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha256.New224)
}</span>

// HmacSha512  SHA-512  HMAC 
func HmacSha512(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha512.New)
}</span>

// HmacSha384  SHA-384  HMAC 
func HmacSha384(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha512.New384)
}</span>

// HmacSha3_256  SHA3-256  HMAC 
func HmacSha3_256(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha3.New256)
}</span>

// HmacSha3_384  SHA3-384  HMAC 
func HmacSha3_384(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha3.New384)
}</span>

// HmacSha3_512  SHA3-512  HMAC 
func HmacSha3_512(key, data string) string <span class="cov1" title="1">{
        return hmacEncode(key, data, sha3.New512)
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package cryptox

import (
        "crypto/rand"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "errors"
        "fmt"
        "io"

        "golang.org/x/crypto/argon2"
        "golang.org/x/crypto/pbkdf2"
        "golang.org/x/crypto/scrypt"
)

// Global variables for dependency injection during testing
var (
        kdfRandReader = rand.Reader
)

// PBKDF2WithSHA256  PBKDF2  SHA256 
func PBKDF2WithSHA256(password, salt []byte, iterations, keyLength int) []byte <span class="cov5" title="38">{
        return pbkdf2.Key(password, salt, iterations, keyLength, sha256.New)
}</span>

// PBKDF2WithSHA1  PBKDF2  SHA1 
// SHA1 
func PBKDF2WithSHA1(password, salt []byte, iterations, keyLength int) []byte <span class="cov1" title="2">{
        return pbkdf2.Key(password, salt, iterations, keyLength, sha1.New)
}</span>

// PBKDF2WithSHA512  PBKDF2  SHA512 
func PBKDF2WithSHA512(password, salt []byte, iterations, keyLength int) []byte <span class="cov1" title="2">{
        return pbkdf2.Key(password, salt, iterations, keyLength, sha512.New)
}</span>

// PBKDF2Config PBKDF2 
type PBKDF2Config struct {
        SaltLength int // 
        Iterations int // 
        KeyLength  int // 
}

// DefaultPBKDF2Config  PBKDF2 
func DefaultPBKDF2Config() PBKDF2Config <span class="cov3" title="8">{
        return PBKDF2Config{
                SaltLength: 16,     // 128
                Iterations: 100000, // 10
                KeyLength:  32,     // 256
        }
}</span>

// PBKDF2Generate  PBKDF2-SHA256 
func PBKDF2Generate(password string, config PBKDF2Config) (key, salt []byte, err error) <span class="cov5" title="26">{
        if config.SaltLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("salt length must be greater than 0")
        }</span>
        <span class="cov4" title="25">if config.Iterations &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("iterations must be greater than 0")
        }</span>
        <span class="cov4" title="24">if config.KeyLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("key length must be greater than 0")
        }</span>

        <span class="cov4" title="23">salt = make([]byte, config.SaltLength)
        _, err = io.ReadFull(kdfRandReader, salt)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov4" title="22">key = PBKDF2WithSHA256([]byte(password), salt, config.Iterations, config.KeyLength)
        return key, salt, nil</span>
}

// PBKDF2Verify 
func PBKDF2Verify(password string, key, salt []byte, config PBKDF2Config) bool <span class="cov4" title="13">{
        derivedKey := PBKDF2WithSHA256([]byte(password), salt, config.Iterations, config.KeyLength)
        return len(key) == len(derivedKey) &amp;&amp; constantTimeCompare(key, derivedKey)
}</span>

// ScryptConfig Scrypt 
type ScryptConfig struct {
        SaltLength int // 
        N          int // CPU/2
        R          int // 
        P          int // 
        KeyLength  int // 
}

// DefaultScryptConfig  Scrypt 
func DefaultScryptConfig() ScryptConfig <span class="cov3" title="8">{
        return ScryptConfig{
                SaltLength: 16,    // 128
                N:          32768, // 2^15, 
                R:          8,     // 
                P:          1,     // 
                KeyLength:  32,    // 256
        }
}</span>

// ScryptDerive  Scrypt 
func ScryptDerive(password, salt []byte, config ScryptConfig) ([]byte, error) <span class="cov4" title="24">{
        if config.N &lt;= 0 || (config.N&amp;(config.N-1)) != 0 </span><span class="cov2" title="4">{
                return nil, errors.New("N must be a positive power of 2")
        }</span>
        <span class="cov4" title="20">if config.R &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("R must be greater than 0")
        }</span>
        <span class="cov4" title="19">if config.P &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("P must be greater than 0")
        }</span>
        <span class="cov4" title="18">if config.KeyLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("key length must be greater than 0")
        }</span>

        <span class="cov4" title="17">return scrypt.Key(password, salt, config.N, config.R, config.P, config.KeyLength)</span>
}

// ScryptGenerate  Scrypt 
func ScryptGenerate(password string, config ScryptConfig) (key, salt []byte, err error) <span class="cov4" title="15">{
        if config.SaltLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("salt length must be greater than 0")
        }</span>

        <span class="cov4" title="14">salt = make([]byte, config.SaltLength)
        _, err = io.ReadFull(kdfRandReader, salt)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov4" title="13">key, err = ScryptDerive([]byte(password), salt, config)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("scrypt derivation failed: %w", err)
        }</span>

        <span class="cov4" title="12">return key, salt, nil</span>
}

// ScryptVerify 
func ScryptVerify(password string, key, salt []byte, config ScryptConfig) bool <span class="cov2" title="4">{
        derivedKey, err := ScryptDerive([]byte(password), salt, config)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov2" title="3">return len(key) == len(derivedKey) &amp;&amp; constantTimeCompare(key, derivedKey)</span>
}

// Argon2Config Argon2 
type Argon2Config struct {
        SaltLength int    // 
        Time       uint32 // 
        Memory     uint32 // KB
        Threads    uint8  // 
        KeyLength  int    // 
}

// DefaultArgon2Config  Argon2 
func DefaultArgon2Config() Argon2Config <span class="cov3" title="8">{
        return Argon2Config{
                SaltLength: 16,      // 128
                Time:       1,       // 1
                Memory:     64 * 1024, // 64MB 
                Threads:    4,       // 4
                KeyLength:  32,      // 256
        }
}</span>

// Argon2IDDerive  Argon2id 
func Argon2IDDerive(password, salt []byte, config Argon2Config) []byte <span class="cov4" title="16">{
        return argon2.IDKey(password, salt, config.Time, config.Memory, config.Threads, uint32(config.KeyLength))
}</span>

// Argon2IDerive  Argon2i 
func Argon2IDerive(password, salt []byte, config Argon2Config) []byte <span class="cov1" title="2">{
        return argon2.Key(password, salt, config.Time, config.Memory, config.Threads, uint32(config.KeyLength))
}</span>

// Argon2Generate  Argon2id 
func Argon2Generate(password string, config Argon2Config) (key, salt []byte, err error) <span class="cov4" title="16">{
        if config.SaltLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("salt length must be greater than 0")
        }</span>
        <span class="cov4" title="15">if config.Time == 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("time parameter must be greater than 0")
        }</span>
        <span class="cov4" title="14">if config.Memory == 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("memory parameter must be greater than 0")
        }</span>
        <span class="cov4" title="13">if config.Threads == 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("threads parameter must be greater than 0")
        }</span>
        <span class="cov4" title="12">if config.KeyLength &lt;= 0 </span><span class="cov1" title="1">{
                return nil, nil, errors.New("key length must be greater than 0")
        }</span>

        <span class="cov3" title="11">salt = make([]byte, config.SaltLength)
        _, err = io.ReadFull(kdfRandReader, salt)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov3" title="10">key = Argon2IDDerive([]byte(password), salt, config)
        return key, salt, nil</span>
}

// Argon2Verify 
func Argon2Verify(password string, key, salt []byte, config Argon2Config) bool <span class="cov2" title="3">{
        derivedKey := Argon2IDDerive([]byte(password), salt, config)
        return len(key) == len(derivedKey) &amp;&amp; constantTimeCompare(key, derivedKey)
}</span>

// constantTimeCompare 
func constantTimeCompare(a, b []byte) bool <span class="cov5" title="57">{
        if len(a) != len(b) </span><span class="cov1" title="2">{
                return false
        }</span>
        
        <span class="cov5" title="55">var result byte
        for i := 0; i &lt; len(a); i++ </span><span class="cov10" title="1482">{
                result |= a[i] ^ b[i]
        }</span>
        <span class="cov5" title="55">return result == 0</span>
}

// GenerateSalt 
func GenerateSalt(length int) ([]byte, error) <span class="cov3" title="11">{
        if length &lt;= 0 </span><span class="cov1" title="2">{
                return nil, errors.New("salt length must be greater than 0")
        }</span>
        
        <span class="cov3" title="9">salt := make([]byte, length)
        _, err := io.ReadFull(kdfRandReader, salt)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to generate salt: %w", err)
        }</span>
        
        <span class="cov3" title="8">return salt, nil</span>
}</pre>
		
		<pre class="file" id="file101" style="display: none">package cryptox

import (
        "crypto"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
)

// Global variables for dependency injection during testing
var (
        rsaGenerateKey    = rsa.GenerateKey
        rsaEncryptOAEP    = rsa.EncryptOAEP
        rsaEncryptPKCS1v15 = rsa.EncryptPKCS1v15
        rsaDecryptOAEP    = rsa.DecryptOAEP
        rsaDecryptPKCS1v15 = rsa.DecryptPKCS1v15
        rsaSignPSS        = rsa.SignPSS
        rsaSignPKCS1v15   = rsa.SignPKCS1v15
        rsaVerifyPSS      = rsa.VerifyPSS
        rsaVerifyPKCS1v15 = rsa.VerifyPKCS1v15
        rsaRandReader     = rand.Reader
)

// RSAKeyPair  RSA 
type RSAKeyPair struct {
        PrivateKey *rsa.PrivateKey
        PublicKey  *rsa.PublicKey
}

// GenerateRSAKeyPair  RSA 
// keySize:  20483072  4096 
func GenerateRSAKeyPair(keySize int) (*RSAKeyPair, error) <span class="cov10" title="25">{
        if keySize &lt; 1024 </span><span class="cov1" title="1">{
                return nil, errors.New("RSA key size must be at least 1024 bits")
        }</span>

        <span class="cov9" title="24">privateKey, err := rsaGenerateKey(rsaRandReader, keySize)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to generate RSA key pair: %w", err)
        }</span>

        <span class="cov9" title="23">return &amp;RSAKeyPair{
                PrivateKey: privateKey,
                PublicKey:  &amp;privateKey.PublicKey,
        }, nil</span>
}

// PrivateKeyToPEM  PEM 
func (kp *RSAKeyPair) PrivateKeyToPEM() ([]byte, error) <span class="cov7" title="11">{
        if kp.PrivateKey == nil </span><span class="cov4" title="3">{
                return nil, errors.New("private key is nil")
        }</span>

        <span class="cov6" title="8">privateKeyBytes, err := x509.MarshalPKCS8PrivateKey(kp.PrivateKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to marshal private key: %w", err)
        }</span>

        <span class="cov6" title="7">privateKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PRIVATE KEY",
                Bytes: privateKeyBytes,
        })

        return privateKeyPEM, nil</span>
}

// PublicKeyToPEM  PEM 
func (kp *RSAKeyPair) PublicKeyToPEM() ([]byte, error) <span class="cov9" title="18">{
        if kp.PublicKey == nil </span><span class="cov4" title="3">{
                return nil, errors.New("public key is nil")
        }</span>

        <span class="cov8" title="15">publicKeyBytes, err := x509.MarshalPKIXPublicKey(kp.PublicKey)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to marshal public key: %w", err)
        }</span>

        <span class="cov8" title="14">publicKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: publicKeyBytes,
        })

        return publicKeyPEM, nil</span>
}

// PrivateKeyFromPEM  PEM 
func PrivateKeyFromPEM(pemData []byte) (*rsa.PrivateKey, error) <span class="cov9" title="20">{
        block, _ := pem.Decode(pemData)
        if block == nil </span><span class="cov6" title="8">{
                return nil, errors.New("failed to decode PEM block")
        }</span>

        <span class="cov7" title="12">if block.Type != "PRIVATE KEY" &amp;&amp; block.Type != "RSA PRIVATE KEY" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid PEM block type: %s", block.Type)
        }</span>

        <span class="cov7" title="11">var privateKey *rsa.PrivateKey
        var err error

        if block.Type == "PRIVATE KEY" </span><span class="cov7" title="10">{
                // PKCS#8 format
                key, err := x509.ParsePKCS8PrivateKey(block.Bytes)
                if err != nil </span><span class="cov4" title="4">{
                        return nil, fmt.Errorf("failed to parse PKCS8 private key: %w", err)
                }</span>
                
                <span class="cov6" title="6">var ok bool
                privateKey, ok = key.(*rsa.PrivateKey)
                if !ok </span><span class="cov1" title="1">{
                        return nil, errors.New("key is not an RSA private key")
                }</span>
        } else<span class="cov1" title="1"> {
                // PKCS#1 format
                privateKey, err = x509.ParsePKCS1PrivateKey(block.Bytes)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to parse PKCS1 private key: %w", err)
                }</span>
        }

        <span class="cov5" title="5">return privateKey, nil</span>
}

// PublicKeyFromPEM  PEM 
func PublicKeyFromPEM(pemData []byte) (*rsa.PublicKey, error) <span class="cov9" title="19">{
        block, _ := pem.Decode(pemData)
        if block == nil </span><span class="cov6" title="7">{
                return nil, errors.New("failed to decode PEM block")
        }</span>

        <span class="cov7" title="12">if block.Type != "PUBLIC KEY" &amp;&amp; block.Type != "RSA PUBLIC KEY" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid PEM block type: %s", block.Type)
        }</span>

        <span class="cov7" title="11">var publicKey *rsa.PublicKey
        var err error

        if block.Type == "PUBLIC KEY" </span><span class="cov7" title="10">{
                // PKIX format
                key, err := x509.ParsePKIXPublicKey(block.Bytes)
                if err != nil </span><span class="cov4" title="4">{
                        return nil, fmt.Errorf("failed to parse PKIX public key: %w", err)
                }</span>
                
                <span class="cov6" title="6">var ok bool
                publicKey, ok = key.(*rsa.PublicKey)
                if !ok </span><span class="cov1" title="1">{
                        return nil, errors.New("key is not an RSA public key")
                }</span>
        } else<span class="cov1" title="1"> {
                // PKCS#1 format
                publicKey, err = x509.ParsePKCS1PublicKey(block.Bytes)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to parse PKCS1 public key: %w", err)
                }</span>
        }

        <span class="cov5" title="5">return publicKey, nil</span>
}

// RSAEncryptOAEP  OAEP  RSA 
func RSAEncryptOAEP(publicKey *rsa.PublicKey, plaintext []byte) ([]byte, error) <span class="cov7" title="10">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("public key is nil")
        }</span>

        <span class="cov7" title="9">hash := sha256.New()
        ciphertext, err := rsaEncryptOAEP(hash, rsaRandReader, publicKey, plaintext, nil)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("RSA OAEP encryption failed: %w", err)
        }</span>

        <span class="cov6" title="7">return ciphertext, nil</span>
}

// RSADecryptOAEP  OAEP  RSA 
func RSADecryptOAEP(privateKey *rsa.PrivateKey, ciphertext []byte) ([]byte, error) <span class="cov6" title="8">{
        if privateKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("private key is nil")
        }</span>

        <span class="cov6" title="7">hash := sha256.New()
        plaintext, err := rsaDecryptOAEP(hash, rsaRandReader, privateKey, ciphertext, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("RSA OAEP decryption failed: %w", err)
        }</span>

        <span class="cov6" title="6">return plaintext, nil</span>
}

// RSAEncryptPKCS1v15  PKCS1v15  RSA 
func RSAEncryptPKCS1v15(publicKey *rsa.PublicKey, plaintext []byte) ([]byte, error) <span class="cov5" title="5">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("public key is nil")
        }</span>

        <span class="cov4" title="4">ciphertext, err := rsaEncryptPKCS1v15(rsaRandReader, publicKey, plaintext)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("RSA PKCS1v15 encryption failed: %w", err)
        }</span>

        <span class="cov4" title="3">return ciphertext, nil</span>
}

// RSADecryptPKCS1v15  PKCS1v15  RSA 
func RSADecryptPKCS1v15(privateKey *rsa.PrivateKey, ciphertext []byte) ([]byte, error) <span class="cov4" title="4">{
        if privateKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("private key is nil")
        }</span>

        <span class="cov4" title="3">plaintext, err := rsaDecryptPKCS1v15(rsaRandReader, privateKey, ciphertext)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("RSA PKCS1v15 decryption failed: %w", err)
        }</span>

        <span class="cov2" title="2">return plaintext, nil</span>
}

// RSASignPSS  PSS 
func RSASignPSS(privateKey *rsa.PrivateKey, message []byte) ([]byte, error) <span class="cov4" title="4">{
        if privateKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("private key is nil")
        }</span>

        <span class="cov4" title="3">hash := sha256.Sum256(message)
        signature, err := rsaSignPSS(rsaRandReader, privateKey, crypto.SHA256, hash[:], nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("RSA PSS signing failed: %w", err)
        }</span>

        <span class="cov2" title="2">return signature, nil</span>
}

// RSAVerifyPSS  PSS 
func RSAVerifyPSS(publicKey *rsa.PublicKey, message []byte, signature []byte) error <span class="cov4" title="4">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return errors.New("public key is nil")
        }</span>

        <span class="cov4" title="3">hash := sha256.Sum256(message)
        err := rsaVerifyPSS(publicKey, crypto.SHA256, hash[:], signature, nil)
        if err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("RSA PSS signature verification failed: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// RSASignPKCS1v15  PKCS1v15 
func RSASignPKCS1v15(privateKey *rsa.PrivateKey, message []byte) ([]byte, error) <span class="cov4" title="4">{
        if privateKey == nil </span><span class="cov1" title="1">{
                return nil, errors.New("private key is nil")
        }</span>

        <span class="cov4" title="3">hash := sha256.Sum256(message)
        signature, err := rsaSignPKCS1v15(rsaRandReader, privateKey, crypto.SHA256, hash[:])
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("RSA PKCS1v15 signing failed: %w", err)
        }</span>

        <span class="cov2" title="2">return signature, nil</span>
}

// RSAVerifyPKCS1v15  PKCS1v15 
func RSAVerifyPKCS1v15(publicKey *rsa.PublicKey, message []byte, signature []byte) error <span class="cov4" title="4">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return errors.New("public key is nil")
        }</span>

        <span class="cov4" title="3">hash := sha256.Sum256(message)
        err := rsaVerifyPKCS1v15(publicKey, crypto.SHA256, hash[:], signature)
        if err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("RSA PKCS1v15 signature verification failed: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetRSAKeySize  RSA 
func GetRSAKeySize(key *rsa.PublicKey) int <span class="cov6" title="7">{
        if key == nil </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov6" title="6">return key.Size() * 8</span>
}

// RSAMaxMessageLength  RSA 
func RSAMaxMessageLength(publicKey *rsa.PublicKey, padding string) (int, error) <span class="cov5" title="5">{
        if publicKey == nil </span><span class="cov1" title="1">{
                return 0, errors.New("public key is nil")
        }</span>

        <span class="cov4" title="4">keySize := publicKey.Size()
        
        switch padding </span>{
        case "OAEP":<span class="cov2" title="2">
                // OAEP: keySize - 2*hashLen - 2 (SHA256 hash length is 32 bytes)
                return keySize - 2*32 - 2, nil</span>
        case "PKCS1v15":<span class="cov1" title="1">
                // PKCS1v15: keySize - 11
                return keySize - 11, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unsupported padding: %s", padding)</span>
        }
}</pre>
		
		<pre class="file" id="file102" style="display: none">package cryptox

import (
        "github.com/google/uuid"
        "strings"
)

func UUID() string <span class="cov10" title="3">{
        return strings.ReplaceAll(uuid.NewString(), "-", "")
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">package defaults

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"
)

// DefaultFunc 
type DefaultFunc func() interface{}

// Options 
type Options struct {
        // ErrorMode 
        ErrorMode ErrorMode
        // CustomDefaults 
        CustomDefaults map[string]DefaultFunc
        // ValidateDefaults 
        ValidateDefaults bool
        // AllowOverwrite 
        AllowOverwrite bool
}

// ErrorMode 
type ErrorMode int

const (
        // ErrorModePanic  panic
        ErrorModePanic ErrorMode = iota
        // ErrorModeIgnore 
        ErrorModeIgnore
        // ErrorModeReturn 
        ErrorModeReturn
)

var (
        // 
        defaultOptions = &amp;Options{
                ErrorMode:        ErrorModePanic,
                CustomDefaults:   make(map[string]DefaultFunc),
                ValidateDefaults: false,
                AllowOverwrite:   false,
        }
)

// SetDefaultsWithOptions 
func SetDefaultsWithOptions(value interface{}, opts *Options) error <span class="cov7" title="57">{
        if opts == nil </span><span class="cov1" title="1">{
                opts = defaultOptions
        }</span>
        
        <span class="cov7" title="57">return setDefaultWithOptions(reflect.ValueOf(value), "", opts)</span>
}

// SetDefaults 
func SetDefaults(value interface{}) <span class="cov6" title="30">{
        err := SetDefaultsWithOptions(value, defaultOptions)
        if err != nil </span><span class="cov1" title="1">{
                panic(err)</span>
        }
}

// setDefaultWithOptions 
func setDefaultWithOptions(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov10" title="331">{
        if !vv.IsValid() </span><span class="cov1" title="1">{
                return handleError("invalid reflect value", opts.ErrorMode)
        }</span>

        <span class="cov9" title="330">switch vv.Kind() </span>{
        case reflect.String:<span class="cov6" title="47">
                return setStringDefault(vv, defaultStr, opts)</span>

        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov5" title="24">
                return setUintDefault(vv, defaultStr, opts)</span>

        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov7" title="69">
                return setIntDefault(vv, defaultStr, opts)</span>

        case reflect.Float32, reflect.Float64:<span class="cov5" title="14">
                return setFloatDefault(vv, defaultStr, opts)</span>

        case reflect.Bool:<span class="cov4" title="10">
                return setBoolDefault(vv, defaultStr, opts)</span>

        case reflect.Ptr:<span class="cov7" title="64">
                return setPtrDefault(vv, defaultStr, opts)</span>

        case reflect.Struct:<span class="cov7" title="71">
                return setStructDefault(vv, defaultStr, opts)</span>

        case reflect.Interface:<span class="cov2" title="2">
                return setInterfaceDefault(vv, defaultStr, opts)</span>

        case reflect.Slice:<span class="cov4" title="8">
                return setSliceDefault(vv, defaultStr, opts)</span>

        case reflect.Array:<span class="cov4" title="11">
                return setArrayDefault(vv, defaultStr, opts)</span>

        case reflect.Map:<span class="cov3" title="4">
                return setMapDefault(vv, defaultStr, opts)</span>

        case reflect.Chan:<span class="cov3" title="4">
                return setChanDefault(vv, defaultStr, opts)</span>

        case reflect.Func:<span class="cov1" title="1">
                return setFuncDefault(vv, defaultStr, opts)</span>

        default:<span class="cov1" title="1">
                return handleError(fmt.Sprintf("unsupported kind: %s", vv.Kind().String()), opts.ErrorMode)</span>
        }
}

// setStringDefault 
func setStringDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov6" title="47">{
        if shouldSetValue(vv.String() == "", defaultStr, opts.AllowOverwrite) </span><span class="cov6" title="30">{
                if customFunc, ok := opts.CustomDefaults["string"]; ok </span><span class="cov3" title="5">{
                        if val := customFunc(); val != nil </span><span class="cov3" title="4">{
                                if strVal, ok := val.(string); ok </span><span class="cov2" title="3">{
                                        vv.SetString(strVal)
                                }</span>
                        }
                } else<span class="cov5" title="25"> if defaultStr != "" </span><span class="cov5" title="25">{
                        vv.SetString(defaultStr)
                }</span>
        }
        <span class="cov6" title="47">return nil</span>
}

// setUintDefault 
func setUintDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov5" title="24">{
        if shouldSetValue(vv.Uint() == 0, defaultStr, opts.AllowOverwrite) </span><span class="cov5" title="23">{
                if customFunc, ok := opts.CustomDefaults["uint"]; ok </span><span class="cov2" title="2">{
                        if val := customFunc(); val != nil </span><span class="cov1" title="1">{
                                if uintVal, ok := val.(uint64); ok </span><span class="cov1" title="1">{
                                        vv.SetUint(uintVal)
                                }</span>
                        }
                } else<span class="cov5" title="21"> if defaultStr != "" </span><span class="cov5" title="21">{
                        val, err := strconv.ParseUint(defaultStr, 10, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                return handleError(fmt.Sprintf("invalid default value for uint field: %s", defaultStr), opts.ErrorMode)
                        }</span>
                        <span class="cov5" title="20">vv.SetUint(val)</span>
                }
        }
        <span class="cov5" title="23">return nil</span>
}

// setIntDefault 
func setIntDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov7" title="69">{
        if shouldSetValue(vv.Int() == 0, defaultStr, opts.AllowOverwrite) </span><span class="cov7" title="51">{
                if customFunc, ok := opts.CustomDefaults["int"]; ok </span><span class="cov1" title="1">{
                        if val := customFunc(); val != nil </span><span class="cov1" title="1">{
                                if intVal, ok := val.(int64); ok </span><span class="cov1" title="1">{
                                        vv.SetInt(intVal)
                                }</span>
                        }
                } else<span class="cov7" title="50"> if defaultStr != "" </span><span class="cov7" title="50">{
                        val, err := strconv.ParseInt(defaultStr, 10, 64)
                        if err != nil </span><span class="cov4" title="11">{
                                return handleError(fmt.Sprintf("invalid default value for int field: %s", defaultStr), opts.ErrorMode)
                        }</span>
                        <span class="cov6" title="39">vv.SetInt(val)</span>
                }
        }
        <span class="cov7" title="58">return nil</span>
}

// setFloatDefault 
func setFloatDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov5" title="14">{
        if shouldSetValue(vv.Float() == 0, defaultStr, opts.AllowOverwrite) </span><span class="cov4" title="13">{
                if customFunc, ok := opts.CustomDefaults["float"]; ok </span><span class="cov2" title="2">{
                        if val := customFunc(); val != nil </span><span class="cov2" title="2">{
                                if floatVal, ok := val.(float64); ok </span><span class="cov1" title="1">{
                                        vv.SetFloat(floatVal)
                                }</span>
                        }
                } else<span class="cov4" title="11"> if defaultStr != "" </span><span class="cov4" title="11">{
                        val, err := strconv.ParseFloat(defaultStr, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                return handleError(fmt.Sprintf("invalid default value for float field: %s", defaultStr), opts.ErrorMode)
                        }</span>
                        <span class="cov4" title="10">vv.SetFloat(val)</span>
                }
        }
        <span class="cov4" title="13">return nil</span>
}

// setBoolDefault 
func setBoolDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov4" title="10">{
        if shouldSetValue(vv.Bool() == false, defaultStr, opts.AllowOverwrite) </span><span class="cov4" title="9">{
                if customFunc, ok := opts.CustomDefaults["bool"]; ok </span><span class="cov2" title="2">{
                        if val := customFunc(); val != nil </span><span class="cov2" title="2">{
                                if boolVal, ok := val.(bool); ok </span><span class="cov1" title="1">{
                                        vv.SetBool(boolVal)
                                }</span>
                        }
                } else<span class="cov4" title="7"> if defaultStr != "" </span><span class="cov4" title="7">{
                        val, err := strconv.ParseBool(defaultStr)
                        if err != nil </span><span class="cov1" title="1">{
                                return handleError(fmt.Sprintf("invalid default value for bool field: %s", defaultStr), opts.ErrorMode)
                        }</span>
                        <span class="cov3" title="6">vv.SetBool(val)</span>
                }
        }
        <span class="cov4" title="9">return nil</span>
}

// setPtrDefault 
func setPtrDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov7" title="64">{
        if vv.IsNil() </span><span class="cov4" title="8">{
                vv.Set(reflect.New(vv.Type().Elem()))
        }</span>
        
        // 
        <span class="cov7" title="64">for vv.Kind() == reflect.Ptr </span><span class="cov7" title="67">{
                vv = vv.Elem()
                if vv.Kind() == reflect.Ptr &amp;&amp; vv.IsNil() </span><span class="cov2" title="3">{
                        vv.Set(reflect.New(vv.Type().Elem()))
                }</span>
        }
        
        <span class="cov7" title="64">return setDefaultWithOptions(vv, defaultStr, opts)</span>
}

// setStructDefault 
func setStructDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov7" title="71">{
        // 
        if vv.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov3" title="5">{
                return setTimeDefault(vv, defaultStr, opts)
        }</span>

        <span class="cov7" title="66">for i := 0; i &lt; vv.NumField(); i++ </span><span class="cov8" title="153">{
                field := vv.Field(i)
                fieldType := vv.Type().Field(i)

                if !field.CanSet() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov8" title="152">defaultTag := fieldType.Tag.Get("default")
                if err := setDefaultWithOptions(field, defaultTag, opts); err != nil </span><span class="cov5" title="18">{
                        if opts.ErrorMode == ErrorModeReturn </span><span class="cov5" title="18">{
                                return fmt.Errorf("failed to set default for field %s: %w", fieldType.Name, err)
                        }</span>
                }
        }
        <span class="cov6" title="43">return nil</span>
}

// setTimeDefault 
func setTimeDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov3" title="5">{
        if shouldSetValue(vv.Interface().(time.Time).IsZero(), defaultStr, opts.AllowOverwrite) </span><span class="cov3" title="5">{
                if defaultStr == "now" </span><span class="cov1" title="1">{
                        vv.Set(reflect.ValueOf(time.Now()))
                }</span> else<span class="cov3" title="4"> if defaultStr != "" </span><span class="cov3" title="4">{
                        // 
                        layouts := []string{
                                time.RFC3339,
                                time.RFC3339Nano,
                                "2006-01-02 15:04:05",
                                "2006-01-02",
                                "15:04:05",
                        }
                        
                        var t time.Time
                        var err error
                        for _, layout := range layouts </span><span class="cov4" title="13">{
                                t, err = time.Parse(layout, defaultStr)
                                if err == nil </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        
                        <span class="cov3" title="4">if err != nil </span><span class="cov1" title="1">{
                                return handleError(fmt.Sprintf("invalid time format: %s", defaultStr), opts.ErrorMode)
                        }</span>
                        <span class="cov2" title="3">vv.Set(reflect.ValueOf(t))</span>
                }
        }
        <span class="cov3" title="4">return nil</span>
}

// setInterfaceDefault 
func setInterfaceDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov2" title="2">{
        // 
        if defaultStr != "" &amp;&amp; vv.IsNil() </span><span class="cov2" title="2">{
                // 
                if strings.Contains(defaultStr, "{") || strings.Contains(defaultStr, "[") </span><span class="cov1" title="1">{
                        // JSON 
                        var result interface{}
                        if err := json.Unmarshal([]byte(defaultStr), &amp;result); err == nil </span><span class="cov1" title="1">{
                                vv.Set(reflect.ValueOf(result))
                        }</span>
                } else<span class="cov1" title="1"> {
                        // 
                        vv.Set(reflect.ValueOf(defaultStr))
                }</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// setSliceDefault 
func setSliceDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov4" title="8">{
        if vv.IsNil() </span><span class="cov4" title="7">{
                if defaultStr == "" </span><span class="cov1" title="1">{
                        // 
                        vv.Set(reflect.MakeSlice(vv.Type(), 0, 0))
                }</span> else<span class="cov3" title="6"> {
                        // 
                        if err := parseSliceDefault(vv, defaultStr, opts); err != nil </span><span class="cov2" title="2">{
                                return err
                        }</span>
                }
        }
        
        // 
        <span class="cov3" title="6">for i := 0; i &lt; vv.Len(); i++ </span><span class="cov5" title="16">{
                elem := vv.Index(i)
                if elem.CanSet() </span><span class="cov5" title="16">{
                        if err := setDefaultWithOptions(elem, "", opts); err != nil &amp;&amp; opts.ErrorMode == ErrorModeReturn </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
        }
        
        <span class="cov3" title="5">return nil</span>
}

// setArrayDefault 
func setArrayDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov4" title="11">{
        if defaultStr != "" </span><span class="cov4" title="10">{
                if err := parseArrayDefault(vv, defaultStr, opts); err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>
        }
        
        // 
        <span class="cov4" title="9">for i := 0; i &lt; vv.Len(); i++ </span><span class="cov5" title="15">{
                elem := vv.Index(i)
                if elem.CanSet() </span><span class="cov5" title="15">{
                        if err := setDefaultWithOptions(elem, "", opts); err != nil &amp;&amp; opts.ErrorMode == ErrorModeReturn </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
        }
        
        <span class="cov4" title="8">return nil</span>
}

// setMapDefault 
func setMapDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov3" title="4">{
        if vv.IsNil() </span><span class="cov3" title="4">{
                if defaultStr == "" </span><span class="cov1" title="1">{
                        // 
                        vv.Set(reflect.MakeMap(vv.Type()))
                }</span> else<span class="cov2" title="3"> {
                        // 
                        if err := parseMapDefault(vv, defaultStr, opts); err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
        }
        <span class="cov2" title="3">return nil</span>
}

// setChanDefault 
func setChanDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov3" title="4">{
        if vv.IsNil() &amp;&amp; defaultStr != "" </span><span class="cov3" title="4">{
                // 
                bufSize := 0
                if defaultStr != "0" </span><span class="cov2" title="3">{
                        var err error
                        bufSize, err = strconv.Atoi(defaultStr)
                        if err != nil </span><span class="cov1" title="1">{
                                return handleError(fmt.Sprintf("invalid channel buffer size: %s", defaultStr), opts.ErrorMode)
                        }</span>
                }
                <span class="cov2" title="3">vv.Set(reflect.MakeChan(vv.Type(), bufSize))</span>
        }
        <span class="cov2" title="3">return nil</span>
}

// setFuncDefault 
func setFuncDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov1" title="1">{
        // 
        // 
        if customFunc, ok := opts.CustomDefaults["func"]; ok </span><span class="cov1" title="1">{
                if vv.IsNil() </span><span class="cov1" title="1">{
                        if val := customFunc(); val != nil </span><span class="cov1" title="1">{
                                if reflect.TypeOf(val).AssignableTo(vv.Type()) </span><span class="cov1" title="1">{
                                        vv.Set(reflect.ValueOf(val))
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return nil</span>
}

// parseSliceDefault 
func parseSliceDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov3" title="6">{
        //  JSON 
        if strings.HasPrefix(defaultStr, "[") &amp;&amp; strings.HasSuffix(defaultStr, "]") </span><span class="cov2" title="3">{
                // 
                slicePtr := reflect.New(vv.Type())
                if err := json.Unmarshal([]byte(defaultStr), slicePtr.Interface()); err == nil </span><span class="cov2" title="2">{
                        vv.Set(slicePtr.Elem())
                        return nil
                }</span>
        }
        
        // 
        <span class="cov3" title="4">if strings.Contains(defaultStr, ",") </span><span class="cov2" title="3">{
                parts := strings.Split(defaultStr, ",")
                slice := reflect.MakeSlice(vv.Type(), len(parts), len(parts))
                
                for i, part := range parts </span><span class="cov4" title="8">{
                        elem := slice.Index(i)
                        if err := setDefaultWithOptions(elem, strings.TrimSpace(part), opts); err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
                <span class="cov2" title="2">vv.Set(slice)
                return nil</span>
        }
        
        <span class="cov1" title="1">return handleError(fmt.Sprintf("unable to parse slice default: %s", defaultStr), opts.ErrorMode)</span>
}

// parseArrayDefault 
func parseArrayDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov5" title="17">{
        // 
        if strings.HasPrefix(defaultStr, "[") &amp;&amp; strings.HasSuffix(defaultStr, "]") </span><span class="cov2" title="2">{
                arrayPtr := reflect.New(vv.Type())
                if err := json.Unmarshal([]byte(defaultStr), arrayPtr.Interface()); err == nil </span><span class="cov2" title="2">{
                        vv.Set(arrayPtr.Elem())
                        return nil
                }</span>
        }
        
        // 
        <span class="cov5" title="15">if strings.Contains(defaultStr, ",") </span><span class="cov5" title="14">{
                parts := strings.Split(defaultStr, ",")
                maxParts := vv.Len()
                // parts
                // 
                if len(parts) &gt; maxParts &amp;&amp; maxParts &gt; 0 </span><span class="cov3" title="6">{
                        parts = parts[:maxParts]
                }</span>
                
                <span class="cov5" title="14">for i, part := range parts </span><span class="cov5" title="21">{
                        if i &gt;= vv.Len() </span><span class="cov3" title="4">{
                                break</span> // 
                        }
                        <span class="cov5" title="17">elem := vv.Index(i)
                        if err := setDefaultWithOptions(elem, strings.TrimSpace(part), opts); err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
                <span class="cov4" title="13">return nil</span>
        }
        
        <span class="cov1" title="1">return handleError(fmt.Sprintf("unable to parse array default: %s", defaultStr), opts.ErrorMode)</span>
}

// parseMapDefault 
func parseMapDefault(vv reflect.Value, defaultStr string, opts *Options) error <span class="cov2" title="3">{
        //  JSON 
        if strings.HasPrefix(defaultStr, "{") &amp;&amp; strings.HasSuffix(defaultStr, "}") </span><span class="cov2" title="3">{
                mapPtr := reflect.New(vv.Type())
                if err := json.Unmarshal([]byte(defaultStr), mapPtr.Interface()); err == nil </span><span class="cov2" title="2">{
                        vv.Set(mapPtr.Elem())
                        return nil
                }</span>
        }
        
        <span class="cov1" title="1">return handleError(fmt.Sprintf("unable to parse map default: %s", defaultStr), opts.ErrorMode)</span>
}

// shouldSetValue 
func shouldSetValue(isZeroValue bool, defaultStr string, allowOverwrite bool) bool <span class="cov8" title="169">{
        return (isZeroValue || allowOverwrite) &amp;&amp; defaultStr != ""
}</span>

// handleError 
func handleError(msg string, mode ErrorMode) error <span class="cov5" title="21">{
        switch mode </span>{
        case ErrorModePanic:<span class="cov3" title="5">
                panic(msg)</span>
        case ErrorModeIgnore:<span class="cov1" title="1">
                return nil</span>
        case ErrorModeReturn:<span class="cov5" title="14">
                return fmt.Errorf("%s", msg)</span>
        default:<span class="cov1" title="1">
                panic(msg)</span>
        }
}

// RegisterCustomDefault 
func RegisterCustomDefault(typeName string, fn DefaultFunc) <span class="cov4" title="9">{
        if defaultOptions.CustomDefaults == nil </span><span class="cov1" title="1">{
                defaultOptions.CustomDefaults = make(map[string]DefaultFunc)
        }</span>
        <span class="cov4" title="9">defaultOptions.CustomDefaults[typeName] = fn</span>
}

// ClearCustomDefaults 
func ClearCustomDefaults() <span class="cov4" title="9">{
        defaultOptions.CustomDefaults = make(map[string]DefaultFunc)
}</pre>
		
		<pre class="file" id="file104" style="display: none">package event

import (
        "github.com/lazygophers/utils/routine"
        "github.com/lazygophers/utils/runtime"
        "sync"
)

var defaultManager = NewManager()

type EventHandler func(args any)

type eventItem struct {
        handler EventHandler

        async bool
}

type Manager struct {
        eventMux sync.RWMutex
        events   map[string][]*eventItem
        c        chan *emitItem
}

func (p *Manager) register(eventName string, item *eventItem) <span class="cov0" title="0">{
        p.eventMux.Lock()
        defer p.eventMux.Unlock()

        p.events[eventName] = append(p.events[eventName], item)
}</span>

func Register(eventName string, handler EventHandler) <span class="cov0" title="0">{
        defaultManager.Register(eventName, handler)
}</span>

func (p *Manager) Register(eventName string, handler EventHandler) <span class="cov0" title="0">{
        p.register(eventName, &amp;eventItem{
                handler: handler,
        })
}</span>

func RegisterAsync(eventName string, handler EventHandler) <span class="cov0" title="0">{
        defaultManager.RegisterAsync(eventName, handler)
}</span>

func (p *Manager) RegisterAsync(eventName string, handler EventHandler) <span class="cov0" title="0">{
        p.register(eventName, &amp;eventItem{
                handler: handler,
                async:   true,
        })
}</span>

func (p *Manager) getItems(eventName string) []*eventItem <span class="cov0" title="0">{
        p.eventMux.RLock()
        defer p.eventMux.RUnlock()

        return p.events[eventName]
}</span>

func Emit(eventName string, args any) <span class="cov0" title="0">{
        defaultManager.Emit(eventName, args)
}</span>

type emitItem struct {
        handler EventHandler
        args    any
}

func (p *emitItem) do() <span class="cov0" title="0">{
        defer runtime.CachePanic()

        p.handler(p.args)
}</span>

func (p *Manager) Emit(eventName string, args any) <span class="cov0" title="0">{
        for _, event := range p.getItems(eventName) </span><span class="cov0" title="0">{
                if event.async </span><span class="cov0" title="0">{
                        p.c &lt;- &amp;emitItem{
                                handler: event.handler,
                                args:    args,
                        }
                        continue</span>
                }

                <span class="cov0" title="0">event.handler(args)</span>
        }
}

func NewManager() *Manager <span class="cov0" title="0">{
        p := &amp;Manager{
                events: make(map[string][]*eventItem),

                c: make(chan *emitItem, 10),
        }

        routine.GoWithRecover(func() (err error) </span><span class="cov0" title="0">{
                for item := range p.c </span><span class="cov0" title="0">{
                        item.do()
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return p</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package fake

import "github.com/lazygophers/utils/randx"

var userAgents = []string{
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; Moto C Build/NRD90M.059) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-G532M Build/MMB29T; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/55.0.2883.91 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1.1; SM-J120M Build/LMY47X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; Moto G (5) Build/NPPS25.137-93-14) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-G570M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0; CAM-L03 Build/HUAWEICAM-L03) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.44 Safari/534.7",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3",
        "Mozilla/5.0 (Linux; Android 8.0.0; FIG-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.237 Safari/534.10",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36",
        "Mozilla/5.0 (X11; Datanyze; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1.1; SM-J111M Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.107 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-J700M Build/MMB29K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.63 Safari/537.36",
        "Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Slackware/Chrome/12.0.742.100 Safari/534.30",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36",
        "Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 8.0.0; WAS-LX3 Build/HUAWEIWAS-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.1805 Safari/537.36 MVisionPlayer/1.0.0.0",
        "Mozilla/5.0 (Linux; Android 7.0; TRT-LX3 Build/HUAWEITRT-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.89 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0; vivo 1610 Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.124 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 4.4.2; de-de; SAMSUNG GT-I9195 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Version/1.5 Chrome/28.0.1500.94 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 8.0.0; ANE-LX3 Build/HUAWEIANE-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (X11; U; Linux i586; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.65 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-G610M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-J500M Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.44 Safari/534.7",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.104 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0; vivo 1606 Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.124 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-G610M Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.1; vivo 1716 Build/N2G47H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.98 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-G570M Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0; MYA-L22 Build/HUAWEIMYA-L22) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1; A1601 Build/LMY47I) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.98 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; TRT-LX2 Build/HUAWEITRT-LX2; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/59.0.3071.125 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/10.0.649.0 Safari/534.17",
        "Mozilla/5.0 (Linux; Android 6.0; CAM-L21 Build/HUAWEICAM-L21; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.3 Safari/534.24",
        "Mozilla/5.0 (Linux; Android 7.1.2; Redmi 4X Build/N2G47H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 4.4.2; SM-G7102 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.109 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1; HUAWEI CUN-L22 Build/HUAWEICUN-L22; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1.1; A37fw Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-J730GM Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-G610F Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.1.2; Redmi Note 5A Build/N2G47H; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; Redmi Note 4 Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36",
        "Mozilla/5.0 (Unknown; Linux) AppleWebKit/538.1 (KHTML, like Gecko) Chrome/v1.0.0 Safari/538.1",
        "Mozilla/5.0 (Linux; Android 7.0; BLL-L22 Build/HUAWEIBLL-L22) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.91 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.0; SM-J710F Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-G532M Build/MMB29T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.91 Mobile Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.1.1; CPH1723 Build/N6F26Q) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.98 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 8.0.0; FIG-LX3 Build/HUAWEIFIG-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 6.1; de-DE) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/10.0.649.0 Safari/534.17",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.63 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.65 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 7.1; Mi A1 Build/N2G47H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.83 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
        "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36 MVisionPlayer/1.0.0.0",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 5.1; A37f Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.93 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; CPH1607 Build/MMB29M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/63.0.3239.111 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; vivo 1603 Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.83 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-G532M Build/MMB29T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; Redmi 4A Build/MMB29M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/60.0.3112.116 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.157 Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.71 Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36",
        "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0.1; SM-G532G Build/MMB29T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.83 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.109 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.131 Safari/537.36",
        "Mozilla/5.0 (Linux; Android 6.0; vivo 1713 Build/MRA58K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.124 Mobile Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
        "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36"}

func RandomUserAgent() string <span class="cov0" title="0">{
        return randx.Choose(userAgents)
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">package hystrix

import (
        "errors"
        "sync"
        "sync/atomic"
        "time"
        "unsafe"
)

// requestResult 
type requestResult struct {
        success bool
        time    time.Time
}

// State 
type State string

const (
        Closed   State = "closed"    // closed 
        Open     State = "open"      // open 
        HalfOpen State = "half-open" // half-open 
)

// StateChange 
type StateChange func(oldState, newState State)

// ReadyToTrip 
// /
type ReadyToTrip func(successes, failures uint64) bool

// Probe 
// 
type Probe func() bool

// CircuitBreakerConfig 
type CircuitBreakerConfig struct {
        TimeWindow    time.Duration // 
        OnStateChange StateChange   // 
        ReadyToTrip   ReadyToTrip   // 
        Probe         Probe         // 
        BufferSize    int           // 1000
}

// CircuitBreaker 
type CircuitBreaker struct {
        //  ()
        timeWindow    int64 // 
        onStateChange StateChange
        readyToTrip   ReadyToTrip
        probe         Probe
        bufferSize    int

        //  ()
        state atomic.Uint32 // 0=Closed, 1=Open, 2=HalfOpen

        //  ()
        stats struct {
                successes       atomic.Uint64
                _               [56]byte // 
                failures        atomic.Uint64
                _               [56]byte // 
                lastCleanupTime atomic.Int64
                _               [56]byte // 
                changed         atomic.Uint32 // 0=false, 1=true
                _               [60]byte // 
        }

        // 
        ringBuffer *optimizedRingBuffer
}

// optimizedRingBuffer 
type optimizedRingBuffer struct {
        // 
        buffer []int64 // 32()32+
        _      [56]byte
        head   atomic.Uint64
        _      [56]byte
        tail   atomic.Uint64
        _      [56]byte
        size   uint64
        mask   uint64 // size-1
}

const (
        stateClosedOpt   = 0
        stateOpenOpt     = 1
        stateHalfOpenOpt = 2

        // 
        successFlag = 0x01
        timeShift   = 32
)

// NewCircuitBreaker 
func NewCircuitBreaker(c CircuitBreakerConfig) *CircuitBreaker <span class="cov5" title="11">{
        if c.Probe == nil </span><span class="cov5" title="11">{
                c.Probe = ProbeWithChance(50)
        }</span>

        <span class="cov5" title="11">if c.ReadyToTrip == nil </span><span class="cov5" title="9">{
                c.ReadyToTrip = func(successes, failures uint64) bool </span><span class="cov3" title="3">{
                        total := successes + failures
                        return total &gt;= 10 &amp;&amp; failures &gt; successes
                }</span>
        }

        <span class="cov5" title="11">if c.BufferSize &lt;= 0 </span><span class="cov5" title="11">{
                c.BufferSize = 1000
        }</span>

        //  BufferSize 2
        <span class="cov5" title="11">bufferSize := 1
        for bufferSize &lt; c.BufferSize </span><span class="cov10" title="110">{
                bufferSize &lt;&lt;= 1
        }</span>

        <span class="cov5" title="11">cb := &amp;CircuitBreaker{
                timeWindow:    c.TimeWindow.Nanoseconds(),
                onStateChange: c.OnStateChange,
                readyToTrip:   c.ReadyToTrip,
                probe:         c.Probe,
                bufferSize:    bufferSize,
                ringBuffer:    newOptimizedRingBuffer(bufferSize),
        }

        cb.state.Store(stateClosedOpt)
        cb.stats.changed.Store(1)
        cb.stats.lastCleanupTime.Store(time.Now().UnixNano())

        return cb</span>
}

// newOptimizedRingBuffer 
func newOptimizedRingBuffer(size int) *optimizedRingBuffer <span class="cov5" title="12">{
        return &amp;optimizedRingBuffer{
                buffer: make([]int64, size),
                size:   uint64(size),
                mask:   uint64(size - 1),
        }
}</span>

// Before  ()
func (p *CircuitBreaker) Before() bool <span class="cov6" title="14">{
        p.updateStateOptimized()

        state := p.state.Load()
        switch state </span>{
        case stateClosedOpt:<span class="cov4" title="7">
                return true</span>
        case stateOpenOpt:<span class="cov4" title="5">
                return false</span>
        case stateHalfOpenOpt:<span class="cov2" title="2">
                return p.probe()</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// After  ()
func (p *CircuitBreaker) After(success bool) <span class="cov5" title="13">{
        now := time.Now().UnixNano()
        
        // () + 
        baseTime := p.stats.lastCleanupTime.Load()
        relativeTime := now - baseTime
        if relativeTime &lt; 0 </span><span class="cov0" title="0">{
                relativeTime = 0
        }</span>
        
        <span class="cov5" title="13">var packed int64
        if relativeTime &gt; 0x7FFFFFFF </span><span class="cov0" title="0">{ // 32
                packed = now &lt;&lt; timeShift
        }</span> else<span class="cov5" title="13"> {
                packed = relativeTime &lt;&lt; timeShift
        }</span>
        
        <span class="cov5" title="13">if success </span><span class="cov3" title="3">{
                packed |= successFlag
                p.stats.successes.Add(1)
        }</span> else<span class="cov5" title="10"> {
                p.stats.failures.Add(1)
        }</span>

        // 
        <span class="cov5" title="13">p.ringBuffer.addOptimized(packed)
        p.stats.changed.Store(1)</span>
}

// addOptimized 
func (rb *optimizedRingBuffer) addOptimized(packed int64) <span class="cov6" title="14">{
        tail := rb.tail.Add(1) - 1
        rb.buffer[tail&amp;rb.mask] = packed
}</span>

// updateStateOptimized 
func (p *CircuitBreaker) updateStateOptimized() <span class="cov6" title="14">{
        if p.stats.changed.Load() == 0 &amp;&amp; !p.cleanUpOptimized() </span><span class="cov4" title="5">{
                return
        }</span>

        // CAS
        <span class="cov5" title="9">if !p.stats.changed.CompareAndSwap(1, 0) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov5" title="9">oldState := p.state.Load()
        successes := p.stats.successes.Load()
        failures := p.stats.failures.Load()

        shouldTrip := p.readyToTrip(successes, failures)
        var newState uint32

        switch oldState </span>{
        case stateClosedOpt:<span class="cov5" title="9">
                if shouldTrip </span><span class="cov2" title="2">{
                        newState = stateOpenOpt
                }</span> else<span class="cov4" title="7"> {
                        newState = stateClosedOpt
                }</span>
        case stateOpenOpt:<span class="cov0" title="0">
                if !shouldTrip </span><span class="cov0" title="0">{
                        newState = stateHalfOpenOpt
                }</span> else<span class="cov0" title="0"> {
                        newState = stateOpenOpt
                }</span>
        case stateHalfOpenOpt:<span class="cov0" title="0">
                if p.ringBuffer.hasRecentRequest() </span><span class="cov0" title="0">{
                        if p.ringBuffer.lastRequestSuccess() </span><span class="cov0" title="0">{
                                newState = stateClosedOpt
                                p.ringBuffer.reset()
                        }</span> else<span class="cov0" title="0"> {
                                newState = stateOpenOpt
                        }</span>
                } else<span class="cov0" title="0"> {
                        newState = stateHalfOpenOpt
                }</span>
        default:<span class="cov0" title="0">
                newState = stateClosedOpt</span>
        }

        <span class="cov5" title="9">if p.state.CompareAndSwap(oldState, newState) &amp;&amp; oldState != newState &amp;&amp; p.onStateChange != nil </span><span class="cov0" title="0">{
                // 
                oldStateEnum := stateFromUint32(oldState)
                newStateEnum := stateFromUint32(newState)
                p.onStateChange(oldStateEnum, newStateEnum)
        }</span>
}

// cleanUpOptimized 
func (p *CircuitBreaker) cleanUpOptimized() bool <span class="cov4" title="5">{
        now := time.Now().UnixNano()
        lastCleanup := p.stats.lastCleanupTime.Load()
        
        if now-lastCleanup &lt; p.timeWindow </span><span class="cov4" title="5">{
                return false
        }</span>

        <span class="cov0" title="0">if !p.stats.lastCleanupTime.CompareAndSwap(lastCleanup, now) </span><span class="cov0" title="0">{
                return false // goroutine
        }</span>

        <span class="cov0" title="0">threshold := now - p.timeWindow
        removedSuccesses, removedFailures := p.ringBuffer.cleanupOptimized(threshold, lastCleanup)

        if removedSuccesses &gt; 0 || removedFailures &gt; 0 </span><span class="cov0" title="0">{
                p.stats.successes.Add(^(removedSuccesses - 1)) // 
                p.stats.failures.Add(^(removedFailures - 1))   // 
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// cleanupOptimized 
func (rb *optimizedRingBuffer) cleanupOptimized(threshold, baseTime int64) (removedSuccesses, removedFailures uint64) <span class="cov0" title="0">{
        head := rb.head.Load()
        tail := rb.tail.Load()

        for head &lt; tail </span><span class="cov0" title="0">{
                idx := head &amp; rb.mask
                packed := rb.buffer[idx]
                
                if packed == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // 
                <span class="cov0" title="0">var timestamp int64
                if packed&gt;&gt;timeShift &gt; 0x7FFFFFFF </span><span class="cov0" title="0">{
                        timestamp = packed &gt;&gt; timeShift // 
                }</span> else<span class="cov0" title="0"> {
                        timestamp = baseTime + (packed &gt;&gt; timeShift) // 
                }</span>

                <span class="cov0" title="0">if timestamp &gt;= threshold </span><span class="cov0" title="0">{
                        break</span>
                }

                // 
                <span class="cov0" title="0">if packed&amp;successFlag != 0 </span><span class="cov0" title="0">{
                        removedSuccesses++
                }</span> else<span class="cov0" title="0"> {
                        removedFailures++
                }</span>

                // 
                <span class="cov0" title="0">rb.buffer[idx] = 0
                head++</span>
        }

        <span class="cov0" title="0">rb.head.Store(head)
        return</span>
}

// hasRecentRequest 
func (rb *optimizedRingBuffer) hasRecentRequest() bool <span class="cov1" title="1">{
        return rb.head.Load() &lt; rb.tail.Load()
}</span>

// lastRequestSuccess 
func (rb *optimizedRingBuffer) lastRequestSuccess() bool <span class="cov1" title="1">{
        head := rb.head.Load()
        tail := rb.tail.Load()
        if head &gt;= tail </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov1" title="1">lastIdx := (tail - 1) &amp; rb.mask
        packed := rb.buffer[lastIdx]
        return packed&amp;successFlag != 0</span>
}

// reset 
func (rb *optimizedRingBuffer) reset() <span class="cov1" title="1">{
        rb.head.Store(0)
        rb.tail.Store(0)
}</span>

// Call  ()
func (p *CircuitBreaker) Call(fn func() error) error <span class="cov4" title="8">{
        if !p.Before() </span><span class="cov2" title="2">{
                return errors.New("circuit breaker is open")
        }</span>

        <span class="cov4" title="6">err := fn()
        p.After(err == nil)
        return err</span>
}

// State 
func (p *CircuitBreaker) State() State <span class="cov4" title="7">{
        return stateFromUint32(p.state.Load())
}</span>

// Stat 
func (p *CircuitBreaker) Stat() (successes, failures uint64) <span class="cov4" title="5">{
        return p.stats.successes.Load(), p.stats.failures.Load()
}</span>

// Total 
func (p *CircuitBreaker) Total() uint64 <span class="cov2" title="2">{
        return p.stats.successes.Load() + p.stats.failures.Load()
}</span>

// 
func stateFromUint32(state uint32) State <span class="cov4" title="7">{
        switch state </span>{
        case stateClosedOpt:<span class="cov3" title="4">
                return Closed</span>
        case stateOpenOpt:<span class="cov3" title="3">
                return Open</span>
        case stateHalfOpenOpt:<span class="cov0" title="0">
                return HalfOpen</span>
        default:<span class="cov0" title="0">
                return Closed</span>
        }
}

// FastCircuitBreaker  ()
type FastCircuitBreaker struct {
        state     atomic.Uint32 // 
        successes atomic.Uint64 // 
        failures  atomic.Uint64 // 
        lastReset atomic.Int64  // 

        threshold   uint64 // 
        windowNanos int64  // ()
}

// NewFastCircuitBreaker 
func NewFastCircuitBreaker(failureThreshold uint64, timeWindow time.Duration) *FastCircuitBreaker <span class="cov2" title="2">{
        cb := &amp;FastCircuitBreaker{
                threshold:   failureThreshold,
                windowNanos: timeWindow.Nanoseconds(),
        }
        cb.lastReset.Store(time.Now().UnixNano())
        return cb
}</span>

// AllowRequest  ()
func (cb *FastCircuitBreaker) AllowRequest() bool <span class="cov4" title="5">{
        now := time.Now().UnixNano()
        lastReset := cb.lastReset.Load()

        // 
        if now-lastReset &gt; cb.windowNanos </span><span class="cov1" title="1">{
                if cb.lastReset.CompareAndSwap(lastReset, now) </span><span class="cov1" title="1">{
                        cb.successes.Store(0)
                        cb.failures.Store(0)
                        cb.state.Store(stateClosedOpt) // 
                }</span>
        }

        <span class="cov4" title="5">state := cb.state.Load()
        if state == stateOpenOpt </span><span class="cov2" title="2">{
                // 
                return false
        }</span>

        <span class="cov3" title="3">return true</span> // Closed  HalfOpen 
}

// RecordResult  ()
func (cb *FastCircuitBreaker) RecordResult(success bool) <span class="cov4" title="6">{
        if success </span><span class="cov1" title="1">{
                cb.successes.Add(1)
        }</span> else<span class="cov4" title="5"> {
                failures := cb.failures.Add(1)
                if failures &gt;= cb.threshold </span><span class="cov2" title="2">{
                        cb.state.Store(stateOpenOpt)
                }</span>
        }
}

// CallFast 
func (cb *FastCircuitBreaker) CallFast(fn func() error) error <span class="cov0" title="0">{
        if !cb.AllowRequest() </span><span class="cov0" title="0">{
                return errors.New("circuit breaker is open")
        }</span>

        <span class="cov0" title="0">err := fn()
        cb.RecordResult(err == nil)
        
        // 
        if err == nil &amp;&amp; cb.state.Load() == stateHalfOpenOpt </span><span class="cov0" title="0">{
                cb.state.Store(stateClosedOpt)
        }</span>
        
        <span class="cov0" title="0">return err</span>
}

//  -  requestResult 
var requestResultPool = sync.Pool{
        New: func() interface{} <span class="cov1" title="1">{
                return &amp;requestResult{}
        }</span>,
}

// getRequestResult 
func getRequestResult() *requestResult <span class="cov2" title="2">{
        return requestResultPool.Get().(*requestResult)
}</span>

// putRequestResult 
func putRequestResult(r *requestResult) <span class="cov1" title="1">{
        r.success = false
        r.time = time.Time{}
        requestResultPool.Put(r)
}</span>

// BatchCircuitBreaker 
type BatchCircuitBreaker struct {
        *CircuitBreaker
        batchSize    int
        batchBuffer  []bool
        batchIndex   atomic.Int32
        batchMutex   sync.Mutex
        batchTimeout time.Duration
        lastFlush    atomic.Int64
}

// NewBatchCircuitBreaker 
func NewBatchCircuitBreaker(config CircuitBreakerConfig, batchSize int, batchTimeout time.Duration) *BatchCircuitBreaker <span class="cov1" title="1">{
        if batchSize &lt;= 0 </span><span class="cov0" title="0">{
                batchSize = 100
        }</span>
        
        <span class="cov1" title="1">cb := &amp;BatchCircuitBreaker{
                CircuitBreaker:  NewCircuitBreaker(config),
                batchSize:       batchSize,
                batchBuffer:     make([]bool, batchSize),
                batchTimeout:    batchTimeout,
        }
        cb.lastFlush.Store(time.Now().UnixNano())
        
        // 
        go cb.flushLoop()
        
        return cb</span>
}

// AfterBatch 
func (cb *BatchCircuitBreaker) AfterBatch(success bool) <span class="cov4" title="5">{
        now := time.Now().UnixNano()
        
        // 
        if now-cb.lastFlush.Load() &gt; cb.batchTimeout.Nanoseconds() </span><span class="cov0" title="0">{
                cb.flush()
                return
        }</span>
        
        <span class="cov4" title="5">index := cb.batchIndex.Add(1) - 1
        if int(index) &gt;= cb.batchSize </span><span class="cov0" title="0">{
                cb.flush()
                cb.AfterBatch(success) // 
                return
        }</span>
        
        <span class="cov4" title="5">cb.batchBuffer[index] = success
        
        if int(index) &gt;= cb.batchSize-1 </span><span class="cov0" title="0">{
                cb.flush()
        }</span>
}

// flush 
func (cb *BatchCircuitBreaker) flush() <span class="cov1" title="1">{
        cb.batchMutex.Lock()
        defer cb.batchMutex.Unlock()
        
        index := cb.batchIndex.Swap(0)
        if index == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov1" title="1">var successes, failures uint64
        for i := int32(0); i &lt; index; i++ </span><span class="cov4" title="5">{
                if cb.batchBuffer[i] </span><span class="cov4" title="5">{
                        successes++
                }</span> else<span class="cov0" title="0"> {
                        failures++
                }</span>
        }
        
        // 
        <span class="cov1" title="1">if successes &gt; 0 </span><span class="cov1" title="1">{
                cb.stats.successes.Add(successes)
        }</span>
        <span class="cov1" title="1">if failures &gt; 0 </span><span class="cov0" title="0">{
                cb.stats.failures.Add(failures)
        }</span>
        
        <span class="cov1" title="1">cb.stats.changed.Store(1)
        cb.lastFlush.Store(time.Now().UnixNano())</span>
}

// flushLoop 
func (cb *BatchCircuitBreaker) flushLoop() <span class="cov1" title="1">{
        ticker := time.NewTicker(cb.batchTimeout)
        defer ticker.Stop()
        
        for range ticker.C </span><span class="cov0" title="0">{
                if cb.batchIndex.Load() &gt; 0 </span><span class="cov0" title="0">{
                        cb.flush()
                }</span>
        }
}

// 
func (p *CircuitBreaker) GetState() uint32 <span class="cov1" title="1">{
        return p.state.Load()
}</span>

// IsOpen 
func (p *CircuitBreaker) IsOpen() bool <span class="cov2" title="2">{
        return p.state.Load() == stateOpenOpt
}</span>

// IsClosed 
func (p *CircuitBreaker) IsClosed() bool <span class="cov2" title="2">{
        return p.state.Load() == stateClosedOpt
}</span>

// ringBuffer 
type ringBuffer = optimizedRingBuffer

// newRingBuffer 
func newRingBuffer(size int) *ringBuffer <span class="cov1" title="1">{
        return newOptimizedRingBuffer(size)
}</span>

// add 
func (rb *ringBuffer) add(result *requestResult) <span class="cov1" title="1">{
        now := time.Now().UnixNano()
        packed := now &lt;&lt; timeShift
        if result.success </span><span class="cov1" title="1">{
                packed |= successFlag
        }</span>
        <span class="cov1" title="1">rb.addOptimized(packed)</span>
}

// cleanup 
func (rb *ringBuffer) cleanup(threshold int64) (removedSuccesses, removedFailures uint64) <span class="cov0" title="0">{
        return rb.cleanupOptimized(threshold, 0)
}</span>

// len 
func (rb *ringBuffer) len() int <span class="cov3" title="3">{
        tail := rb.tail.Load()
        head := rb.head.Load()
        return int(tail - head)
}</span>

// last 
func (rb *ringBuffer) last() *requestResult <span class="cov1" title="1">{
        if !rb.hasRecentRequest() </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        //  requestResult 
        <span class="cov1" title="1">result := &amp;requestResult{
                success: rb.lastRequestSuccess(),
                time:    time.Now(), // 
        }
        return result</span>
}

// 
var (
        _ unsafe.Pointer = unsafe.Pointer(&amp;CircuitBreaker{})
        _ unsafe.Pointer = unsafe.Pointer(&amp;FastCircuitBreaker{})
        _ unsafe.Pointer = unsafe.Pointer(&amp;BatchCircuitBreaker{})
)</pre>
		
		<pre class="file" id="file107" style="display: none">package hystrix

import "github.com/lazygophers/utils/randx"

// ProbeWithChance [0, 100]
func ProbeWithChance(percent float64) Probe <span class="cov10" title="11">{
        return func() bool </span><span class="cov0" title="0">{
                return randx.Booln(percent)
        }</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package json

import (
        "os"
)

func UnmarshalFromFile(filename string, v any) error <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return NewDecoder(file).Decode(v)</span>
}

func MustUnmarshalFromFile(filename string, v any) <span class="cov0" title="0">{
        err := UnmarshalFromFile(filename, v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func MarshalToFile(filename string, v any) error <span class="cov0" title="0">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return NewEncoder(file).Encode(v)</span>
}

func MustMarshalToFile(filename string, v any) <span class="cov0" title="0">{
        err := MarshalToFile(filename, v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package json

func MustMarshal(v any) []byte <span class="cov0" title="0">{
        buf, err := Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return buf</span>
}

func MustMarshalString(v any) string <span class="cov0" title="0">{
        buf, err := MarshalString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return buf</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package json

import (
        "bytes"
        "encoding/json"
)

func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error <span class="cov0" title="0">{
        return json.Indent(dst, src, prefix, indent)
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">//go:build (linux &amp;&amp; amd64) || darwin

package json

import (
        "github.com/bytedance/sonic"
        "io"
)

func Marshal(v any) ([]byte, error) <span class="cov0" title="0">{
        return sonic.Marshal(v)
}</span>

func Unmarshal(data []byte, v any) error <span class="cov0" title="0">{
        return sonic.Unmarshal(data, v)
}</span>

func MarshalString(v any) (string, error) <span class="cov0" title="0">{
        buf, err := sonic.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(buf), nil</span>
}

func UnmarshalString(data string, v any) error <span class="cov0" title="0">{
        return sonic.Unmarshal([]byte(data), v)
}</span>

func NewEncoder(w io.Writer) sonic.Encoder <span class="cov0" title="0">{
        return sonic.ConfigDefault.NewEncoder(w)
}</span>

func NewDecoder(r io.Reader) sonic.Decoder <span class="cov0" title="0">{
        return sonic.ConfigDefault.NewDecoder(r)
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package utils

import "github.com/lazygophers/log"

// MustOk  ok  false  panic
//  T 
//
// :
//
//        value: 
//        ok:    
//
// :
//
//        T 
func MustOk[T any](value T, ok bool) T <span class="cov0" title="0">{
        if !ok </span><span class="cov0" title="0">{
                log.Panic("is not ok")
        }</span>
        <span class="cov0" title="0">return value</span>
}

// MustSuccess  error  nil  panic
// 
//
// :
//
//        err: 
func MustSuccess(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("err:%s", err)
        }</span>
}

// Must 
// 
//
// :
//
//        value: 
//        err:   
//
// :
//
//        T 
func Must[T any](value T, err error) T <span class="cov0" title="0">{
        MustSuccess(err)
        return value
}</span>

// Ignore 
// 
//
// :
//
//        value: 
//        _:     
//
// :
//
//        T 
func Ignore[T any](value T, _ any) T <span class="cov0" title="0">{
        return value
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package network

import (
        "net"
        "net/http"
        "strings"
)

func RealIpFromHeader(header http.Header) string <span class="cov10" title="40">{
        val := header.Get("Cf-Connecting-Ip")
        if val != "" </span><span class="cov5" title="6">{
                if !IsLocalIp(val) </span><span class="cov4" title="5">{
                        return val
                }</span>
        }

        <span class="cov9" title="35">val = header.Get("Cf-Pseudo-Ipv4")
        if val != "" </span><span class="cov2" title="2">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov9" title="34">val = header.Get("Cf-Connecting-Ipv6")
        if val != "" </span><span class="cov2" title="2">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov9" title="33">val = header.Get("Cf-Pseudo-Ipv6")
        if val != "" </span><span class="cov1" title="1">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov9" title="32">val = header.Get("Fastly-Client-Ip")
        if val != "" </span><span class="cov1" title="1">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov9" title="31">val = header.Get("True-Client-Ip")
        if val != "" </span><span class="cov1" title="1">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov9" title="30">val = header.Get("X-Real-IP")
        if val != "" </span><span class="cov6" title="8">{
                if !IsLocalIp(val) </span><span class="cov4" title="4">{
                        return val
                }</span>
        }

        <span class="cov8" title="26">val = header.Get("X-Client-IP")
        if val != "" </span><span class="cov1" title="1">{
                if !IsLocalIp(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
        }

        <span class="cov8" title="25">val = header.Get("X-Original-Forwarded-For")
        if val != "" </span><span class="cov3" title="3">{
                for _, v := range strings.Split(val, ",") </span><span class="cov5" title="7">{
                        v = strings.TrimSpace(v)
                        if v != "" &amp;&amp; net.ParseIP(v) != nil &amp;&amp; !IsLocalIp(v) </span><span class="cov2" title="2">{
                                return v
                        }</span>
                }
        }

        <span class="cov8" title="23">val = header.Get("X-Forwarded-For")
        if val != "" </span><span class="cov6" title="9">{
                for _, v := range strings.Split(val, ",") </span><span class="cov8" title="24">{
                        v = strings.TrimSpace(v)
                        if v != "" &amp;&amp; net.ParseIP(v) != nil &amp;&amp; !IsLocalIp(v) </span><span class="cov5" title="6">{
                                return v
                        }</span>
                }
        }

        <span class="cov7" title="17">val = header.Get("X-Forwarded")
        if val != "" </span><span class="cov1" title="1">{
                for _, v := range strings.Split(val, ",") </span><span class="cov2" title="2">{
                        v = strings.TrimSpace(v)
                        if v != "" &amp;&amp; net.ParseIP(v) != nil &amp;&amp; !IsLocalIp(v) </span><span class="cov1" title="1">{
                                return v
                        }</span>
                }
        }

        <span class="cov7" title="16">val = header.Get("Forwarded-For")
        if val != "" </span><span class="cov1" title="1">{
                for _, v := range strings.Split(val, ",") </span><span class="cov2" title="2">{
                        v = strings.TrimSpace(v)
                        if v != "" &amp;&amp; net.ParseIP(v) != nil &amp;&amp; !IsLocalIp(v) </span><span class="cov1" title="1">{
                                return v
                        }</span>
                }
        }

        <span class="cov7" title="15">val = header.Get("Forwarded")
        if val != "" </span><span class="cov1" title="1">{
                for _, v := range strings.Split(val, ",") </span><span class="cov2" title="2">{
                        v = strings.TrimSpace(v)
                        if v != "" &amp;&amp; net.ParseIP(v) != nil &amp;&amp; !IsLocalIp(v) </span><span class="cov1" title="1">{
                                return v
                        }</span>
                }
        }

        <span class="cov7" title="14">return ""</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package network

import (
        "github.com/lazygophers/log"
        "net"
)

func GetInterfaceIpByName(name string, prev6 bool) string <span class="cov10" title="17">{
        inter, err := net.InterfaceByName(name)
        if err != nil </span><span class="cov8" title="11">{
                log.Debugf("err:%v", err)
                return ""
        }</span>

        <span class="cov6" title="6">address, err := inter.Addrs()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return ""
        }</span>

        <span class="cov6" title="6">return GetInterfaceIpByAddrs(address, prev6)</span>
}

func GetInterfaceIpByAddrs(address []net.Addr, prev6 bool) string <span class="cov9" title="16">{
        var v4 string
        for _, addr := range address </span><span class="cov10" title="17">{
                if ipnet, ok := addr.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() </span><span class="cov9" title="13">{
                        if ipnet.IP.To4() == nil &amp;&amp; ipnet.IP.To16() != nil </span><span class="cov3" title="2">{
                                // v6  (To4()nilIPv4To16()nilIP)
                                if prev6 </span><span class="cov3" title="2">{
                                        return ipnet.IP.String()
                                }</span>
                        } else<span class="cov8" title="11"> if ipnet.IP.To4() != nil </span><span class="cov8" title="11">{
                                // v4 
                                if !prev6 </span><span class="cov6" title="6">{
                                        return ipnet.IP.String()
                                }</span> else<span class="cov6" title="5"> {
                                        v4 = ipnet.IP.String()
                                }</span>
                        }
                }
        }

        <span class="cov7" title="8">return v4</span>
}

func GetListenIp(prev6 ...bool) string <span class="cov5" title="4">{
        //  IP
        var _prev6 bool
        _prev6 = len(prev6) &gt; 0 &amp;&amp; prev6[0]

        //  eth0 
        if ip := GetInterfaceIpByName("eth0", _prev6); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>

        //  en0 
        <span class="cov5" title="4">if ip := GetInterfaceIpByName("en0", _prev6); ip != "" </span><span class="cov5" title="4">{
                return ip
        }</span>

        <span class="cov0" title="0">address, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return ""
        }</span>

        <span class="cov0" title="0">if ip := GetInterfaceIpByAddrs(address, _prev6); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>

        <span class="cov0" title="0">log.Error("get interface ip failed")

        return ""</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package network

import "net/netip"

func IsLocalIp(ip string) bool <span class="cov10" title="64">{
        i, err := netip.ParseAddr(ip)
        if err != nil </span><span class="cov4" title="4">{
                return false
        }</span>

        <span class="cov9" title="60">return i.IsPrivate() || i.IsLoopback() || i.IsLinkLocalUnicast()</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">// utils 
// 
// 1. (Scan)
// 2. (Value)
// 3. 
package utils

import (
        "database/sql/driver"
        "fmt"
        "reflect"

        "github.com/lazygophers/log"
        "github.com/lazygophers/utils/json"

        "github.com/mcuadros/go-defaults"
        "github.com/pkg/errors"
)

// Scan 
// []bytestringdefaults.SetDefaults
// :
//   - src: []bytestring
//   - dst: 
//
// :
//   - error: 
//
// :
// 1. srcJSONjson.Unmarshal
// 2. defaults.SetDefaults
func Scan(src interface{}, dst interface{}) (err error) <span class="cov0" title="0">{
        x := func(buf []byte) error </span><span class="cov0" title="0">{
                bufLen := len(buf)
                if bufLen &gt;= 2 &amp;&amp; ((buf[0] == '{' &amp;&amp; buf[bufLen-1] == '}') || (buf[0] == '[' &amp;&amp; buf[bufLen-1] == ']')) </span><span class="cov0" title="0">{
                        err = json.Unmarshal(buf, dst)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("err:%v", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                } else<span class="cov0" title="0"> if bufLen &gt; 0 </span><span class="cov0" title="0">{
                        err = json.Unmarshal(buf, dst)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("err:%v", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                } else<span class="cov0" title="0"> {
                        defaults.SetDefaults(dst)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">switch r := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                buf := src.([]byte)
                return x(buf)</span>
        case string:<span class="cov0" title="0">
                buf := []byte(src.(string))
                return x(buf)</span>
        default:<span class="cov0" title="0">
                return errors.New(
                        fmt.Sprintf("unknown type %v %s to scan", r, reflect.ValueOf(src).String()))</span>
        }
}

func Value(m interface{}) (value driver.Value, err error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                defaults.SetDefaults(m)
        }</span>

        <span class="cov0" title="0">value, err = json.Marshal(m)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package osx

import (
        "io"
        "io/fs"
        "os"
)

func Exists(path string) bool <span class="cov6" title="21">{
        _, err := os.Stat(path)
        if err != nil </span><span class="cov5" title="13">{
                return os.IsExist(err)
        }</span>
        <span class="cov4" title="8">return true</span>
}

func IsDir(path string) bool <span class="cov3" title="5">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov2" title="2">{
                return false
        }</span>
        <span class="cov2" title="3">return info.IsDir()</span>
}

func IsFile(path string) bool <span class="cov3" title="5">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov2" title="2">{
                return false
        }</span>
        <span class="cov2" title="3">return !info.IsDir()</span>
}

func Exist(path string) bool <span class="cov6" title="24">{
        _, err := os.Stat(path)
        if err != nil </span><span class="cov4" title="9">{
                return false
        }</span>
        <span class="cov5" title="15">return true</span>
}

func FsHasFile(fs fs.FS, path string) bool <span class="cov5" title="11">{
        f, err := fs.Open(path)
        if err != nil </span><span class="cov3" title="4">{
                return false
        }</span>
        <span class="cov4" title="7">defer f.Close()
        return true</span>
}

func RenameForce(oldpath, newpath string) (err error) <span class="cov5" title="14">{
        if Exists(newpath) </span><span class="cov4" title="6">{
                err = os.RemoveAll(newpath)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov5" title="13">err = os.Rename(oldpath, newpath)
        if err != nil </span><span class="cov4" title="6">{
                return err
        }</span>
        <span class="cov4" title="7">return nil</span>
}

func Copy(src, dst string) error <span class="cov10" title="164">{
        srcFile, err := os.Open(src)
        if err != nil </span><span class="cov3" title="4">{
                return err
        }</span>
        <span class="cov9" title="160">defer srcFile.Close()

        stat, err := srcFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="160">dstFile, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, stat.Mode())
        if err != nil </span><span class="cov3" title="4">{
                return err
        }</span>
        <span class="cov9" title="156">defer dstFile.Close()

        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov9" title="154">return nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package pyroscope

import (
        "github.com/grafana/pyroscope-go"
        "github.com/lazygophers/log"
        "github.com/lazygophers/utils/app"
        "github.com/pterm/pterm"
        "os"
)

// docker run -itd -p 4040:4040 pyroscope/pyroscope:latest server
func load(address string) <span class="cov0" title="0">{
        if address == "" </span><span class="cov0" title="0">{
                address = "http://127.0.0.1:4040"
        }</span>

        <span class="cov0" title="0">log.Info("pyroscope address:", address)

        _, err := pyroscope.Start(pyroscope.Config{
                ApplicationName: app.Name,
                Tags:            map[string]string{"hostname": os.Getenv("HOSTNAME")},
                ServerAddress:   address,
                UploadRate:      0,
                ProfileTypes: []pyroscope.ProfileType{
                        pyroscope.ProfileCPU,
                        pyroscope.ProfileInuseObjects,
                        pyroscope.ProfileAllocObjects,
                        pyroscope.ProfileInuseSpace,
                        pyroscope.ProfileAllocSpace,
                        pyroscope.ProfileGoroutines,
                        pyroscope.ProfileMutexCount,
                        pyroscope.ProfileMutexDuration,
                        pyroscope.ProfileBlockCount,
                        pyroscope.ProfileBlockDuration,
                },
                DisableGCRuns: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                pterm.Error.Printfln("start pyroscope err:%v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">//go:build !release

package pyroscope

func Load(address string) <span class="cov0" title="0">{
        load(address)
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">package randx

// Choose 
func Choose[T any](s []T) T <span class="cov10" title="3257">{
        if len(s) == 0 </span><span class="cov1" title="2">{
                return *new(T)
        }</span>

        <span class="cov9" title="3255">if len(s) == 1 </span><span class="cov1" title="2">{
                return s[0]
        }</span>

        <span class="cov9" title="3253">return s[FastIntn(len(s))]</span>
}

// FastChoose 
func FastChoose[T any](s []T) T <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return *new(T)
        }</span>

        <span class="cov0" title="0">if len(s) == 1 </span><span class="cov0" title="0">{
                return s[0]
        }</span>

        <span class="cov0" title="0">globalMu.Lock()
        idx := globalRand.Intn(len(s))
        globalMu.Unlock()
        
        return s[idx]</span>
}

// ChooseN N
func ChooseN[T any](s []T, n int) []T <span class="cov0" title="0">{
        if len(s) == 0 || n &lt;= 0 </span><span class="cov0" title="0">{
                return []T{}
        }</span>
        
        <span class="cov0" title="0">if n &gt;= len(s) </span><span class="cov0" title="0">{
                // 
                result := make([]T, len(s))
                copy(result, s)
                return result
        }</span>
        
        // Fisher-YatesN
        <span class="cov0" title="0">sCopy := make([]T, len(s))
        copy(sCopy, s)
        
        r := getFastRand()
        
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                j := i + r.Intn(len(sCopy)-i)
                sCopy[i], sCopy[j] = sCopy[j], sCopy[i]
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        
        return sCopy[:n]</span>
}

// Shuffle 
func Shuffle[T any](s []T) <span class="cov0" title="0">{
        if len(s) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">r := getFastRand()
        
        // Fisher-Yates 
        for i := len(s) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                j := r.Intn(i + 1)
                s[i], s[j] = s[j], s[i]
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)</span>
}

// FastShuffle 
func FastShuffle[T any](s []T) <span class="cov0" title="0">{
        if len(s) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">globalMu.Lock()
        defer globalMu.Unlock()
        
        for i := len(s) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                j := globalRand.Intn(i + 1)
                s[i], s[j] = s[j], s[i]
        }</span>
}

// WeightedChoose 
func WeightedChoose[T any](items []T, weights []float64) T <span class="cov0" title="0">{
        if len(items) == 0 || len(items) != len(weights) </span><span class="cov0" title="0">{
                return *new(T)
        }</span>
        
        <span class="cov0" title="0">if len(items) == 1 </span><span class="cov0" title="0">{
                return items[0]
        }</span>
        
        // 
        <span class="cov0" title="0">totalWeight := 0.0
        for _, w := range weights </span><span class="cov0" title="0">{
                totalWeight += w
        }</span>
        
        <span class="cov0" title="0">if totalWeight &lt;= 0 </span><span class="cov0" title="0">{
                return items[FastIntn(len(items))]
        }</span>
        
        // 
        <span class="cov0" title="0">r := FastFloat64() * totalWeight
        
        // 
        accumWeight := 0.0
        for i, weight := range weights </span><span class="cov0" title="0">{
                accumWeight += weight
                if r &lt;= accumWeight </span><span class="cov0" title="0">{
                        return items[i]
                }</span>
        }
        
        // 
        <span class="cov0" title="0">return items[len(items)-1]</span>
}

// BatchChoose 
func BatchChoose[T any](s []T, count int) []T <span class="cov0" title="0">{
        if len(s) == 0 || count &lt;= 0 </span><span class="cov0" title="0">{
                return []T{}
        }</span>
        
        <span class="cov0" title="0">results := make([]T, count)
        
        if len(s) == 1 </span><span class="cov0" title="0">{
                for i := range results </span><span class="cov0" title="0">{
                        results[i] = s[0]
                }</span>
                <span class="cov0" title="0">return results</span>
        }
        
        <span class="cov0" title="0">r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = s[r.Intn(len(s))]
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}</pre>
		
		<pre class="file" id="file121" style="display: none">package randx

// Bool 
func Bool() bool <span class="cov8" title="10100">{
        return FastIntn(2) == 0
}</span>

// Booln 
func Booln(n float64) bool <span class="cov10" title="32490">{
        if n &gt;= 100 </span><span class="cov5" title="250">{
                return true
        }</span> else<span class="cov9" title="32240"> if n &lt;= 0 </span><span class="cov5" title="200">{
                return false
        }</span>

        <span class="cov9" title="32040">return FastFloat64()*100 &lt; n</span>
}

// FastBool 
func FastBool() bool <span class="cov0" title="0">{
        globalMu.Lock()
        result := globalRand.Intn(2) == 0
        globalMu.Unlock()
        return result
}</span>

// WeightedBool weighttrue(0.0-1.0)
func WeightedBool(weight float64) bool <span class="cov0" title="0">{
        if weight &gt;= 1.0 </span><span class="cov0" title="0">{
                return true
        }</span> else<span class="cov0" title="0"> if weight &lt;= 0.0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return Float64() &lt; weight</span>
}

// BatchBool 
func BatchBool(count int) []bool <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">results := make([]bool, count)
        r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = r.Intn(2) == 0
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}

// BatchBooln 
func BatchBooln(n float64, count int) []bool <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">if n &gt;= 100 </span><span class="cov0" title="0">{
                results := make([]bool, count)
                for i := range results </span><span class="cov0" title="0">{
                        results[i] = true
                }</span>
                <span class="cov0" title="0">return results</span>
        } else<span class="cov0" title="0"> if n &lt;= 0 </span><span class="cov0" title="0">{
                return make([]bool, count) // false
        }</span>
        
        <span class="cov0" title="0">results := make([]bool, count)
        r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = r.Float64()*100 &lt; n
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}</pre>
		
		<pre class="file" id="file122" style="display: none">package randx

import (
        "math/rand"
        "sync"
        "time"
        "unsafe"
)

// 
var (
        // 
        globalRand = rand.New(rand.NewSource(time.Now().UnixNano()))
        globalMu   sync.Mutex

        // 
        randPool = sync.Pool{
                New: func() interface{} <span class="cov2" title="5">{
                        return rand.New(rand.NewSource(time.Now().UnixNano()))
                }</span>,
        }

        // time.Now()
        fastSeedCounter uint64 = uint64(time.Now().UnixNano())
)

// getFastRand 
func getFastRand() *rand.Rand <span class="cov9" title="21394">{
        return randPool.Get().(*rand.Rand)
}</span>

// putFastRand 
func putFastRand(r *rand.Rand) <span class="cov9" title="21390">{
        randPool.Put(r)
}</span>

// fastSeed 
func fastSeed() int64 <span class="cov0" title="0">{
        // 
        counter := (*uint64)(unsafe.Pointer(&amp;fastSeedCounter))
        return int64(*counter&lt;&lt;8 | uint64(time.Now().UnixNano()&amp;0xFF))
}</span>

// globalRandIntn 
func globalRandIntn(n int) int <span class="cov9" title="13353">{
        globalMu.Lock()
        result := globalRand.Intn(n)
        globalMu.Unlock()
        return result
}</span>

// Intn 
func Intn(n int) int <span class="cov9" title="10500">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov9" title="10500">if n == 1 </span><span class="cov4" title="100">{
                return 0
        }</span>
        
        <span class="cov9" title="10400">r := getFastRand()
        result := r.Intn(n)
        putFastRand(r)
        return result</span>
}

// Int 
func Int() int <span class="cov7" title="1100">{
        r := getFastRand()
        result := r.Int()
        putFastRand(r)
        return result
}</span>

// IntnRange  [min, max]
func IntnRange(min, max int) int <span class="cov8" title="5505">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov8" title="5504"> if min == max </span><span class="cov2" title="4">{
                return min
        }</span>

        <span class="cov8" title="5500">r := getFastRand()
        result := min + r.Intn(max-min+1)
        putFastRand(r)
        return result</span>
}

// Int64n 
func Int64n(n int64) int64 <span class="cov5" title="250">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov5" title="250">if n == 1 </span><span class="cov4" title="50">{
                return 0
        }</span>
        
        <span class="cov5" title="200">r := getFastRand()
        result := r.Int63n(n)
        putFastRand(r)
        return result</span>
}

// Int64 
func Int64() int64 <span class="cov4" title="100">{
        r := getFastRand()
        result := r.Int63()
        putFastRand(r)
        return result
}</span>

// Int64nRange  [min, max]
func Int64nRange(min, max int64) int64 <span class="cov5" title="252">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov5" title="251"> if min == max </span><span class="cov1" title="1">{
                return min
        }</span>

        <span class="cov5" title="250">r := getFastRand()
        result := min + r.Int63n(max-min+1)
        putFastRand(r)
        return result</span>
}

// Float64 
func Float64() float64 <span class="cov7" title="1100">{
        r := getFastRand()
        result := r.Float64()
        putFastRand(r)
        return result
}</span>

// Float64Range  [min, max]
func Float64Range(min, max float64) float64 <span class="cov5" title="202">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov5" title="201"> if min == max </span><span class="cov1" title="1">{
                return min
        }</span>

        <span class="cov5" title="200">r := getFastRand()
        result := min + r.Float64()*(max-min)
        putFastRand(r)
        return result</span>
}

// Float32 
func Float32() float32 <span class="cov4" title="100">{
        r := getFastRand()
        result := r.Float32()
        putFastRand(r)
        return result
}</span>

// Float32Range  [min, max]
func Float32Range(min, max float32) float32 <span class="cov5" title="152">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov5" title="151"> if min == max </span><span class="cov1" title="1">{
                return min
        }</span>

        <span class="cov5" title="150">r := getFastRand()
        result := min + r.Float32()*(max-min)
        putFastRand(r)
        return result</span>
}

// Uint32 
func Uint32() uint32 <span class="cov4" title="100">{
        r := getFastRand()
        result := r.Uint32()
        putFastRand(r)
        return result
}</span>

// Uint32Range  [min, max]
func Uint32Range(min, max uint32) uint32 <span class="cov5" title="202">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov5" title="201"> if min == max </span><span class="cov1" title="1">{
                return min
        }</span>

        <span class="cov5" title="200">r := getFastRand()
        result := min + r.Uint32()%(max-min+1)
        putFastRand(r)
        return result</span>
}

// Uint64 
func Uint64() uint64 <span class="cov4" title="100">{
        r := getFastRand()
        result := r.Uint64()
        putFastRand(r)
        return result
}</span>

// Uint64Range  [min, max]
func Uint64Range(min, max uint64) uint64 <span class="cov5" title="202">{
        if min &gt; max </span><span class="cov1" title="1">{
                return 0
        }</span> else<span class="cov5" title="201"> if min == max </span><span class="cov1" title="1">{
                return min
        }</span>

        <span class="cov5" title="200">r := getFastRand()
        result := min + r.Uint64()%(max-min+1)
        putFastRand(r)
        return result</span>
}

// FastIntn 
func FastIntn(n int) int <span class="cov9" title="13353">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov9" title="13353">if n == 1 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov9" title="13353">return globalRandIntn(n)</span>
}

// FastInt 
func FastInt() int <span class="cov0" title="0">{
        globalMu.Lock()
        result := globalRand.Int()
        globalMu.Unlock()
        return result
}</span>

// FastFloat64 
func FastFloat64() float64 <span class="cov10" title="32040">{
        globalMu.Lock()
        result := globalRand.Float64()
        globalMu.Unlock()
        return result
}</span>

// BatchIntn 
func BatchIntn(n int, count int) []int <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">results := make([]int, count)
        r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = r.Intn(n)
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}

// BatchInt64n int64
func BatchInt64n(n int64, count int) []int64 <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">results := make([]int64, count)
        r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = r.Int63n(n)
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}

// BatchFloat64 float64
func BatchFloat64(count int) []float64 <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">results := make([]float64, count)
        r := getFastRand()
        
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = r.Float64()
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}</pre>
		
		<pre class="file" id="file123" style="display: none">package randx

import (
        "time"
)

// TimeDuration4Sleep 
func TimeDuration4Sleep(s ...time.Duration) time.Duration <span class="cov10" title="1694">{
        start, end := time.Second, time.Second*3
        if len(s) &gt; 1 </span><span class="cov9" title="1402">{
                start = s[0]
                end = s[1]
        }</span> else<span class="cov7" title="292"> if len(s) &gt; 0 </span><span class="cov7" title="192">{
                start = 0
                end = s[0]
        }</span>

        // 
        <span class="cov10" title="1694">r := getFastRand()
        result := time.Duration(r.Int63n(int64(end-start))) + start
        putFastRand(r)
        
        return result</span>
}

// FastTimeDuration4Sleep 
func FastTimeDuration4Sleep(s ...time.Duration) time.Duration <span class="cov0" title="0">{
        start, end := time.Second, time.Second*3
        if len(s) &gt; 1 </span><span class="cov0" title="0">{
                start = s[0]
                end = s[1]
        }</span> else<span class="cov0" title="0"> if len(s) &gt; 0 </span><span class="cov0" title="0">{
                start = 0
                end = s[0]
        }</span>

        <span class="cov0" title="0">if start &gt;= end </span><span class="cov0" title="0">{
                return start
        }</span>

        <span class="cov0" title="0">globalMu.Lock()
        result := time.Duration(globalRand.Int63n(int64(end-start))) + start
        globalMu.Unlock()
        
        return result</span>
}

// RandomDuration  [min, max]
func RandomDuration(min, max time.Duration) time.Duration <span class="cov0" title="0">{
        if min &gt; max </span><span class="cov0" title="0">{
                return min
        }</span> else<span class="cov0" title="0"> if min == max </span><span class="cov0" title="0">{
                return min
        }</span>

        <span class="cov0" title="0">r := getFastRand()
        result := min + time.Duration(r.Int63n(int64(max-min+1)))
        putFastRand(r)
        
        return result</span>
}

// RandomTime 
func RandomTime(start, end time.Time) time.Time <span class="cov0" title="0">{
        if start.After(end) </span><span class="cov0" title="0">{
                return start
        }</span> else<span class="cov0" title="0"> if start.Equal(end) </span><span class="cov0" title="0">{
                return start
        }</span>

        <span class="cov0" title="0">diff := end.Sub(start)
        r := getFastRand()
        randomDiff := time.Duration(r.Int63n(int64(diff)))
        putFastRand(r)
        
        return start.Add(randomDiff)</span>
}

// RandomTimeInDay 
func RandomTimeInDay(date time.Time) time.Time <span class="cov0" title="0">{
        // 
        startOfDay := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
        // 
        endOfDay := startOfDay.Add(24 * time.Hour)
        
        return RandomTime(startOfDay, endOfDay)
}</span>

// RandomTimeInHour 
func RandomTimeInHour(baseTime time.Time, hour int) time.Time <span class="cov0" title="0">{
        if hour &lt; 0 || hour &gt; 23 </span><span class="cov0" title="0">{
                hour = baseTime.Hour()
        }</span>
        
        <span class="cov0" title="0">startOfHour := time.Date(baseTime.Year(), baseTime.Month(), baseTime.Day(), hour, 0, 0, 0, baseTime.Location())
        endOfHour := startOfHour.Add(time.Hour)
        
        return RandomTime(startOfHour, endOfHour)</span>
}

// BatchRandomDuration 
func BatchRandomDuration(min, max time.Duration, count int) []time.Duration <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">if min &gt; max </span><span class="cov0" title="0">{
                min, max = max, min
        }</span> else<span class="cov0" title="0"> if min == max </span><span class="cov0" title="0">{
                results := make([]time.Duration, count)
                for i := range results </span><span class="cov0" title="0">{
                        results[i] = min
                }</span>
                <span class="cov0" title="0">return results</span>
        }
        
        <span class="cov0" title="0">results := make([]time.Duration, count)
        r := getFastRand()
        
        diff := int64(max - min + 1)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = min + time.Duration(r.Int63n(diff))
        }</span>
        
        <span class="cov0" title="0">putFastRand(r)
        return results</span>
}

// SleepRandom 
func SleepRandom(min, max time.Duration) <span class="cov0" title="0">{
        duration := RandomDuration(min, max)
        time.Sleep(duration)
}</span>

// SleepRandomMilliseconds 
func SleepRandomMilliseconds(minMs, maxMs int) <span class="cov0" title="0">{
        min := time.Duration(minMs) * time.Millisecond
        max := time.Duration(maxMs) * time.Millisecond
        SleepRandom(min, max)
}</span>

// Jitter jitterPercent%
func Jitter(duration time.Duration, jitterPercent float64) time.Duration <span class="cov0" title="0">{
        if jitterPercent &lt;= 0 </span><span class="cov0" title="0">{
                return duration
        }</span>
        
        <span class="cov0" title="0">if jitterPercent &gt; 100 </span><span class="cov0" title="0">{
                jitterPercent = 100
        }</span>
        
        // 
        <span class="cov0" title="0">jitterRange := time.Duration(float64(duration) * jitterPercent / 100)
        
        //  [-jitterRange, +jitterRange] 
        randomJitter := RandomDuration(-jitterRange, jitterRange)
        
        result := duration + randomJitter
        if result &lt; 0 </span><span class="cov0" title="0">{
                result = 0
        }</span>
        
        <span class="cov0" title="0">return result</span>
}</pre>
		
		<pre class="file" id="file124" style="display: none">package routine

import (
        "fmt"
        "github.com/lazygophers/log"
        "github.com/petermattis/goid"
        "os"
        "runtime/debug"
        "strings"
)

type BeforeRoutine func(baseGid, currentGid int64)
type AfterRoutine func(currentGid int64)

var (
        beforeRoutines []BeforeRoutine
        afterRoutines  []AfterRoutine
)

func before(baseGid, currentGid int64) <span class="cov0" title="0">{
        for _, f := range beforeRoutines </span><span class="cov0" title="0">{
                f(baseGid, currentGid)
        }</span>
}

func after(currentGid int64) <span class="cov0" title="0">{
        for _, f := range afterRoutines </span><span class="cov0" title="0">{
                f(currentGid)
        }</span>
}

func AddBeforeRoutine(f BeforeRoutine) <span class="cov0" title="0">{
        beforeRoutines = append(beforeRoutines, f)
}</span>

func AddAfterRoutine(f AfterRoutine) <span class="cov0" title="0">{
        afterRoutines = append(afterRoutines, f)
}</span>

func init() <span class="cov0" title="0">{
        AddBeforeRoutine(func(baseGid, currentGid int64) </span><span class="cov0" title="0">{
                log.SetTraceWithGID(currentGid, fmt.Sprintf("%s.%s", log.GetTraceWithGID(baseGid), log.GenTraceId()))
        }</span>)

        <span class="cov0" title="0">AddAfterRoutine(func(currentGid int64) </span><span class="cov0" title="0">{
                log.DelTraceWithGID(currentGid)
        }</span>)
}

func Go(f func() (err error)) <span class="cov0" title="0">{
        baseGid := goid.Get()
        go func() </span><span class="cov0" title="0">{
                currentGid := goid.Get()
                before(baseGid, currentGid)
                defer func() </span><span class="cov0" title="0">{
                        after(currentGid)
                }</span>()

                <span class="cov0" title="0">err := f()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                }</span>
        }()
}

func GoWithRecover(f func() (err error)) <span class="cov0" title="0">{
        baseGid := goid.Get()
        go func() </span><span class="cov0" title="0">{
                currentGid := goid.Get()
                before(baseGid, currentGid)
                defer func() </span><span class="cov0" title="0">{
                        after(currentGid)
                }</span>()

                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("err:%v", err)
                                st := debug.Stack()
                                if len(st) &gt; 0 </span><span class="cov0" title="0">{
                                        log.Errorf("dump stack (%s):", err)
                                        lines := strings.Split(string(st), "\n")
                                        for _, line := range lines </span><span class="cov0" title="0">{
                                                log.Error("  ", line)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        log.Errorf("stack is empty (%s)", err)
                                }</span>
                        }
                }()

                <span class="cov0" title="0">err := f()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                }</span>
        }()
}

func GoWithMustSuccess(f func() (err error)) <span class="cov0" title="0">{
        baseGid := goid.Get()
        go func() </span><span class="cov0" title="0">{
                currentGid := goid.Get()
                before(baseGid, currentGid)
                defer func() </span><span class="cov0" title="0">{
                        after(currentGid)
                }</span>()

                <span class="cov0" title="0">err := f()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                        os.Exit(1)
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package runtime

import (
        "github.com/lazygophers/log"
        "os"
        "os/signal"
)

func GetExitSign() chan os.Signal <span class="cov10" title="8">{
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, exitSignal...)
        return sigCh
}</span>

func WaitExit() <span class="cov1" title="1">{
        sign := GetExitSign()
        &lt;-sign
}</span>

func Exit() <span class="cov0" title="0">{
        process, err := os.FindProcess(os.Getpid())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                os.Exit(0)
        }</span> else<span class="cov0" title="0"> {
                log.Infof("will stop process:%d", process.Pid)
                // SIGTERMSIGKILLSIGKILL
                err = process.Signal(os.Interrupt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v", err)
                        os.Exit(0)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package runtime

import (
        "github.com/lazygophers/log"
        "github.com/lazygophers/utils/app"
        "os"
        "path/filepath"
        "runtime/debug"
        "strings"
)

func CachePanic() <span class="cov2" title="2">{
        CachePanicWithHandle(nil)
}</span>

func CachePanicWithHandle(handle func(err interface{})) <span class="cov5" title="11">{
        if err := recover(); err != nil </span><span class="cov4" title="5">{
                log.Errorf("PROCESS PANIC: err %s", err)
                st := debug.Stack()
                if len(st) &gt; 0 </span><span class="cov4" title="5">{
                        log.Errorf("dump stack (%s):", err)
                        lines := strings.Split(string(st), "\n")
                        for _, line := range lines </span><span class="cov10" title="80">{
                                log.Error("  ", line)
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Errorf("stack is empty (%s)", err)
                }</span>
                <span class="cov4" title="5">if handle != nil </span><span class="cov3" title="3">{
                        handle(err)
                }</span>
                // panic""panic
        }
}

func PrintStack() <span class="cov3" title="4">{
        st := debug.Stack()
        if len(st) &gt; 0 </span><span class="cov3" title="4">{
                log.Error("dump stack:")
                log.Error(string(st))
        }</span> else<span class="cov0" title="0"> {
                log.Error("stack is empty")
        }</span>
}

func ExecDir() string <span class="cov4" title="7">{
        execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov4" title="7">return filepath.Dir(execPath)</span>
}

func ExecFile() string <span class="cov4" title="7">{
        execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov4" title="7">return execPath</span>
}

func Pwd() string <span class="cov4" title="6">{
        pwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov4" title="6">return pwd</span>
}

func UserHomeDir() string <span class="cov4" title="5">{
        path, _ := os.UserHomeDir()
        return path
}</span>

func UserConfigDir() string <span class="cov4" title="5">{
        path, _ := os.UserConfigDir()
        return path
}</span>

func UserCacheDir() string <span class="cov4" title="6">{
        path, _ := os.UserCacheDir()
        return path
}</span>

func LazyConfigDir() string <span class="cov4" title="5">{
        path, _ := os.UserConfigDir()
        return filepath.Join(path, app.Organization)
}</span>

func LazyCacheDir() string <span class="cov4" title="5">{
        path, _ := os.UserCacheDir()
        return filepath.Join(path, app.Organization)
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">//go:build darwin

package runtime

func IsWindows() bool <span class="cov10" title="11006">{
        return false
}</span>

func IsDarwin() bool <span class="cov10" title="11006">{
        return true
}</span>

func IsLinux() bool <span class="cov10" title="11006">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">package singledo

import (
        "sync"
        "time"
)

type Group[T any] struct {
        wait time.Duration

        mux       sync.RWMutex
        singleMap map[string]*Single[T]
}

func (p *Group[T]) getOrAddSingle(key string) *Single[T] <span class="cov0" title="0">{
        p.mux.RLock()
        single := p.singleMap[key]
        p.mux.RUnlock()

        if single != nil </span><span class="cov0" title="0">{
                return single
        }</span>

        <span class="cov0" title="0">p.mux.Lock()
        defer p.mux.Unlock()

        single = p.singleMap[key]

        if single != nil </span><span class="cov0" title="0">{
                return single
        }</span>

        <span class="cov0" title="0">single = NewSingle[T](p.wait)
        p.singleMap[key] = single

        return single</span>
}

func (p *Group[T]) Do(key string, fn func() (T, error)) (v T, err error) <span class="cov0" title="0">{
        return p.getOrAddSingle(key).Do(fn)
}</span>

func NewSingleGroup[T any](wait time.Duration) *Group[T] <span class="cov0" title="0">{
        return &amp;Group[T]{
                wait:      wait,
                singleMap: make(map[string]*Single[T]),
        }
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">package singledo

import (
        "sync"
        "time"
)

type call[T any] struct {
        wg  sync.WaitGroup
        val T
        err error
}

type Single[T any] struct {
        mux    sync.Mutex
        last   time.Time
        wait   time.Duration
        call   *call[T]
        result T
}

func (s *Single[T]) Do(fn func() (T, error)) (v T, err error) <span class="cov0" title="0">{
        s.mux.Lock()
        now := time.Now()
        if now.Before(s.last.Add(s.wait)) </span><span class="cov0" title="0">{
                s.mux.Unlock()
                return s.result, nil
        }</span>

        <span class="cov0" title="0">if callM := s.call; callM != nil </span><span class="cov0" title="0">{
                s.mux.Unlock()
                callM.wg.Wait()
                return callM.val, callM.err
        }</span>

        <span class="cov0" title="0">callM := &amp;call[T]{}
        callM.wg.Add(1)
        s.call = callM
        s.mux.Unlock()

        callM.val, callM.err = fn()
        callM.wg.Done()

        s.mux.Lock()
        if callM.err == nil </span><span class="cov0" title="0">{
                s.last = now
                s.result = callM.val
                s.call = nil
        }</span>
        <span class="cov0" title="0">s.mux.Unlock()

        return callM.val, callM.err</span>
}

func (s *Single[T]) Reset() <span class="cov0" title="0">{
        s.last = time.Time{}
}</span>

func NewSingle[T any](wait time.Duration) *Single[T] <span class="cov0" title="0">{
        return &amp;Single[T]{wait: wait}
}</span>
</pre>
		
		<pre class="file" id="file130" style="display: none">package stringx

import "math/rand"

func RandLetters(n int) string <span class="cov4" title="103">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov4" title="101">return RandStringWithSeed(n, []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))</span>
}

func RandLowerLetters(n int) string <span class="cov1" title="3">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return RandStringWithSeed(n, []rune("abcdefghijklmnopqrstuvwxyz"))</span>
}

func RandUpperLetters(n int) string <span class="cov1" title="3">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return RandStringWithSeed(n, []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZ"))</span>
}

func RandNumbers(n int) string <span class="cov1" title="3">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return RandStringWithSeed(n, []rune("0123456789"))</span>
}

func RandLetterNumbers(n int) string <span class="cov2" title="5">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="3">return RandStringWithSeed(n, []rune("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))</span>
}

func RandLowerLetterNumbers(n int) string <span class="cov1" title="3">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return RandStringWithSeed(n, []rune("0123456789abcdefghijklmnopqrstuvwxyz"))</span>
}

func RandUpperLetterNumbers(n int) string <span class="cov1" title="3">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov1" title="1">return RandStringWithSeed(n, []rune("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"))</span>
}

func RandStringWithSeed(n int, seed []rune) string <span class="cov4" title="119">{
        if n &lt;= 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov4" title="117">if len(seed) == 0 </span><span class="cov1" title="2">{
                return ""
        }</span>
        <span class="cov4" title="115">b := make([]rune, n)
        for i := range b </span><span class="cov10" title="1012011">{
                b[i] = seed[rand.Intn(len(seed))]
        }</span>
        <span class="cov4" title="115">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package stringx

import (
        "bytes"
        "strconv"
        "strings"
        "unicode"
        "unsafe"
)

func ToString(b []byte) string <span class="cov2" title="5">{
        if b == nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov2" title="4">if len(b) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov2" title="3">return *(*string)(unsafe.Pointer(&amp;b))</span>
}

func ToBytes(s string) []byte <span class="cov2" title="4">{
        if s == "" </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov2" title="3">return *(*[]byte)(unsafe.Pointer(&amp;s))</span>
}

// Camel2Snake  - 
func Camel2Snake(s string) string <span class="cov3" title="11">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        // ASCII
        <span class="cov3" title="10">if isASCII(s) </span><span class="cov3" title="10">{
                return optimizedASCIICamel2Snake(s)
        }</span>
        
        // Unicode
        <span class="cov0" title="0">capacity := len(s) + len(s)/3
        result := make([]byte, 0, capacity)
        
        for i, r := range s </span><span class="cov0" title="0">{
                if unicode.IsUpper(r) </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                result = append(result, '_')
                        }</span>
                        <span class="cov0" title="0">result = append(result, byte(unicode.ToLower(r)))</span>
                } else<span class="cov0" title="0"> {
                        if r &lt; 128 </span><span class="cov0" title="0">{
                                result = append(result, byte(r))
                        }</span> else<span class="cov0" title="0"> {
                                // ASCII
                                charBytes := []byte(string(r))
                                result = append(result, charBytes...)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return *(*string)(unsafe.Pointer(&amp;result))</span>
}

// Snake2Camel 
func Snake2Camel(s string) string <span class="cov3" title="10">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov3" title="9">var b bytes.Buffer
        upper := true
        for _, v := range s </span><span class="cov5" title="120">{
                if v == '_' </span><span class="cov3" title="12">{
                        upper = true
                }</span> else<span class="cov5" title="108"> {
                        if upper </span><span class="cov3" title="17">{
                                b.WriteRune(unicode.ToUpper(v))
                                upper = false
                        }</span> else<span class="cov5" title="91"> {
                                b.WriteRune(v)
                        }</span>
                }
        }
        <span class="cov3" title="9">return b.String()</span>
}

// Snake2SmallCamel 
func Snake2SmallCamel(s string) string <span class="cov3" title="11">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov3" title="10">var b bytes.Buffer
        upper := false
        isFirst := true
        for _, v := range s </span><span class="cov5" title="130">{
                if v == '_' </span><span class="cov3" title="13">{
                        upper = true
                }</span> else<span class="cov5" title="117"> {
                        if isFirst </span><span class="cov3" title="10">{
                                isFirst = false
                                b.WriteRune(unicode.ToLower(v))
                                upper = false // Reset upper flag after first character
                        }</span> else<span class="cov5" title="107"> if upper </span><span class="cov3" title="9">{
                                b.WriteRune(unicode.ToUpper(v))
                                upper = false
                        }</span> else<span class="cov5" title="98"> {
                                // Convert to lowercase for consistency in camelCase
                                b.WriteRune(unicode.ToLower(v))
                        }</span>
                }
        }
        <span class="cov3" title="10">return b.String()</span>
}

// ToSnake  - 
func ToSnake(s string) string <span class="cov4" title="25">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        // 
        <span class="cov4" title="24">capacity := len(s) + len(s)/4  // 25%
        if capacity &gt; 256 </span><span class="cov0" title="0">{
                capacity = 256 // 
        }</span>
        
        //  []byte  bytes.Buffer
        <span class="cov4" title="24">result := make([]byte, 0, capacity)
        runes := []rune(s)
        
        for i, r := range runes </span><span class="cov6" title="253">{
                if unicode.IsLetter(r) || unicode.IsNumber(r) </span><span class="cov6" title="230">{
                        // 
                        if i &gt; 0 </span><span class="cov6" title="208">{
                                prev := runes[i-1]
                                if (unicode.IsUpper(r) &amp;&amp; unicode.IsLetter(prev)) ||
                                        (unicode.IsNumber(r) &amp;&amp; unicode.IsLetter(prev)) ||
                                        (unicode.IsLetter(r) &amp;&amp; unicode.IsNumber(prev)) </span><span class="cov4" title="38">{
                                        result = append(result, '_')
                                }</span>
                        }
                        
                        // 
                        <span class="cov6" title="230">if unicode.IsUpper(r) </span><span class="cov4" title="49">{
                                result = append(result, byte(unicode.ToLower(r)))
                        }</span> else<span class="cov6" title="181"> {
                                // ASCIIUnicode
                                if r &lt; 128 </span><span class="cov5" title="164">{
                                        result = append(result, byte(r))
                                }</span> else<span class="cov3" title="17"> {
                                        // ASCIIUnicode
                                        lowerStr := string(unicode.ToLower(r))
                                        result = append(result, lowerStr...)
                                }</span>
                        }
                } else<span class="cov4" title="23"> {
                        // 
                        if len(result) &gt; 0 &amp;&amp; result[len(result)-1] != '_' </span><span class="cov3" title="11">{
                                result = append(result, '_')
                        }</span>
                }
        }
        
        // 
        <span class="cov4" title="24">return *(*string)(unsafe.Pointer(&amp;result))</span>
}

// ToKebab - ToSnake
func ToKebab(s string) string <span class="cov3" title="10">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        //  ToSnake 
        <span class="cov3" title="9">snakeResult := ToSnake(s)
        
        // 
        if !strings.Contains(snakeResult, "_") </span><span class="cov1" title="1">{
                return snakeResult
        }</span>
        
        // 
        <span class="cov3" title="8">resultBytes := []byte(snakeResult)
        for i, b := range resultBytes </span><span class="cov5" title="121">{
                if b == '_' </span><span class="cov4" title="22">{
                        resultBytes[i] = '-'
                }</span>
        }
        
        <span class="cov3" title="8">return *(*string)(unsafe.Pointer(&amp;resultBytes))</span>
}

// ToCamel 
func ToCamel(s string) string <span class="cov3" title="16">{
        var b bytes.Buffer
        upper := true
        prevWasNumber := false
        for _, v := range s </span><span class="cov5" title="149">{
                if unicode.IsLetter(v) || unicode.IsNumber(v) </span><span class="cov5" title="124">{
                        if upper || (prevWasNumber &amp;&amp; unicode.IsLetter(v)) </span><span class="cov4" title="27">{
                                if unicode.IsLetter(v) </span><span class="cov4" title="26">{
                                        b.WriteRune(unicode.ToUpper(v))
                                }</span> else<span class="cov1" title="1"> {
                                        b.WriteRune(v)
                                }</span>
                                <span class="cov4" title="27">upper = false</span>
                        } else<span class="cov5" title="97"> {
                                if unicode.IsLetter(v) </span><span class="cov5" title="95">{
                                        b.WriteRune(unicode.ToLower(v))
                                }</span> else<span class="cov1" title="2"> {
                                        b.WriteRune(v)
                                }</span>
                        }
                        <span class="cov5" title="124">prevWasNumber = unicode.IsNumber(v)</span>
                } else<span class="cov4" title="25"> {
                        upper = true
                        prevWasNumber = false
                }</span>
        }
        <span class="cov3" title="16">return b.String()</span>
}

func ToSlash(s string) string <span class="cov3" title="8">{
        var b bytes.Buffer
        runes := []rune(s)
        for i, v := range runes </span><span class="cov5" title="88">{
                if unicode.IsLetter(v) || unicode.IsNumber(v) </span><span class="cov5" title="83">{
                        needsSlash := false
                        
                        // Check if we need a slash before this character
                        if i &gt; 0 </span><span class="cov5" title="76">{
                                prev := runes[i-1]
                                // Add slash for uppercase letters (camelCase -&gt; camel/case)
                                if unicode.IsUpper(v) &amp;&amp; unicode.IsLetter(prev) </span><span class="cov3" title="11">{
                                        needsSlash = true
                                }</span>
                                // Add slash when transitioning from letter to number
                                <span class="cov5" title="76">if unicode.IsNumber(v) &amp;&amp; unicode.IsLetter(prev) </span><span class="cov1" title="1">{
                                        needsSlash = true
                                }</span>
                                // Add slash when transitioning from number to letter  
                                <span class="cov5" title="76">if unicode.IsLetter(v) &amp;&amp; unicode.IsNumber(prev) </span><span class="cov1" title="1">{
                                        needsSlash = true
                                }</span>
                        }
                        
                        <span class="cov5" title="83">if needsSlash </span><span class="cov3" title="13">{
                                b.WriteRune('/')
                        }</span>
                        
                        <span class="cov5" title="83">if unicode.IsUpper(v) </span><span class="cov3" title="20">{
                                b.WriteRune(unicode.ToLower(v))
                        }</span> else<span class="cov5" title="63"> {
                                b.WriteRune(v)
                        }</span>
                } else<span class="cov2" title="5"> {
                        // Only add slash if the last character wasn't a slash
                        if b.Len() &gt; 0 </span><span class="cov2" title="5">{
                                lastRune := []rune(b.String())
                                if len(lastRune) == 0 || lastRune[len(lastRune)-1] != '/' </span><span class="cov2" title="3">{
                                        b.WriteRune('/')
                                }</span>
                        }
                }
        }
        <span class="cov3" title="8">return b.String()</span>
}

func ToDot(s string) string <span class="cov3" title="8">{
        var b bytes.Buffer
        runes := []rune(s)
        for i, v := range runes </span><span class="cov5" title="88">{
                if unicode.IsLetter(v) || unicode.IsNumber(v) </span><span class="cov5" title="83">{
                        needsDot := false
                        
                        // Check if we need a dot before this character
                        if i &gt; 0 </span><span class="cov5" title="76">{
                                prev := runes[i-1]
                                // Add dot for uppercase letters (camelCase -&gt; camel.case)
                                if unicode.IsUpper(v) &amp;&amp; unicode.IsLetter(prev) </span><span class="cov3" title="11">{
                                        needsDot = true
                                }</span>
                                // Add dot when transitioning from letter to number
                                <span class="cov5" title="76">if unicode.IsNumber(v) &amp;&amp; unicode.IsLetter(prev) </span><span class="cov1" title="1">{
                                        needsDot = true
                                }</span>
                                // Add dot when transitioning from number to letter  
                                <span class="cov5" title="76">if unicode.IsLetter(v) &amp;&amp; unicode.IsNumber(prev) </span><span class="cov1" title="1">{
                                        needsDot = true
                                }</span>
                        }
                        
                        <span class="cov5" title="83">if needsDot </span><span class="cov3" title="13">{
                                b.WriteRune('.')
                        }</span>
                        
                        <span class="cov5" title="83">if unicode.IsUpper(v) </span><span class="cov3" title="20">{
                                b.WriteRune(unicode.ToLower(v))
                        }</span> else<span class="cov5" title="63"> {
                                b.WriteRune(v)
                        }</span>
                } else<span class="cov2" title="5"> {
                        // Only add dot if the last character wasn't a dot
                        if b.Len() &gt; 0 </span><span class="cov2" title="5">{
                                lastRune := []rune(b.String())
                                if len(lastRune) == 0 || lastRune[len(lastRune)-1] != '.' </span><span class="cov2" title="3">{
                                        b.WriteRune('.')
                                }</span>
                        }
                }
        }
        <span class="cov3" title="8">return b.String()</span>
}

// ToSmallCamel 
func ToSmallCamel(s string) string <span class="cov3" title="11">{
        var b bytes.Buffer
        upper := false
        isFirst := true
        prevWasNumber := false
        for _, v := range s </span><span class="cov5" title="126">{
                if unicode.IsLetter(v) || unicode.IsNumber(v) </span><span class="cov5" title="113">{
                        if isFirst </span><span class="cov3" title="10">{
                                isFirst = false
                                if unicode.IsLetter(v) </span><span class="cov3" title="9">{
                                        b.WriteRune(unicode.ToLower(v))
                                }</span> else<span class="cov1" title="1"> {
                                        b.WriteRune(v)
                                }</span>
                                <span class="cov3" title="10">upper = false</span>
                        } else<span class="cov5" title="103"> if upper || (prevWasNumber &amp;&amp; unicode.IsLetter(v)) </span><span class="cov3" title="10">{
                                if unicode.IsLetter(v) </span><span class="cov3" title="10">{
                                        b.WriteRune(unicode.ToUpper(v))
                                }</span> else<span class="cov0" title="0"> {
                                        b.WriteRune(v)
                                }</span>
                                <span class="cov3" title="10">upper = false</span>
                        } else<span class="cov5" title="93"> {
                                if unicode.IsLetter(v) </span><span class="cov5" title="91">{
                                        b.WriteRune(unicode.ToLower(v))
                                }</span> else<span class="cov1" title="2"> {
                                        b.WriteRune(v)
                                }</span>
                        }
                        <span class="cov5" title="113">prevWasNumber = unicode.IsNumber(v)</span>
                } else<span class="cov3" title="13"> if !isFirst </span><span class="cov3" title="11">{
                        upper = true
                        prevWasNumber = false
                }</span>
        }
        <span class="cov3" title="11">return b.String()</span>
}

// SplitLen  - 
func SplitLen(s string, max int) []string <span class="cov2" title="6">{
        if max &lt;= 0 </span><span class="cov1" title="2">{
                return []string{s}
        }</span>
        <span class="cov2" title="4">if s == "" </span><span class="cov1" title="1">{
                return []string{}
        }</span>
        
        <span class="cov2" title="3">runes := []rune(s)
        totalRunes := len(runes)
        if totalRunes &lt;= max </span><span class="cov0" title="0">{
                return []string{s}
        }</span>
        
        // 
        <span class="cov2" title="3">estimatedParts := (totalRunes + max - 1) / max
        result := make([]string, 0, estimatedParts)
        
        for start := 0; start &lt; totalRunes; start += max </span><span class="cov3" title="9">{
                end := start + max
                if end &gt; totalRunes </span><span class="cov1" title="1">{
                        end = totalRunes
                }</span>
                
                // 
                <span class="cov3" title="9">part := string(runes[start:end])
                result = append(result, part)</span>
        }
        
        <span class="cov2" title="3">return result</span>
}

// Shorten 
func Shorten(s string, max int) string <span class="cov2" title="6">{
        if max &lt; 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov2" title="5">if len(s) &lt;= max </span><span class="cov1" title="2">{
                return s
        }</span>
        <span class="cov2" title="3">return s[:max]</span>
}

func ShortenShow(s string, max int) string <span class="cov2" title="6">{
        if max &lt; 0 </span><span class="cov1" title="1">{
                return "..."
        }</span>
        <span class="cov2" title="5">if len(s) &lt;= max </span><span class="cov1" title="2">{
                return s
        }</span>
        <span class="cov2" title="3">if max &lt; 3 </span><span class="cov1" title="1">{
                return "..."
        }</span>
        <span class="cov1" title="2">return s[:max-3] + "..."</span>
}

func IsUpper[M string | []rune](r M) bool <span class="cov3" title="16">{
        return string(r) == strings.ToUpper(string(r))
}</span>

func IsDigit[M string | []rune](r M) bool <span class="cov3" title="15">{
        for _, i := range []rune(r) </span><span class="cov4" title="22">{
                if !unicode.IsDigit(i) </span><span class="cov3" title="9">{
                        return false
                }</span>
        }

        <span class="cov2" title="6">return true</span>
}

func Reverse(s string) string <span class="cov3" title="15">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        
        // ASCII
        <span class="cov3" title="14">if isASCII(s) </span><span class="cov2" title="6">{
                return reverseASCII(s)
        }</span>
        
        // Unicode - 
        <span class="cov3" title="8">runes := []rune(s)
        for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov3" title="19">{
                runes[i], runes[j] = runes[j], runes[i]
        }</span>
        <span class="cov3" title="8">return string(runes)</span>
}

func Quote(s string) string <span class="cov3" title="12">{
        return strconv.Quote(s)
}</span>

func QuotePure(s string) string <span class="cov2" title="6">{
        return strings.TrimPrefix(strings.TrimSuffix(Quote(s), `"`), `"`)
}</span>

// ASCII
func isASCII(s string) bool <span class="cov4" title="24">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov10" title="10108">{
                if s[i] &gt;= 128 </span><span class="cov3" title="8">{
                        return false
                }</span>
        }
        <span class="cov3" title="16">return true</span>
}

// ASCIICamel2Snake
func optimizedASCIICamel2Snake(s string) string <span class="cov3" title="10">{
        capacity := len(s) + len(s)/3
        result := make([]byte, 0, capacity)
        
        for i := 0; i &lt; len(s); i++ </span><span class="cov5" title="71">{
                c := s[i]
                if c &gt;= 'A' &amp;&amp; c &lt;= 'Z' </span><span class="cov4" title="23">{
                        if i &gt; 0 </span><span class="cov3" title="17">{
                                result = append(result, '_')
                        }</span>
                        <span class="cov4" title="23">result = append(result, c+32)</span> // 
                } else<span class="cov4" title="48"> {
                        result = append(result, c)
                }</span>
        }
        
        <span class="cov3" title="10">return *(*string)(unsafe.Pointer(&amp;result))</span>
}

// ASCII
func reverseASCII(s string) string <span class="cov2" title="6">{
        if len(s) &lt;= 1 </span><span class="cov1" title="1">{
                return s
        }</span>
        
        <span class="cov2" title="5">bytes := make([]byte, len(s))
        for i := 0; i &lt; len(s); i++ </span><span class="cov9" title="10026">{
                bytes[i] = s[len(s)-1-i]
        }</span>
        
        <span class="cov2" title="5">return *(*string)(unsafe.Pointer(&amp;bytes))</span>
}

</pre>
		
		<pre class="file" id="file132" style="display: none">package stringx

import (
        "strings"
)

// ContainsAny reports whether any of the UTF-8-encoded code points in chars are within s.
func ContainsAny(s, chars string) bool <span class="cov9" title="8">{
        return strings.ContainsAny(s, chars)
}</span>

// ContainsRune reports whether the Unicode code point r is within s.
func ContainsRune(s string, r rune) bool <span class="cov9" title="8">{
        return strings.ContainsRune(s, r)
}</span>

// Count counts the number of non-overlapping instances of substr in s.
func Count(s, substr string) int <span class="cov10" title="9">{
        if substr == "" </span><span class="cov3" title="2">{
                return len([]rune(s)) + 1
        }</span>
        <span class="cov8" title="7">return strings.Count(s, substr)</span>
}

// EqualFold reports whether s and t are equal under Unicode case-folding.
func EqualFold(s, t string) bool <span class="cov9" title="8">{
        return strings.EqualFold(s, t)
}</span>

// Fields splits the string s around each instance of one or more consecutive white space characters.
func Fields(s string) []string <span class="cov8" title="7">{
        return strings.Fields(s)
}</span>

// FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c).
func FieldsFunc(s string, f func(rune) bool) []string <span class="cov6" title="4">{
        if f == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov5" title="3">return strings.FieldsFunc(s, f)</span>
}

// HasPrefix tests whether the string s begins with prefix.
func HasPrefix(s, prefix string) bool <span class="cov8" title="7">{
        return strings.HasPrefix(s, prefix)
}</span>

// HasSuffix tests whether the string s ends with suffix.
func HasSuffix(s, suffix string) bool <span class="cov8" title="7">{
        return strings.HasSuffix(s, suffix)
}</span>

// Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.
func Index(s, substr string) int <span class="cov9" title="8">{
        return strings.Index(s, substr)
}</span>

// IndexAny returns the index of the first instance of any Unicode code point from chars in s,
// or -1 if no Unicode code point from chars is present in s.
func IndexAny(s, chars string) int <span class="cov8" title="7">{
        return strings.IndexAny(s, chars)
}</span>

// LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.
func LastIndex(s, substr string) int <span class="cov9" title="8">{
        return strings.LastIndex(s, substr)
}</span>

// LastIndexAny returns the index of the last instance of any Unicode code point from chars in s,
// or -1 if no Unicode code point from chars is present in s.
func LastIndexAny(s, chars string) int <span class="cov8" title="6">{
        return strings.LastIndexAny(s, chars)
}</span>

// Repeat returns a new string consisting of count copies of the string s.
func Repeat(s string, count int) string <span class="cov8" title="6">{
        if count &lt; 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov7" title="5">return strings.Repeat(s, count)</span>
}

// Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new.
func Replace(s, old, new string, n int) string <span class="cov8" title="7">{
        return strings.Replace(s, old, new, n)
}</span>

// ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new.
func ReplaceAll(s, old, new string) string <span class="cov7" title="5">{
        return strings.ReplaceAll(s, old, new)
}</span>

// Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.
func Split(s, sep string) []string <span class="cov8" title="6">{
        return strings.Split(s, sep)
}</span>

// SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings.
func SplitAfter(s, sep string) []string <span class="cov7" title="5">{
        return strings.SplitAfter(s, sep)
}</span>

// SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators.
func SplitN(s, sep string, n int) []string <span class="cov8" title="6">{
        return strings.SplitN(s, sep, n)
}</span>

// SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings.
func SplitAfterN(s, sep string, n int) []string <span class="cov8" title="6">{
        return strings.SplitAfterN(s, sep, n)
}</span>

// Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.
func Title(s string) string <span class="cov8" title="6">{
        return strings.Title(s)
}</span>

// ToLower returns s with all Unicode letters mapped to their lower case.
func ToLower(s string) string <span class="cov8" title="6">{
        return strings.ToLower(s)
}</span>

// ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.
func ToTitle(s string) string <span class="cov8" title="6">{
        return strings.ToTitle(s)
}</span>

// ToUpper returns s with all Unicode letters mapped to their upper case.
func ToUpper(s string) string <span class="cov8" title="6">{
        return strings.ToUpper(s)
}</span>

// Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.
func Trim(s, cutset string) string <span class="cov8" title="6">{
        return strings.Trim(s, cutset)
}</span>

// TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.
func TrimLeft(s, cutset string) string <span class="cov8" title="6">{
        return strings.TrimLeft(s, cutset)
}</span>

// TrimRight returns a slice of the string s with all trailing Unicode code points contained in cutset removed.
func TrimRight(s, cutset string) string <span class="cov8" title="6">{
        return strings.TrimRight(s, cutset)
}</span>

// TrimSpace returns a slice of the string s, with all leading and trailing white space removed.
func TrimSpace(s string) string <span class="cov8" title="6">{
        return strings.TrimSpace(s)
}</span>

// TrimPrefix returns s without the provided leading prefix string.
func TrimPrefix(s, prefix string) string <span class="cov7" title="5">{
        return strings.TrimPrefix(s, prefix)
}</span>

// TrimSuffix returns s without the provided trailing suffix string.
func TrimSuffix(s, suffix string) string <span class="cov7" title="5">{
        return strings.TrimSuffix(s, suffix)
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">package stringx

import "unicode"

func AllDigit(s string) bool <span class="cov7" title="13">{
        if s == "" </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov6" title="11">for _, c := range s </span><span class="cov8" title="24">{
                if !unicode.IsDigit(c) </span><span class="cov5" title="8">{
                        return false
                }</span>
        }
        <span class="cov3" title="3">return true</span>
}

func HasDigit(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov9" title="38">{
                if unicode.IsDigit(c) </span><span class="cov5" title="6">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func AllLetter(s string) bool <span class="cov7" title="13">{
        for _, c := range s </span><span class="cov9" title="35">{
                if !unicode.IsLetter(c) </span><span class="cov5" title="6">{
                        return false
                }</span>
        }
        <span class="cov5" title="7">return true</span>
}

func HasLetter(s string) bool <span class="cov7" title="13">{
        for _, c := range s </span><span class="cov8" title="24">{
                if unicode.IsLetter(c) </span><span class="cov5" title="8">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func AllSpace(s string) bool <span class="cov6" title="12">{
        for _, c := range s </span><span class="cov7" title="18">{
                if !unicode.IsSpace(c) </span><span class="cov3" title="3">{
                        return false
                }</span>
        }
        <span class="cov6" title="9">return true</span>
}

func HasSpace(s string) bool <span class="cov6" title="12">{
        for _, c := range s </span><span class="cov9" title="31">{
                if unicode.IsSpace(c) </span><span class="cov5" title="8">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllSymbol(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov7" title="17">{
                if !unicode.IsSymbol(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov5" title="7">return true</span>
}

func HasSymbol(s string) bool <span class="cov6" title="9">{
        for _, c := range s </span><span class="cov8" title="27">{
                if unicode.IsSymbol(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllMark(s string) bool <span class="cov5" title="7">{
        for _, c := range s </span><span class="cov5" title="8">{
                if !unicode.IsMark(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov3" title="3">return true</span>
}

func HasMark(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov8" title="30">{
                if unicode.IsMark(c) </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        <span class="cov6" title="9">return false</span>
}

func AllPunct(s string) bool <span class="cov6" title="10">{
        for _, c := range s </span><span class="cov8" title="24">{
                if !unicode.IsPunct(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov5" title="6">return true</span>
}

func HasPunct(s string) bool <span class="cov6" title="9">{
        for _, c := range s </span><span class="cov9" title="37">{
                if unicode.IsPunct(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllGraphic(s string) bool <span class="cov6" title="12">{
        for _, c := range s </span><span class="cov9" title="34">{
                if !unicode.IsGraphic(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov5" title="8">return true</span>
}

func HasGraphic(s string) bool <span class="cov6" title="9">{
        for _, c := range s </span><span class="cov6" title="10">{
                if unicode.IsGraphic(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllPrint(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov9" title="32">{
                if !unicode.IsPrint(c) </span><span class="cov3" title="3">{
                        return false
                }</span>
        }
        <span class="cov5" title="8">return true</span>
}

func HasPrint(s string) bool <span class="cov6" title="9">{
        for _, c := range s </span><span class="cov6" title="11">{
                if unicode.IsPrint(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllControl(s string) bool <span class="cov5" title="8">{
        for _, c := range s </span><span class="cov6" title="10">{
                if !unicode.IsControl(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov4" title="4">return true</span>
}

func HasControl(s string) bool <span class="cov5" title="8">{
        for _, c := range s </span><span class="cov8" title="23">{
                if unicode.IsControl(c) </span><span class="cov4" title="4">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

func AllUpper(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov8" title="27">{
                if !unicode.IsUpper(c) </span><span class="cov5" title="6">{
                        return false
                }</span>
        }
        <span class="cov4" title="5">return true</span>
}

func HasUpper(s string) bool <span class="cov6" title="10">{
        for _, c := range s </span><span class="cov8" title="24">{
                if unicode.IsUpper(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func AllLower(s string) bool <span class="cov6" title="11">{
        for _, c := range s </span><span class="cov8" title="26">{
                if !unicode.IsLower(c) </span><span class="cov5" title="6">{
                        return false
                }</span>
        }
        <span class="cov4" title="5">return true</span>
}

func HasLower(s string) bool <span class="cov6" title="10">{
        for _, c := range s </span><span class="cov8" title="26">{
                if unicode.IsLower(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func AllTitle(s string) bool <span class="cov5" title="7">{
        for _, c := range s </span><span class="cov5" title="7">{
                if !unicode.IsTitle(c) </span><span class="cov4" title="4">{
                        return false
                }</span>
        }
        <span class="cov3" title="3">return true</span>
}

func HasTitle(s string) bool <span class="cov5" title="7">{
        for _, c := range s </span><span class="cov7" title="16">{
                if unicode.IsTitle(c) </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

func AllLetterOrDigit(s string) bool <span class="cov6" title="11">{
        if s == "" </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov6" title="9">for _, c := range s </span><span class="cov10" title="46">{
                if !unicode.IsLetter(c) &amp;&amp; !unicode.IsDigit(c) </span><span class="cov3" title="3">{
                        return false
                }</span>
        }
        <span class="cov5" title="6">return true</span>
}

func HasLetterOrDigit(s string) bool <span class="cov6" title="10">{
        for _, c := range s </span><span class="cov7" title="19">{
                if unicode.IsLetter(c) || unicode.IsDigit(c) </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package stringx

import "unicode/utf16"

func Utf16Len[M string | []rune | []byte](str M) int <span class="cov10" title="4135">{
        s := string(str)
        if s == "" </span><span class="cov3" title="9">{
                return 0
        }</span>
        <span class="cov9" title="4126">return len(utf16.Encode([]rune(s)))</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package unit

import (
        "fmt"
)

const (
        Byte = 1
        KB   = 1024 * Byte
        MB   = 1024 * KB
        GB   = 1024 * MB
        TB   = 1024 * GB
        PB   = 1024 * TB
        EB   = 1024 * PB
)

const (
        Bit = 8 * Byte
        Kb  = 1024 * Bit
        Mb  = 1024 * Kb
        Gb  = 1024 * Mb
        Tb  = 1024 * Gb
        Pb  = 1024 * Tb
        Eb  = 1024 * Pb
)

func FormatSpeed(speed float64) string <span class="cov0" title="0">{
        return Format2bps(speed)
}</span>

func Format2bps(speed float64) string <span class="cov0" title="0">{
        if speed &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span> else<span class="cov0" title="0"> if speed &lt; Kb/8 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f bps", speed*8)
        }</span> else<span class="cov0" title="0"> if speed &lt; Mb/8 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f Kbps", speed*8/Kb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Gb/8 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f Mbps", speed*8/Mb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Tb/8 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f Gbps", speed*8/Gb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Pb/8 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f Tbps", speed*8/Tb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Eb/8 </span><span class="cov0" title="0">{ //  Eb 
                return fmt.Sprintf("%.2f Pbps", speed*8/Pb)
        }</span> else<span class="cov0" title="0"> { //  Eb 
                return fmt.Sprintf("%.2f Ebps", speed*8/Eb)
        }</span>
}

func Format2Bs(speed float64) string <span class="cov0" title="0">{
        if speed &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span> else<span class="cov0" title="0"> if speed &lt; Kb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f B/s", speed)
        }</span> else<span class="cov0" title="0"> if speed &lt; Mb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f KB/s", speed/Kb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Gb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f MB/s", speed/Mb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Tb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f GB/s", speed/Gb)
        }</span> else<span class="cov0" title="0"> if speed &lt; Pb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f TB/s", speed/Tb)
        }</span> else<span class="cov0" title="0"> { // if speed &lt; EB
                return fmt.Sprintf("%.2f PB/s", speed/Pb)
        }</span>
}

func FormatSize(fileSize int64) string <span class="cov0" title="0">{
        return Format2B(fileSize)
}</span>

func Format2b(fileSize int64) string <span class="cov0" title="0">{
        if fileSize &lt; 0 </span><span class="cov0" title="0">{
                return ""
        }</span> else<span class="cov0" title="0"> if fileSize &lt; Kb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fb", float64(fileSize))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; Mb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fKb", float64(fileSize)/float64(Kb))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; Gb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fMb", float64(fileSize)/float64(Mb))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; Tb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fGb", float64(fileSize)/float64(Gb))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; Pb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fTb", float64(fileSize)/float64(Tb))
        }</span> else<span class="cov0" title="0"> { // if fileSize &lt; Eb
                return fmt.Sprintf("%.2fPb", float64(fileSize)/float64(Pb))
        }</span>
}

func Format2B(fileSize int64) string <span class="cov0" title="0">{
        if fileSize &lt; 0 </span><span class="cov0" title="0">{
                return ""
        }</span> else<span class="cov0" title="0"> if fileSize &lt; KB </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f KB", float64(fileSize)) // :  "%.2fB"  "%.2f KB"
        }</span> else<span class="cov0" title="0"> if fileSize &lt; MB </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f KB", float64(fileSize)/float64(KB))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; GB </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f MB", float64(fileSize)/float64(MB))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; TB </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f GB", float64(fileSize)/float64(GB))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; PB </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f TB", float64(fileSize)/float64(TB))
        }</span> else<span class="cov0" title="0"> if fileSize &lt; EB </span><span class="cov0" title="0">{ //  EB 
                return fmt.Sprintf("%.2f PB", float64(fileSize)/float64(PB))
        }</span> else<span class="cov0" title="0"> { //  EB 
                return fmt.Sprintf("%.2f EB", float64(fileSize)/float64(EB))
        }</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package unit

import (
        "bytes"
        "github.com/lazygophers/utils/xtime"
        "strconv"
        "time"
)

func DurationYearMonthDay(t time.Duration) string <span class="cov0" title="0">{
        years := int(t.Hours() / 24 / 365)
        t = t - time.Duration(years)*xtime.Year

        mouths := int(t.Hours() / 24 / 30)
        t = t - time.Duration(mouths)*xtime.Month

        days := int(t.Hours() / 24)
        t = t - time.Duration(days)*xtime.Day

        var b bytes.Buffer
        if years &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(years))
                b.WriteString("")
        }</span>

        <span class="cov0" title="0">if mouths &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(mouths))
                b.WriteString("")
        }</span>

        <span class="cov0" title="0">if days &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(days))
                b.WriteString("")
        }</span>

        // 0
        <span class="cov0" title="0">if b.Len() == 0 </span><span class="cov0" title="0">{
                b.WriteString("0")
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func DurationMonthDayHour(t time.Duration) string <span class="cov0" title="0">{
        mouths := int(t.Hours() / 24 / 30)
        t = t - time.Duration(mouths)*xtime.Month

        days := int(t.Hours() / 24)
        t = t - time.Duration(days)*xtime.Day

        hours := int(t.Hours())
        t = t - time.Duration(hours)*xtime.Hour

        var b bytes.Buffer
        if mouths &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(mouths))
                b.WriteString("")
        }</span>

        <span class="cov0" title="0">if days &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(days))
                b.WriteString("")
        }</span>

        <span class="cov0" title="0">if hours &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(hours))
                b.WriteString("")
        }</span>

        // 0
        <span class="cov0" title="0">if b.Len() == 0 </span><span class="cov0" title="0">{
                b.WriteString("0")
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func DurationMinuteSecond(t time.Duration) string <span class="cov0" title="0">{
        minutes := int(t.Minutes())
        t = t - time.Duration(minutes)*xtime.Minute

        seconds := t.Seconds()

        var b bytes.Buffer
        if minutes &gt; 1 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(minutes))
                b.WriteString("")
        }</span>

        <span class="cov0" title="0">if seconds &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(int(seconds)))
                b.WriteString("")
        }</span>

        // 0
        <span class="cov0" title="0">if b.Len() == 0 </span><span class="cov0" title="0">{
                b.WriteString("0")
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func DurationYearMonthDayHourMinuteSecond(t time.Duration) string <span class="cov0" title="0">{
        years := int(t.Hours() / 24 / 365)
        t = t - time.Duration(years)*xtime.Year

        mouths := int(t.Hours() / 24 / 30)
        t = t - time.Duration(mouths)*xtime.Month

        days := int(t.Hours() / 24)
        t = t - time.Duration(days)*xtime.Day

        hours := int(t.Hours())
        t = t - time.Duration(hours)*xtime.Hour

        minutes := int(t.Minutes())
        t = t - time.Duration(minutes)*xtime.Minute

        seconds := t.Seconds()

        var b bytes.Buffer
        if years &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(years))
                b.WriteString("")
        }</span>

        <span class="cov0" title="0">if mouths &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(mouths))
                b.WriteString("")
        }</span>

        <span class="cov0" title="0">if days &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(days))
                b.WriteString("")
        }</span>

        <span class="cov0" title="0">if hours &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(hours))
                b.WriteString("")
        }</span>

        <span class="cov0" title="0">if minutes &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(minutes))
                b.WriteString("")
        }</span>

        <span class="cov0" title="0">if seconds &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(strconv.Itoa(int(seconds)))
                b.WriteString("")
        }</span>

        // 0
        <span class="cov0" title="0">if b.Len() == 0 </span><span class="cov0" title="0">{
                b.WriteString("0")
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func TimeYearMonthDayHourMinute(t time.Time) string <span class="cov0" title="0">{
        return t.Format("200601021504")
}</span>

func TimeYearMonthDayHourMinuteSecond(t time.Time) string <span class="cov0" title="0">{
        return t.Format("20060102150405")
}</span>
</pre>
		
		<pre class="file" id="file137" style="display: none">package urlx

import (
        "github.com/lazygophers/utils/candy"
        "net/url"
)

// SortQuery URL
func SortQuery(query url.Values) url.Values <span class="cov0" title="0">{
        if len(query) == 0 </span><span class="cov0" title="0">{
                return query
        }</span>

        <span class="cov0" title="0">keys := make([]string, 0, len(query))
        for key := range query </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>

        <span class="cov0" title="0">nq := url.Values{}
        for _, key := range candy.Sort(keys) </span><span class="cov0" title="0">{
                nq.Set(key, query.Get(key))
        }</span>

        <span class="cov0" title="0">return nq</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">// validate go-playground/validator
package utils

import (
        "github.com/go-playground/validator/v10"
        "github.com/lazygophers/log"
)

// Validate
//
// :
//   - m: 
//
// :
//   - error: 
//
// 
var validate = validator.New()

func Validate(m interface{}) (err error) <span class="cov0" title="0">{
        err = validate.Struct(m)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
