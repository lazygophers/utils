# Config Package - Configuration Management

> 这是 config 目录的 llms.txt 文件，用于帮助语言模型理解该目录的结构和内容。


这是 config 目录的 llms.txt 文件，用于帮助语言模型理解该目录的结构和内容。


## Overview
The config package provides comprehensive configuration management with support for multiple file formats, environment variables, and validation.

## Supported Formats
- **JSON**: `.json` files with nested object support
- **YAML**: `.yaml/.yml` files with complex data structures  
- **TOML**: `.toml` files with section-based organization
- **INI**: `.ini` files with key-value pairs
- **Environment Variables**: System environment variable integration

## Core Functions
- **LoadConfig[T](path, config)**: Load and validate configuration from file
- **LoadConfigSkipValidate[T](path, config)**: Load configuration without validation
- **SaveConfig[T](path, config)**: Save configuration to file
- **MergeConfig[T](base, override)**: Merge multiple configurations

## Code Examples

```go
import "github.com/lazygophers/utils/config"

// Define configuration structure
type AppConfig struct {
    Server struct {
        Port int    `json:"port" yaml:"port" validate:"min=1,max=65535"`
        Host string `json:"host" yaml:"host" validate:"required"`
    } `json:"server" yaml:"server"`
    
    Database struct {
        URL      string `json:"url" yaml:"url" validate:"required,url"`
        MaxConns int    `json:"max_conns" yaml:"max_conns" validate:"min=1"`
    } `json:"database" yaml:"database"`
}

// Load configuration with validation
var cfg AppConfig
err := config.LoadConfig("config.json", &cfg)
if err != nil {
    log.Fatal("Failed to load config:", err)
}

// Load without validation for flexible configurations
err = config.LoadConfigSkipValidate("config.yaml", &cfg)

// Save configuration
err = config.SaveConfig("output.json", &cfg)
```

## Configuration Loading Strategy

### Search Order
1. Specified file path (if provided)
2. Environment variable `LAZYGOPHERS_CONFIG`
3. Current working directory (`./config/`)
4. Executable directory
5. Default configuration (if no file found)

### Format Detection
- Automatic format detection based on file extension
- Support for custom parsers and validators
- Graceful fallback for unsupported formats

## Environment Variable Integration

### Env Tag Support

The config package supports the `env` tag for environment variable overrides. Environment variables take precedence over file values.

```go
// Basic environment variable override
type Config struct {
    Port     int    `json:"port" env:"APP_PORT"`
    LogLevel string `json:"log_level" env:"LOG_LEVEL"`
    Debug    bool   `json:"debug" env:"DEBUG"`
}

// Load with environment variable support
cfg := Config{}
config.LoadConfigSkipValidate("config.json", &cfg)
// File values are loaded first, then environment variables override them
// If APP_PORT=9000 is set, Port will be 9000 regardless of the JSON value
```

### Override Priority

When loading configuration:
1. **File Configuration**: Load from config file (JSON, YAML, TOML, INI, etc.)
2. **Environment Variable Override**: Environment variables with matching `env` tag names override file values
3. **If Env Variable is Empty**: File value is used (empty env vars don't override)
4. **If Env Variable is Invalid**: File value is retained (conversion errors are logged and ignored)

### Nested Struct Support

Environment variables work with nested structures using the field's `env` tag directly:

```go
type Config struct {
    Name string `json:"name" env:"APP_NAME"`
    Database struct {
        Host     string `json:"host" env:"DB_HOST"`
        Port     int    `json:"port" env:"DB_PORT"`
        Username string `json:"username" env:"DB_USER"`
        Password string `json:"password" env:"DB_PASS"`
    } `json:"database" env:"database"`
}

// Example with environment variables:
// APP_NAME=my-app
// DB_HOST=prod-db.example.com
// DB_PORT=5432
// DB_USER=prod_user
// DB_PASS=secret_pass

// Usage:
cfg := Config{}
config.LoadConfigSkipValidate("config.json", &cfg)
// cfg.Name will be "my-app" (from env APP_NAME)
// cfg.Database.Host will be "prod-db.example.com" (from env DB_HOST)
// cfg.Database.Port will be 5432 (from env DB_PORT)
```

### Practical Example

**config.json:**
```json
{
    "name": "default-app",
    "port": 8080,
    "debug": false,
    "database": {
        "host": "localhost",
        "port": 5432,
        "username": "user",
        "password": "pass"
    }
}
```

**Go Code:**
```go
type Config struct {
    Name  string `json:"name" env:"APP_NAME"`
    Port  int    `json:"port" env:"PORT"`
    Debug bool   `json:"debug" env:"DEBUG"`
    Database struct {
        Host     string `json:"host" env:"DB_HOST"`
        Port     int    `json:"port" env:"DB_PORT"`
        Username string `json:"username" env:"DB_USER"`
        Password string `json:"password" env:"DB_PASS"`
    } `json:"database"`
}

cfg := Config{}
config.LoadConfigSkipValidate("config.json", &cfg)

// With environment variables set:
// export APP_NAME=production
// export PORT=9000
// export DEBUG=true
// export DB_HOST=prod.example.com

// Result:
// cfg.Name = "production" (from APP_NAME env)
// cfg.Port = 9000 (from PORT env)
// cfg.Debug = true (from DEBUG env)
// cfg.Database.Host = "prod.example.com" (from DB_HOST env)
// cfg.Database.Port = 5432 (from file, env DB_PORT not set)
// cfg.Database.Username = "user" (from file, env DB_USER not set)
// cfg.Database.Password = "pass" (from file, env DB_PASS not set)
```

## Validation Features
- **Struct Tag Validation**: Using `github.com/go-playground/validator/v10`
- **Custom Validators**: Extensible validation system
- **Nested Validation**: Deep validation of nested structures
- **Conditional Rules**: Context-aware validation rules

## Advanced Usage

```go
// Configuration merging
baseConfig := loadBaseConfig()
envConfig := loadEnvironmentOverrides()
finalConfig := config.MergeConfig(baseConfig, envConfig)

// Configuration watching (file system events)
watcher := config.NewWatcher("config.json", func(cfg *AppConfig) {
    log.Println("Configuration reloaded")
    // Handle configuration changes
})
defer watcher.Close()

// Default value population
type ConfigWithDefaults struct {
    Timeout time.Duration `json:"timeout" default:"30s"`
    Retries int          `json:"retries" default:"3"`
}
```

## Error Handling
- **Detailed Parse Errors**: Line and column information for syntax errors
- **Validation Error Aggregation**: All validation failures reported together
- **Missing File Handling**: Graceful fallback to default configurations
- **Type Conversion Errors**: Clear error messages for type mismatches

## Dependencies
- `github.com/go-playground/validator/v10` - Struct validation
- `github.com/mcuadros/go-defaults` - Default value assignment
- `github.com/lazygophers/log` - Structured logging
- Format-specific parsers (encoding/json, gopkg.in/yaml.v3, etc.)

## Use Cases
1. **Application Settings**: Runtime configuration management
2. **Feature Flags**: Dynamic feature enablement
3. **Environment-Specific Config**: Dev/staging/production configurations
4. **Service Discovery**: Dynamic service endpoint configuration
5. **Security Settings**: API keys and authentication configuration

## Performance Notes
- Lazy loading with caching for frequently accessed configs
- Minimal memory footprint for unused configuration sections
- Efficient file watching with debounced reload events