
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>anyx: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lazygophers/utils/anyx/map.go (98.6%)</option>
				
				<option value="file1">github.com/lazygophers/utils/anyx/map_any.go (99.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package anyx

import (
        "fmt"
        "reflect"

        "golang.org/x/exp/constraints"
)

type ValueType int

const (
        ValueUnknown ValueType = iota
        ValueNumber
        ValueString
        ValueBool
)

func CheckValueType(val interface{}) ValueType <span class="cov8" title="1">{
        switch val.(type) </span>{
        case bool:<span class="cov8" title="1">
                return ValueBool</span>
        case int, int8, int16, int32, int64,
                uint, uint8, uint16, uint32, uint64,
                float32, float64:<span class="cov8" title="1">
                return ValueNumber</span>
        case string, []byte:<span class="cov8" title="1">
                return ValueString</span>
        default:<span class="cov8" title="1">
                return ValueUnknown</span>
        }
}

func MapKeysString(m interface{}) []string <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                panic("nil map")</span>
        }

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.String </span><span class="cov8" title="1">{
                panic("map key type required string")</span>
        }

        <span class="cov8" title="1">result := make([]string, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, v.String())
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysUint32(m interface{}) []uint32 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                panic("nil map")</span>
        }

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint32 </span><span class="cov8" title="1">{
                panic("map key type required uint32")</span>
        }

        <span class="cov8" title="1">result := make([]uint32, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, uint32(v.Uint()))
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysUint64(m interface{}) []uint64 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint64 </span><span class="cov8" title="1">{
                panic("map key type required uint64")</span>
        }

        <span class="cov8" title="1">result := make([]uint64, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, v.Uint())
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysInt32(m interface{}) []int32 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []int32{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int32 </span><span class="cov8" title="1">{
                panic("map key type required int32")</span>
        }

        <span class="cov8" title="1">result := make([]int32, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, int32(v.Int()))
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysInt64(m interface{}) []int64 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []int64{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int64 </span><span class="cov8" title="1">{
                panic("map key type required int64")</span>
        }

        <span class="cov8" title="1">result := make([]int64, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, v.Int())
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysInt(m interface{}) []int <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []int{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int </span><span class="cov8" title="1">{
                panic("map key type required int")</span>
        }

        <span class="cov8" title="1">result := make([]int, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, int(v.Int()))
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysInt8(m interface{}) []int8 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []int8{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int8 </span><span class="cov8" title="1">{
                panic("map key type required int8")</span>
        }

        <span class="cov8" title="1">result := make([]int8, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, int8(v.Int()))
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysInt16(m interface{}) []int16 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []int16{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Int16 </span><span class="cov8" title="1">{
                panic("map key type required int16")</span>
        }

        <span class="cov8" title="1">result := make([]int16, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, int16(v.Int()))
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysUint(m interface{}) []uint <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []uint{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint </span><span class="cov8" title="1">{
                panic("map key type required uint")</span>
        }

        <span class="cov8" title="1">result := make([]uint, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, uint(v.Uint()))
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysUint8(m interface{}) []uint8 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []uint8{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint8 </span><span class="cov8" title="1">{
                panic("map key type required uint8")</span>
        }

        <span class="cov8" title="1">result := make([]uint8, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, uint8(v.Uint()))
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysUint16(m interface{}) []uint16 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []uint16{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Uint16 </span><span class="cov8" title="1">{
                panic("map key type required uint16")</span>
        }

        <span class="cov8" title="1">result := make([]uint16, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, uint16(v.Uint()))
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysFloat32(m interface{}) []float32 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []float32{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Float32 </span><span class="cov8" title="1">{
                panic("map key type required float32")</span>
        }

        <span class="cov8" title="1">result := make([]float32, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, float32(v.Float()))
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysFloat64(m interface{}) []float64 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []float64{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        if keyType.Kind() != reflect.Float64 </span><span class="cov8" title="1">{
                panic("map key type required float64")</span>
        }

        <span class="cov8" title="1">result := make([]float64, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, v.Float())
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysInterface(m interface{}) []interface{} <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov8" title="1">result := make([]interface{}, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, v.Interface())
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysAny(m interface{}) []interface{} <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov8" title="1">result := make([]interface{}, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, v.Interface())
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapKeysNumber(m interface{}) []interface{} <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov8" title="1">keyType := t.Type().Key()
        switch keyType.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
                reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
                reflect.Float32, reflect.Float64:<span class="cov8" title="1"></span>
                // valid number types
        default:<span class="cov8" title="1">
                panic("map key type required number")</span>
        }

        <span class="cov8" title="1">result := make([]interface{}, 0, t.Len())
        for _, v := range t.MapKeys() </span><span class="cov8" title="1">{
                result = append(result, v.Interface())
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapValues[K constraints.Ordered, V any](m map[K]V) []V <span class="cov8" title="1">{
        res := make([]V, 0, len(m))
        for _, v := range m </span><span class="cov8" title="1">{
                res = append(res, v)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func MapValuesAny(m interface{}) []interface{} <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov8" title="1">result := make([]interface{}, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov8" title="1">{
                result = append(result, iter.Value().Interface())
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapValuesString(m interface{}) []string <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []string{}
        }</span>

        <span class="cov8" title="1">result := make([]string, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov8" title="1">{
                result = append(result, iter.Value().String())
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapValuesInt(m interface{}) []int <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []int{}
        }</span>

        <span class="cov8" title="1">result := make([]int, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov8" title="1">{
                result = append(result, int(iter.Value().Int()))
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MapValuesFloat64(m interface{}) []float64 <span class="cov8" title="1">{
        t := reflect.ValueOf(m)
        if t.Kind() != reflect.Map </span><span class="cov8" title="1">{
                panic("required map type")</span>
        }
        <span class="cov8" title="1">if t.IsNil() </span><span class="cov8" title="1">{
                return []float64{}
        }</span>

        <span class="cov8" title="1">result := make([]float64, 0, t.Len())
        iter := t.MapRange()
        for iter.Next() </span><span class="cov8" title="1">{
                result = append(result, iter.Value().Float())
        }</span>

        <span class="cov8" title="1">return result</span>
}

func MergeMap[K constraints.Ordered, V any](source, target map[K]V) map[K]V <span class="cov8" title="1">{
        res := make(map[K]V, len(source))
        
        // Manual clone implementation
        for k, v := range source </span><span class="cov8" title="1">{
                res[k] = v
        }</span>

        <span class="cov8" title="1">if len(target) &gt; 0 </span><span class="cov8" title="1">{
                for k, v := range target </span><span class="cov8" title="1">{
                        res[k] = v
                }</span>
        }

        <span class="cov8" title="1">return res</span>
}

func KeyBy(list interface{}, fieldName string) interface{} <span class="cov8" title="1">{
        if list == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">lv := reflect.ValueOf(list)

        switch lv.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                panic("list required slice or array type")</span>
        }

        <span class="cov8" title="1">ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                evs = evs.Elem()
        }</span>

        <span class="cov8" title="1">if evs.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                panic("list element is not struct")</span>
        }

        <span class="cov8" title="1">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov8" title="1">m := reflect.MakeMapWithSize(reflect.MapOf(field.Type, ev), lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov8" title="1">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov8" title="1">if !elemStruct.IsValid() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov8" title="1">m.SetMapIndex(elemStruct.FieldByIndex(field.Index), elem)</span>
        }

        <span class="cov8" title="1">return m.Interface()</span>
}

func KeyByUint64[M any](list []*M, fieldName string) map[uint64]*M <span class="cov8" title="1">{
        if len(list) == 0 </span><span class="cov8" title="1">{
                return map[uint64]*M{}
        }</span>

        <span class="cov8" title="1">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                evs = evs.Elem()
        }</span>

        <span class="cov8" title="1">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov8" title="1">m := make(map[uint64]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov8" title="1">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov8" title="1">if !elemStruct.IsValid() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov8" title="1">m[elemStruct.FieldByIndex(field.Index).Uint()] = elem.Interface().(*M)</span>
        }

        <span class="cov8" title="1">return m</span>
}

func KeyByInt64[M any](list []*M, fieldName string) map[int64]*M <span class="cov8" title="1">{
        if len(list) == 0 </span><span class="cov8" title="1">{
                return map[int64]*M{}
        }</span>

        <span class="cov8" title="1">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                evs = evs.Elem()
        }</span>

        <span class="cov8" title="1">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov8" title="1">m := make(map[int64]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov8" title="1">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov8" title="1">if !elemStruct.IsValid() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov8" title="1">m[elemStruct.FieldByIndex(field.Index).Int()] = elem.Interface().(*M)</span>
        }

        <span class="cov8" title="1">return m</span>
}

func KeyByString[M any](list []*M, fieldName string) map[string]*M <span class="cov8" title="1">{
        if len(list) == 0 </span><span class="cov8" title="1">{
                return map[string]*M{}
        }</span>

        <span class="cov8" title="1">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                evs = evs.Elem()
        }</span>

        <span class="cov8" title="1">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov8" title="1">m := make(map[string]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov8" title="1">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov8" title="1">if !elemStruct.IsValid() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov8" title="1">m[elemStruct.FieldByIndex(field.Index).String()] = elem.Interface().(*M)</span>
        }

        <span class="cov8" title="1">return m</span>
}

func KeyByInt32[M any](list []*M, fieldName string) map[int32]*M <span class="cov8" title="1">{
        if len(list) == 0 </span><span class="cov8" title="1">{
                return map[int32]*M{}
        }</span>

        <span class="cov8" title="1">lv := reflect.ValueOf(list)

        ev := lv.Type().Elem()
        evs := ev
        for evs.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                evs = evs.Elem()
        }</span>

        <span class="cov8" title="1">field, ok := evs.FieldByName(fieldName)
        if !ok </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("field %s not found", fieldName))</span>
        }

        <span class="cov8" title="1">m := make(map[int32]*M, lv.Len())
        for i := 0; i &lt; lv.Len(); i++ </span><span class="cov8" title="1">{
                elem := lv.Index(i)
                elemStruct := elem
                for elemStruct.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        elemStruct = elemStruct.Elem()
                }</span>

                <span class="cov8" title="1">if !elemStruct.IsValid() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if elemStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        panic("element not struct")</span>
                }

                <span class="cov8" title="1">m[int32(elemStruct.FieldByIndex(field.Index).Int())] = elem.Interface().(*M)</span>
        }

        <span class="cov8" title="1">return m</span>
}

func Slice2Map[M constraints.Ordered](list []M) map[M]bool <span class="cov8" title="1">{
        m := make(map[M]bool, len(list))

        for _, v := range list </span><span class="cov8" title="1">{
                m[v] = true
        }</span>

        <span class="cov8" title="1">return m</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package anyx

import (
        "errors"
        "fmt"
        "math"
        "strings"
        "sync"

        "github.com/lazygophers/utils/candy"
        "github.com/lazygophers/utils/json"
        "go.uber.org/atomic"
        "gopkg.in/yaml.v3"
)

type MapAny struct {
        data *sync.Map
        cut  *atomic.Bool
        seq  *atomic.String
}

var (
        ErrNotFound = errors.New("not found")
)

func NewMap(m map[string]interface{}) *MapAny <span class="cov8" title="1">{
        m2 := &amp;MapAny{
                data: &amp;sync.Map{},
                cut:  atomic.NewBool(false),
                seq:  atomic.NewString(""),
        }
        for k, v := range m </span><span class="cov8" title="1">{
                m2.data.Store(k, v)
        }</span>
        <span class="cov8" title="1">return m2</span>
}

func NewMapWithJson(s []byte) (*MapAny, error) <span class="cov8" title="1">{
        var m map[string]interface{}
        err := json.Unmarshal(s, &amp;m)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return NewMap(m), nil</span>
}

func NewMapWithYaml(s []byte) (*MapAny, error) <span class="cov8" title="1">{
        var m map[string]interface{}
        err := yaml.Unmarshal(s, &amp;m)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return NewMap(m), nil</span>
}

func NewMapWithAny(s interface{}) (*MapAny, error) <span class="cov8" title="1">{
        buf, err := json.Marshal(s)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var m map[string]interface{}
        err = yaml.Unmarshal(buf, &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return NewMap(m), nil</span>
}

func (p *MapAny) EnableCut(seq string) *MapAny <span class="cov8" title="1">{
        p.cut.Store(true)
        p.seq.Store(seq)
        return p
}</span>

func (p *MapAny) DisableCut() *MapAny <span class="cov8" title="1">{
        p.cut.Store(false)
        return p
}</span>

func (p *MapAny) Set(key string, value interface{}) <span class="cov8" title="1">{
        p.data.Store(key, value)
}</span>

func (p *MapAny) Get(key string) (interface{}, error) <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return nil, ErrNotFound
        }</span>

        <span class="cov8" title="1">return val, nil</span>
}

func (p *MapAny) get(key string) (interface{}, bool) <span class="cov8" title="1">{
        var val interface{}
        var ok bool

        if val, ok = p.data.Load(key); ok </span><span class="cov8" title="1">{
                return val, true
        }</span>
        <span class="cov8" title="1">if !p.cut.Load() </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">seq := p.seq.Load()
        keys := strings.Split(key, seq)

        data := p.data
        var m *MapAny
        for len(keys) &gt; 1 </span><span class="cov8" title="1">{
                k := keys[0]
                keys = keys[1:]

                val, ok = data.Load(k)
                if !ok </span><span class="cov8" title="1">{
                        return nil, false
                }</span>

                <span class="cov8" title="1">m = p.toMap(val)
                if m == nil </span><span class="cov0" title="0">{
                        return nil, false
                }</span>

                <span class="cov8" title="1">data = m.data</span>
        }

        <span class="cov8" title="1">if len(keys) &gt; 0 </span><span class="cov8" title="1">{
                if val, ok = data.Load(keys[0]); ok </span><span class="cov8" title="1">{
                        return val, true
                }</span>
                <span class="cov8" title="1">return nil, false</span>
        }

        <span class="cov0" title="0">return nil, false</span>
}

func (p *MapAny) Exists(key string) bool <span class="cov8" title="1">{
        _, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (p *MapAny) GetBool(key string) bool <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return candy.ToBool(val)</span>
}

func (p *MapAny) GetInt(key string) int <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return candy.ToInt(val)</span>
}

func (p *MapAny) GetInt32(key string) int32 <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return candy.ToInt32(val)</span>
}

func (p *MapAny) GetInt64(key string) int64 <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return candy.ToInt64(val)</span>
}

func (p *MapAny) GetUint16(key string) uint16 <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return candy.ToUint16(val)</span>
}

func (p *MapAny) GetUint32(key string) uint32 <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return candy.ToUint32(val)</span>
}

func (p *MapAny) GetUint64(key string) uint64 <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return candy.ToUint64(val)</span>
}

func (p *MapAny) GetFloat64(key string) float64 <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return candy.ToFloat64(val)</span>
}

func (p *MapAny) GetString(key string) string <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return candy.ToString(val)</span>
}

func (p *MapAny) GetBytes(key string) []byte <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return []byte("")
        }</span>

        <span class="cov8" title="1">switch x := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                if x </span><span class="cov8" title="1">{
                        return []byte("1")
                }</span>
                <span class="cov8" title="1">return []byte("0")</span>
        case int:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int8:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int16:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int32:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case int64:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint8:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint16:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint32:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case uint64:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%d", x))</span>
        case float32:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%v", x))</span>
        case float64:<span class="cov8" title="1">
                return []byte(fmt.Sprintf("%v", x))</span>
        case string:<span class="cov8" title="1">
                return []byte(x)</span>
        case []byte:<span class="cov8" title="1">
                return x</span>
        default:<span class="cov8" title="1">
                return []byte("")</span>
        }
}

func (p *MapAny) GetMap(key string) *MapAny <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return NewMap(nil)
        }</span>

        <span class="cov8" title="1">return p.toMap(val)</span>
}

func (p *MapAny) toMap(val interface{}) *MapAny <span class="cov8" title="1">{
        switch x := val.(type) </span>{
        case bool, int, int8, int16, int32, int64,
                uint, uint8, uint16, uint32, uint64,
                float32, float64:<span class="cov8" title="1">
                return NewMap(nil)</span>
        case string:<span class="cov8" title="1">
                var m map[string]interface{}
                err := json.Unmarshal([]byte(x), &amp;m)
                if err != nil </span><span class="cov8" title="1">{
                        return NewMap(nil)
                }</span>
                <span class="cov8" title="1">return NewMap(m)</span>
        case []byte:<span class="cov8" title="1">
                var m map[string]interface{}
                err := json.Unmarshal(x, &amp;m)
                if err != nil </span><span class="cov8" title="1">{
                        return NewMap(nil)
                }</span>
                <span class="cov8" title="1">return NewMap(m)</span>
        case map[string]interface{}:<span class="cov8" title="1">
                return NewMap(x)</span>
        case map[interface{}]interface{}:<span class="cov8" title="1">
                m := NewMap(nil)
                for k, v := range x </span><span class="cov8" title="1">{
                        m.Set(candy.ToString(k), v)
                }</span>
                <span class="cov8" title="1">return m</span>
        default:<span class="cov8" title="1">
                buf, err := json.Marshal(x)
                if err != nil </span><span class="cov8" title="1">{
                        return NewMap(nil)
                }</span>
                <span class="cov8" title="1">var m map[string]interface{}
                err = json.Unmarshal(buf, &amp;m)
                if err != nil </span><span class="cov8" title="1">{
                        return NewMap(nil)
                }</span>
                <span class="cov8" title="1">return NewMap(m)</span>
        }
}

func (p *MapAny) GetSlice(key string) []interface{} <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">switch x := val.(type) </span>{
        case []bool:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int8:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int16:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int32:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int64:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint8:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint16:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint32:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint64:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float32:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float64:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []string:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case [][]byte:<span class="cov8" title="1">
                var v []interface{}
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []interface{}:<span class="cov8" title="1">
                return x</span>
        default:<span class="cov8" title="1">
                return []interface{}{}</span>
        }
}

func (p *MapAny) GetStringSlice(key string) []string <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">switch x := val.(type) </span>{
        case []bool:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int8:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int16:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int32:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int64:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint8:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint16:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint32:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint64:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float32:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float64:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []string:<span class="cov8" title="1">
                return x</span>
        case [][]byte:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, string(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []interface{}:<span class="cov8" title="1">
                var v []string
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToString(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        default:<span class="cov8" title="1">
                return []string{}</span>
        }
}

func (p *MapAny) GetUint64Slice(key string) []uint64 <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">switch x := val.(type) </span>{
        case []bool:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int8:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int16:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int32:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int64:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint8:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint16:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint32:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint64:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, val)
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float32:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float64:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []string:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case [][]byte:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []interface{}:<span class="cov8" title="1">
                var v []uint64
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint64(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        default:<span class="cov8" title="1">
                return []uint64{}</span>
        }
}

func (p *MapAny) GetInt64Slice(key string) []int64 <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return candy.ToInt64Slice(val)</span>
}

func (p *MapAny) GetUint32Slice(key string) []uint32 <span class="cov8" title="1">{
        val, ok := p.get(key)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">switch x := val.(type) </span>{
        case []bool:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int8:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int16:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int32:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []int64:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint8:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint16:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []uint32:<span class="cov8" title="1">
                return x</span>
        case []uint64:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float32:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []float64:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []string:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case [][]byte:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        case []interface{}:<span class="cov8" title="1">
                var v []uint32
                for _, val := range x </span><span class="cov8" title="1">{
                        v = append(v, candy.ToUint32(val))
                }</span>
                <span class="cov8" title="1">return v</span>
        default:<span class="cov8" title="1">
                return []uint32{}</span>
        }
}

func (p *MapAny) ToSyncMap() *sync.Map <span class="cov8" title="1">{
        var m sync.Map
        p.data.Range(func(key, value interface{}) bool </span><span class="cov8" title="1">{
                m.Store(key, value)
                return true
        }</span>)
        <span class="cov8" title="1">return &amp;m</span>
}

func (p *MapAny) ToMap() map[string]interface{} <span class="cov8" title="1">{
        m := map[string]interface{}{}
        p.data.Range(func(key, value interface{}) bool </span><span class="cov8" title="1">{
                k := candy.ToString(key)

                switch x := value.(type) </span>{
                case float32:<span class="cov8" title="1">
                        if math.Floor(float64(x)) == float64(x) </span><span class="cov8" title="1">{
                                m[k] = int32(x)
                        }</span> else<span class="cov8" title="1"> {
                                m[k] = x
                        }</span>
                case float64:<span class="cov8" title="1">
                        if math.Floor(x) == x </span><span class="cov8" title="1">{
                                m[k] = int64(x)
                        }</span> else<span class="cov8" title="1"> {
                                m[k] = x
                        }</span>
                case *MapAny:<span class="cov8" title="1">
                        m[k] = x.ToMap()</span>
                case bool,
                        int, int8, int16, int32, int64,
                        uint, uint8, uint16, uint32, uint64,
                        string, []byte:<span class="cov8" title="1">
                        m[k] = x</span>
                default:<span class="cov8" title="1">
                        m[k] = x</span>
                }

                <span class="cov8" title="1">return true</span>
        })
        <span class="cov8" title="1">return m</span>
}

func (p *MapAny) Clone() *MapAny <span class="cov8" title="1">{
        return &amp;MapAny{
                data: p.ToSyncMap(),
                cut:  atomic.NewBool(p.cut.Load()),
                seq:  atomic.NewString(p.seq.Load()),
        }
}</span>

func (p *MapAny) Range(f func(key, value interface{}) bool) <span class="cov8" title="1">{
        p.data.Range(func(key, value interface{}) bool </span><span class="cov8" title="1">{
                return f(key, value)
        }</span>)
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
